{"meta":{"title":"易语的博客","subtitle":"易语的博客","description":"这是易语的博客","author":"易语","url":"http://www.yiyuclub.club","root":"/"},"pages":[{"title":"about","date":"2019-05-06T02:32:59.000Z","updated":"2019-06-24T09:13:28.066Z","comments":true,"path":"about/index.html","permalink":"http://www.yiyuclub.club/about/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2019-05-06T01:52:42.000Z","updated":"2019-06-24T09:13:28.050Z","comments":false,"path":"/404.html","permalink":"http://www.yiyuclub.club//404.html","excerpt":"","text":"&lt;!DOCTYPE html&gt; 404"},{"title":"categories","date":"2019-05-06T01:44:43.000Z","updated":"2019-06-24T09:13:28.066Z","comments":true,"path":"categories/index.html","permalink":"http://www.yiyuclub.club/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-05-06T02:30:02.000Z","updated":"2019-06-24T09:13:28.066Z","comments":true,"path":"archives/index.html","permalink":"http://www.yiyuclub.club/archives/index.html","excerpt":"","text":""},{"title":"","date":"2019-06-24T09:13:28.066Z","updated":"2019-06-24T09:13:28.066Z","comments":true,"path":"friends/index.html","permalink":"http://www.yiyuclub.club/friends/index.html","excerpt":"","text":"layout: links # 必须title: 我的朋友们 # 可选，这是友链页的标题date: 2019-05-06 09:45:23links: group: 技术大佬icon: fas fa-user-tieitems: name: # 博客名avatar: # 头像链接url: # 博客链接backgroundColor: ‘#3E74C9’ # 卡片背景颜色textColor: ‘#fff’ # 卡片文字颜色tags: # 标签 标签1 标签2 group: 分组2icon: fas fa-user-tieitems: name: # 博客名avatar: # 头像链接url: # 博客链接backgroundColor: ‘#3E74C9’ # 卡片背景颜色textColor: ‘#fff’ # 卡片文字颜色tags: # 标签 标签1 标签2"},{"title":"projects","date":"2019-05-06T02:33:37.000Z","updated":"2019-06-24T09:13:28.066Z","comments":true,"path":"projects/index.html","permalink":"http://www.yiyuclub.club/projects/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-05-06T01:45:09.000Z","updated":"2019-06-24T09:13:28.066Z","comments":true,"path":"tags/index.html","permalink":"http://www.yiyuclub.club/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"（软考高项笔记一）信息系统基础知识","slug":"（软考高项笔记一）信息系统基础知识","date":"2020-02-24T08:06:55.000Z","updated":"2020-02-24T08:16:38.007Z","comments":true,"path":"2020/02/24/（软考高项笔记一）信息系统基础知识/","link":"","permalink":"http://www.yiyuclub.club/2020/02/24/（软考高项笔记一）信息系统基础知识/","excerpt":"信息系统基础知识","text":"信息系统基础知识 1.信息系统的概念 泛指收集、存储、处理和传播各种信息的 具有完整功能的集合体 2.信息系统发展阶段 ①：电子数据处理阶段 (EDP) ②：事务处理阶段 (TPS) ③：管理信息系统阶段 (MIS) ④：决策支持系统阶段 (DDS) 3.信息系统类型按数据环境分类 ①：数据文件 ②：应用数据库 ③：主题数据库 ④：信息检索系统 按应用层此分类 ①：战略级信息系统（企业的最高管理层） ②：战术级信息系统（企业的中层经理及其管理的部门） ③：操作级信息系统（企业的业务部门，即使用者） ④：事务级信息系统（企业的管理业务人员） 3.信息系统的建设生命周期 信息系统从产生到消亡的整个过程 为信息系统的生命周期 生命周期四阶段 ①：系统规划阶段（信息系统的产生阶段、信息系统的概念阶段或者是信息系统的需求分析阶段） ②：系统开发阶段（总体规划、系统分析、系统设计、系统实施和系统验收阶段。） ③：系统运行与维护阶段（排错性维护、适应性维护、完善性维护和预防性维护） ④：系统更新阶段 信息系统建设原则 ①：高层管理人员介入原则 ②：用户参与开发原则（有确定的范围，参与全过程的开发，深度参与系统开发） ③：自顶向下规划原则 ④：工程化原则 ⑤：其他原则 信息系统规划方法① 企业系统规划方法（Business System Planning, BSP） 关键点：利用过程/数据矩阵，即UC矩阵 ② 战略数据规划方法 数据环境对于信息系统至关重要 4钟数据环境 建设主题数据库是信息系统开发的中心任务 围绕主题数据库搞好应用软件开发。 ③ 信息工程方法 信息工程方法是其他两种方法的总结和提升，而其他两种方法则是信息工程方法的基础和核心 ④ 关键成功因（Critical Success Factors, CSF) 法 ⑤ 战略目标集合转化法（Strategy Set Transformation, SST) 信息系统开发方法 ①：结构化方法 ②：快速原型法 ③：面向对象方法","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.yiyuclub.club/categories/学习笔记/"},{"name":"软考高项","slug":"学习笔记/软考高项","permalink":"http://www.yiyuclub.club/categories/学习笔记/软考高项/"}],"tags":[{"name":"软考","slug":"软考","permalink":"http://www.yiyuclub.club/tags/软考/"},{"name":"高项","slug":"高项","permalink":"http://www.yiyuclub.club/tags/高项/"}]},{"title":"数据结构（排序---希尔排序）","slug":"数据结构（排序-希尔排序）","date":"2019-08-01T00:46:02.000Z","updated":"2019-08-01T00:46:31.712Z","comments":true,"path":"2019/08/01/数据结构（排序-希尔排序）/","link":"","permalink":"http://www.yiyuclub.club/2019/08/01/数据结构（排序-希尔排序）/","excerpt":"数据结构（排序—希尔排序）","text":"数据结构（排序—希尔排序） 概念定义 其为插入排序的加强版，也叫递减增量排序算法先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序 适用范围 数据量中等 步骤定义 ① 得到一组待排序的数组； ② 设置增量gap，gap依次为，数组大小的一半、再一半、…直到为1 ③ 根据gap的大小划分小组，如：gap=2，0-9的数组划分为0-4，5-9 ④ 然后两组对应的数据相互比较，如：0与5，1与6…. ⑤ 按gap继续分组比较，直接为1，最后依次比较交换即可 注：如果元素个数为单数，先不管，按照规则先运算，等gap改变，总能排到 图解 注：图出自https://www.jianshu.com/p/40dcc3b83ddc 性能时间复杂度 根据增量gap的不同会有不一样的结果 空间复杂度 不需要消耗额外的空间资源复杂度：O(1) 稳定性 交换有跳跃性稳定性：不稳定 复杂性 在排序中插入排序复杂性 ：极其复杂 java demo//希尔排序 public void shellSort(int[] arr){ //临时变量 int temp; //数组长度 int len = arr.length; //得到gap增量，除2递减 for(int gap=len/2; gap&gt;=1; gap=gap/2){ //得到两数对比中右边的值 for(int i=gap; i&lt;len; i++){ //得到两数对比中做边的值，并左右对比 for(int j=i-gap; j&gt;=0&amp;&amp;arr[j]&gt;arr[j+gap]; j=j-gap){ //成立则交换 temp = arr[j]; arr[j] = arr[j+gap]; arr[j+gap]=temp; } } } }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/categories/数据结构/"},{"name":"排序","slug":"数据结构/排序","permalink":"http://www.yiyuclub.club/categories/数据结构/排序/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/tags/数据结构/"},{"name":"排序","slug":"排序","permalink":"http://www.yiyuclub.club/tags/排序/"},{"name":"直接选择排序","slug":"直接选择排序","permalink":"http://www.yiyuclub.club/tags/直接选择排序/"}]},{"title":"数据结构（排序---直接选择排序）","slug":"数据结构（排序-直接选择排序）","date":"2019-07-31T03:15:33.000Z","updated":"2019-07-31T03:16:33.251Z","comments":true,"path":"2019/07/31/数据结构（排序-直接选择排序）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/31/数据结构（排序-直接选择排序）/","excerpt":"数据结构（排序—直接选择排序）","text":"数据结构（排序—直接选择排序） 概念定义 从第一位开始依次和后面所有的数比较，然后交换 适用范围 较为常用不在乎时间且使用简单的情况下 步骤定义 ① 得到一组待排序的数组； ② 选择数组第一个数，依次和后面第二个到最后一个比较，满足条件则交换， ③ 选择数组第二个数，依次和后面第三个到最后一个比较，满足条件则交换 ④ 后面如上所示 图解 性能时间复杂度 由于无论是最好情况还是最坏情况，所需要的步骤都一直，花费的时间也一致时间复杂度： O(n的2次方) 空间复杂度 不需要消耗额外的空间资源复杂度：O(1) 稳定性 存在着不相邻元素之间的互换稳定性：不稳定 复杂性 在排序中插入排序复杂性 ：简单 java demo//直接选择排序 public void selectionSort(int[] str){ //长度 int length = str.length; //交换时的中间值 int temp = 0; //遍历0-length的数 for(int i = 0 ; i &lt; length ;i++){ //遍历i之后的数 for(int j = i+1;j &lt; length ; j++){ //数组i&gt;数组j则交换 if(str[j] &lt; str[i] ){ temp = str[i]; str[i] = str[j]; str[j] = temp; } } } }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/categories/数据结构/"},{"name":"排序","slug":"数据结构/排序","permalink":"http://www.yiyuclub.club/categories/数据结构/排序/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/tags/数据结构/"},{"name":"排序","slug":"排序","permalink":"http://www.yiyuclub.club/tags/排序/"},{"name":"直接选择排序","slug":"直接选择排序","permalink":"http://www.yiyuclub.club/tags/直接选择排序/"}]},{"title":"数据结构（排序---堆排序）","slug":"数据结构（排序-堆排序）","date":"2019-07-31T02:34:54.000Z","updated":"2019-07-31T03:16:03.837Z","comments":true,"path":"2019/07/31/数据结构（排序-堆排序）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/31/数据结构（排序-堆排序）/","excerpt":"数据结构（排序—堆排序）","text":"数据结构（排序—堆排序） 概念定义 大顶堆：每个结点的值都大于或等于其左右孩子结点的值，在堆排序算法中用于升序排列小顶堆：每个结点的值都小于或等于其左右孩子结点的值，在堆排序算法中用于降序排列 适用范围 从数据中找到最大最小的数数据量庞大且需求是不消耗过多空间 步骤定义 ① 得到一组待排序的数组（此次按大顶堆处理）； ② 开始最大堆化，先找到最后一个非叶子节点(n/2 -1)， ③ 其左右子节点（2(n/2 -1+1）比较，大的一端和其该节点比较，大则交换 ④ 依次自下而上，自右而左找到非叶子结点，与其左右子节点比较 ⑤ 大顶堆完成后，拿出堆顶（最大元素）放入数组最后一位注：放最后一位其实就是和第⑥ 部的位置交换，其只是达到了它最终的位置 ⑥ 重新调整为最大堆结构 ⑦ 按⑤ 步骤向上依次取出，得到从小到大的数组 图解 注：图出自https://www.douban.com/group/topic/128720541/ 性能时间复杂度 由于无论是最好情况还是最坏情况，所需要的步骤都一直，花费的时间也一致时间复杂度：O(nlog2n) 空间复杂度 不需要消耗额外的空间资源复杂度：O(1) 稳定性 排序前和排序后相等的值顺序可能改变稳定性：不稳定 复杂性 在排序中插入排序复杂性 ：较为复杂 java demo//堆排序 public void headSort(int[] str){ int temp; //得到数组长度 int length = str.length; //找到最后一个非叶子节点length/2-1，然后向前依次寻找,最大堆化 for(int i =length/2-1;i &gt;= 0;i--){ //堆化 headify(str,length,i); } //开始排序 for(int j = length - 1;j &gt; 0 ; j--){ //交换堆顶和树的最后元素（最后元素一次往前） temp = str[j]; str[j] = str[0]; str[0] = temp; //最大堆化 headify(str,j,0); } } //建堆 public void headify(int[] str,int length,int node){ int maxNode; int temp = 0; for (int i = 2*node+1;i&lt;length;i = 2*node+1){ temp = i; //判断左右子节点哪一个大,i+1&lt;lengt是为了防止最后一个非叶子节点只有一个子节点 if( i+1&lt;length &amp;&amp; str[i]&lt;str[i+1]){ temp = i+1; } //节点与最大子节点比较 if(str[node] &lt; str[temp]){ maxNode = str[node]; str[node] = str[temp]; str[temp] = maxNode; //交换后跟着节点往下继续和下面的子节点排序 node = temp; }else{ break; } } }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/categories/数据结构/"},{"name":"排序","slug":"数据结构/排序","permalink":"http://www.yiyuclub.club/categories/数据结构/排序/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/tags/数据结构/"},{"name":"排序","slug":"排序","permalink":"http://www.yiyuclub.club/tags/排序/"},{"name":"堆排序","slug":"堆排序","permalink":"http://www.yiyuclub.club/tags/堆排序/"}]},{"title":"数据结构（排序---合并排序）","slug":"数据结构（排序-合并排序）","date":"2019-07-29T01:11:49.000Z","updated":"2019-07-31T03:15:56.713Z","comments":true,"path":"2019/07/29/数据结构（排序-合并排序）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/29/数据结构（排序-合并排序）/","excerpt":"数据结构（排序—合并排序）","text":"数据结构（排序—合并排序） 概念定义 先分后合，把一组数划分为不可分割的单元，两两比较，合并，合并后的数据再次两两比较，最终成为一组有序的数据 适用范围 追求数据稳定数据量较大，且空间花费不做要求 步骤定义 ① 得到一组待排序的数组；② 把数组按1/2的方法依次划分为两两一组的数据（如果数不为双数，则多出来的单个数为一组）；③ 两个为一组的数据相互比较，按规则换位；④ 两组换位的数组再相互比较（先比较两者头，分别依次向后遍历比较）⑤ 逐级数据比较，最后得倒有序数组 图解 组与组排序方法 ① 拿上述图举例，两数组0与0比较，把小的放入到新数组的第一位② 被拿出的数组+1，1与0比较，把小的放入到新的数组③ 大致步骤②依次+1，最后得到新数组 性能时间复杂度 由于无论是最好情况还是最坏情况，所需要的步骤都一直，花费的时间也一致时间复杂度：O(nlog2n) 注意：一般数据是随机的，未知情况下平均时间复杂度：Θ(n的二次方) 空间复杂度 两数组比较时需要临时数组作为暂存空间复杂度：O(n) 稳定性 排序前和排序后相等的值顺序不变稳定性：稳定 复杂性 在排序中插入排序复杂性 ：较为复杂 java demo//已排序好的数组 public static int[] str; //临时数组 public static int[] temp; //合并排序01---输入数组 public void mergeInsertStr(int[] str){ if(str.length&lt;=0 || str == null){ return; } temp=new int[str.length]; mergeSortByRecursion(str,0,str.length-1); } //合并排序02----递归 public void mergeSortByRecursion(int[] str,int left,int right){ while (left&lt;right){ //把数组分成两半 int middel = (right+left)/2; //递归分左边两边 mergeSortByRecursion(str,left,middel); //递归分右边两边 mergeSortByRecursion(str,middel+1,right); //切分结束，开始排序 mergeSort(str,left,middel,right); return; } } //合并排序03--排序 public void mergeSort(int[] str,int left,int middel,int right){ //左索引 int lindex = left; //中索引 int tempindex = 0; //右索引 int rindex = middel+1; //比较排序 while (lindex&lt;=middel&amp;&amp;rindex&lt;=right){ if(str[lindex]&lt;=str[rindex]){ temp[tempindex++]=str[lindex++]; }else{ temp[tempindex++]=str[rindex++]; } } //左未被排序的放入数组 while(lindex&lt;=middel){ temp[tempindex++]=str[lindex++]; } //右未被排序的放入数组 while(rindex&lt;=right){ temp[tempindex++]=str[rindex++]; } int t=0; 赋给临时数组 while(left&lt;=right){ str[left++]=temp[t++]; } }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/categories/数据结构/"},{"name":"排序","slug":"数据结构/排序","permalink":"http://www.yiyuclub.club/categories/数据结构/排序/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/tags/数据结构/"},{"name":"排序","slug":"排序","permalink":"http://www.yiyuclub.club/tags/排序/"},{"name":"合并排序","slug":"合并排序","permalink":"http://www.yiyuclub.club/tags/合并排序/"}]},{"title":"数据结构（排序---快速排序）","slug":"数据结构（排序-快速排序）","date":"2019-07-29T01:09:03.000Z","updated":"2019-07-31T03:15:45.473Z","comments":true,"path":"2019/07/29/数据结构（排序-快速排序）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/29/数据结构（排序-快速排序）/","excerpt":"title: 数据结构（排序—快速排序）","text":"title: 数据结构（排序—快速排序） 概念定义 又名：划分交换排序选取基数，各数分别和基数比较，最后一侧小于基数，一侧大于基数 适用范围 实际情况中，此排序为最佳选择，常被使用数据量较大 基准值选择 基准值（pivot）是在排序时被左右两边比较的数① 前后固定位② 随机选取③ 三数取中④ 挖坑法 前后固定位定义 选数据中第一位（或最后一位）作为基准值（判断时，从基准位的另一侧开始判断）第一位和最后一位作为low和high指针移动 步骤 随机选取 三数取中 挖坑法定义 ① 选取数组头作为基数② 从另一侧的尾部向左遍历，直到找到小于基数的值（right位），放到基数的位置③ 然后从左侧开始向右遍历，找到比基数大的值，放入上一步骤right位中④ 直到左右两侧遍历相遇（基数放入该位置），否则重复第② ③步骤⑤ 第一轮结束⑥ 第二轮分别对第一轮基数左右两侧的数重复从①开始的步骤⑦ 直到无法划分，结束 图解 代码 性能时间复杂度① 最坏情况： 后一位的数全都比前面的小，每一位数都要和前面的数比较时间复杂度：Θ(n的二次方) ① 最好情况： 后一位的数全都比前面的大，每一位数都不需要和前面的数比较时间复杂度：Θ(n) 注意：一般数据是随机的，未知情况下平均时间复杂度：Θ(n的二次方) 空间复杂度 由于在空间上并未增加或减少空间，使用量不变空间复杂度：Θ(1),(Θ(1)表示大小未改变) 稳定性 排序前和排序后相等的值顺序不变稳定性：稳定 复杂性 在排序中插入排序复杂性 ：简单 java demo//冒泡排序 public void bubbleSort(int[] data){ //判空 if(data.length==0||data ==null){ return; } //初始化参数，temp暂存点，length长度，isChange是否已换位 int temp = 0; int length = data.length; boolean isChange = false; //轮数，以数组长度为上线 for (int count = 0 ; count &lt; length ; count++){ isChange = false; System.out.println(&quot;第&quot;+count+&quot;轮&quot;); for (int i = 1 ; i &lt; length ; i++){ if(data[i]&lt;data[i-1]){ temp = data[i-1]; data[i-1] = data[i]; data[i] = temp; //声明已交换，还需要继续下一轮 isChange = true; } } //打印测试 for (int i :data){ System.out.print(i+&quot;,&quot;); } //如果没有交换说明已排序完毕 if(isChange == false){ return; } } }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/categories/数据结构/"},{"name":"排序","slug":"数据结构/排序","permalink":"http://www.yiyuclub.club/categories/数据结构/排序/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/tags/数据结构/"},{"name":"排序","slug":"排序","permalink":"http://www.yiyuclub.club/tags/排序/"},{"name":"快速排序","slug":"快速排序","permalink":"http://www.yiyuclub.club/tags/快速排序/"}]},{"title":"数据结构（排序---冒泡排序）","slug":"数据结构（排序-冒泡排序）","date":"2019-07-22T00:56:06.000Z","updated":"2019-07-31T03:03:19.965Z","comments":true,"path":"2019/07/22/数据结构（排序-冒泡排序）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/22/数据结构（排序-冒泡排序）/","excerpt":"数据结构（排序—冒泡排序）","text":"数据结构（排序—冒泡排序） 概念定义 一个数组，从第一位开始，依次和下一位的数进行比较，满足条件则交换交换一个轮回后不一定排序好了，往往需要几轮上述操作 适用范围 适合数据量较小的场合适合数组基本上已经有序的场合 实现步骤① 第一位数和第二位数比较，满足条件交换，反之不交换 ② 第二位数和第三位数比较，满足条件交换，反之不交换 ③ 依次下去，直至最后一位数，第一轮结束 ④ 第二轮按照上述步骤，直至全部无法交换为止- 注意：如果两数相等，后一位的数依然在后（因为没有比前一位小，依然在后） 性能时间复杂度① 最坏情况： 后一位的数全都比前面的小，每一位数都要和前面的数比较时间复杂度：Θ(n的二次方) ① 最好情况： 后一位的数全都比前面的大，每一位数都不需要和前面的数比较时间复杂度：Θ(n) 注意：一般数据是随机的，未知情况下平均时间复杂度：Θ(n的二次方) 空间复杂度 由于在空间上并未增加或减少空间，使用量不变空间复杂度：Θ(1),(Θ(1)表示大小未改变) 稳定性 排序前和排序后相等的值顺序不变稳定性：稳定 复杂性 在排序中插入排序复杂性 ：简单 java demo//冒泡排序 public void bubbleSort(int[] data){ //判空 if(data.length==0||data ==null){ return; } //初始化参数，temp暂存点，length长度，isChange是否已换位 int temp = 0; int length = data.length; boolean isChange = false; //轮数，以数组长度为上线 for (int count = 0 ; count &lt; length ; count++){ isChange = false; System.out.println(&quot;第&quot;+count+&quot;轮&quot;); for (int i = 1 ; i &lt; length ; i++){ if(data[i]&lt;data[i-1]){ temp = data[i-1]; data[i-1] = data[i]; data[i] = temp; //声明已交换，还需要继续下一轮 isChange = true; } } //打印测试 for (int i :data){ System.out.print(i+&quot;,&quot;); } //如果没有交换说明已排序完毕 if(isChange == false){ return; } } }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/categories/数据结构/"},{"name":"排序","slug":"数据结构/排序","permalink":"http://www.yiyuclub.club/categories/数据结构/排序/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/tags/数据结构/"},{"name":"排序","slug":"排序","permalink":"http://www.yiyuclub.club/tags/排序/"},{"name":"冒泡排序","slug":"冒泡排序","permalink":"http://www.yiyuclub.club/tags/冒泡排序/"}]},{"title":"数据结构（排序---插入排序）","slug":"数据结构（排序-插入排序）","date":"2019-07-19T07:55:47.000Z","updated":"2019-07-22T00:08:43.728Z","comments":true,"path":"2019/07/19/数据结构（排序-插入排序）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/19/数据结构（排序-插入排序）/","excerpt":"数据结构（排序—插入排序）","text":"数据结构（排序—插入排序） 概念定义 一组数据，第一位不动，从第二位开始的数依次和前面的数据比较，直到不比前面的数小为止。 适用范围 适合数据量较小的场合适合数组基本上已经有序的场合 实现步骤① 固定数组第一个数 ② 取出数组第二位数与第一位比较，小于则换位，否则依然位于第二位 ③ 取出数组第三位数与第二位比较，小于则换位（否则依然位于第三位），与第一位比较，小于则换位（否则依然位于第二位） ④ 后续的数依次如此，排序结束 注意：如果两数相等，后一位的数依然在后（因为没有比前一位小，依然在后） 性能时间复杂度① 最坏情况： 后一位的数全都比前面的小，每一位数都要和前面的数比较时间复杂度：Θ(n的二次方) ① 最好情况： 后一位的数全都比前面的大，每一位数都不需要和前面的数比较时间复杂度：Θ(n) 注意：一般数据是随机的，未知情况下平均时间复杂度：Θ(n的二次方) 空间复杂度 由于在空间上并未增加或减少空间，使用量不变空间复杂度：Θ(1),(Θ(1)表示大小未改变) 稳定性 插入排序 排序前和排序后相等的值顺序不变稳定性：稳定 复杂性 在排序中插入排序复杂性 ：简单 java demo//插入排序 public void insertSort(int[] data){ //判空停止 if(data.length==0||data == null){ return; } //交换时的临时参数 int temp = 0; //数组大小 int length = data.length; //要去比较的数，从数组第二位开始 for (int i = 1 ; i &lt; length;i++){ //为了不改变i，而使交换后该数的地址跟随，即data[2]和data[3]交换后，data[3]的替换到了data[2] int maxCount =i; //被比较的值 for (int j = i-1 ; j &gt;= 0;j--){ //开始比较，小于即交换 if(data[maxCount] &lt; data[j]){ temp = data[j]; data[j] = data[maxCount]; data[maxCount] = temp; //替换后数组下标减1，跟随该值继续比较 maxCount--; } } } //打印测试 for (int i :data){ System.out.println(i); } }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/categories/数据结构/"},{"name":"排序","slug":"数据结构/排序","permalink":"http://www.yiyuclub.club/categories/数据结构/排序/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/tags/数据结构/"},{"name":"排序","slug":"排序","permalink":"http://www.yiyuclub.club/tags/排序/"},{"name":"插入排序","slug":"插入排序","permalink":"http://www.yiyuclub.club/tags/插入排序/"}]},{"title":"数据结构（算法---穷举）","slug":"数据结构（算法-穷举）","date":"2019-07-19T02:17:50.000Z","updated":"2019-07-19T02:24:21.297Z","comments":true,"path":"2019/07/19/数据结构（算法-穷举）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/19/数据结构（算法-穷举）/","excerpt":"数据结构（算法—穷举）","text":"数据结构（算法—穷举） 概念定义 穷举也叫枚举，就是分析问题，一一列出所有可能符合问题的解 分类顺序列举 根据一个自然数的变化顺序列举 排列列举 根据原有数的排列列举 组合列举 解为一组数据的组合，其无序 步骤确定文体 分析问题，选择使用什么方法列举 选择变量 根据问题，选择变量，根据变量改变列举问题的解 返回解 一一列出得到的解 算法应用百鸡问题密码破译100内素数","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/categories/数据结构/"},{"name":"算法","slug":"数据结构/算法","permalink":"http://www.yiyuclub.club/categories/数据结构/算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"http://www.yiyuclub.club/tags/算法/"},{"name":"穷举","slug":"穷举","permalink":"http://www.yiyuclub.club/tags/穷举/"}]},{"title":"数据结构（算法---动态规划）","slug":"数据结构（算法-动态规划）","date":"2019-07-19T02:10:52.000Z","updated":"2019-07-19T02:13:41.927Z","comments":true,"path":"2019/07/19/数据结构（算法-动态规划）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/19/数据结构（算法-动态规划）/","excerpt":"数据结构（算法—动态规划）","text":"数据结构（算法—动态规划） 概念定义 将待求解的问题分解为若干个阶段，阶段如能分解再分解，最后各阶段的解能得到原问题的解不需要划分为独立子问题 适用特征最优化原理 最优解下的各阶段的解也为最优解 无后效性 该阶段状态确定后，不受后续状态的影响 有重叠子问题 各阶段问题不独立 分类队列式分支界限法 按照先进先出原则选取下一个扩展节点 优先队列式分支界限法 按照优先级选取优先级最高的节点 步骤 初始状态—&gt;决策—&gt;再决策—&gt;再再决策再决策—&gt;…—&gt;结束状态 问题划分 把问题划分阶段，阶段是有序的 阶段状态和变量的确定 根据各阶段情况写出状态，该状态不可被后续操作影响 确定解决方法 根据上阶段状态得出该阶段状态，根据多个阶段的状态可得解决方法 条件 根据条件终止问题 算法应用找零钱问题/背包问题最长递增子序列LIS格子取数/走棋盘","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/categories/数据结构/"},{"name":"算法","slug":"数据结构/算法","permalink":"http://www.yiyuclub.club/categories/数据结构/算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"http://www.yiyuclub.club/tags/算法/"},{"name":"动态规划","slug":"动态规划","permalink":"http://www.yiyuclub.club/tags/动态规划/"}]},{"title":"数据结构（算法---分支界限）","slug":"数据结构（算法-分支界限）","date":"2019-07-19T01:35:51.000Z","updated":"2019-07-19T01:36:17.252Z","comments":true,"path":"2019/07/19/数据结构（算法-分支界限）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/19/数据结构（算法-分支界限）/","excerpt":"数据结构（算法—分支界限）","text":"数据结构（算法—分支界限） 概念定义 把全部可行的解空间不断分割为越来越小的子集（称为分支），并为每个子集内的解的值计算一个下界或上界 基本流程 ① 从树的根节点开始，每个节点只有一次机会成为扩展节点② 如果其扩展节点势必会产生所有子节点③ 如果产生的节点不能解或导致最优解出错，会被舍弃，未被舍弃的会成为活结点，放入活表中④ 重复上述过程直至活结点表中没有节点 目标 找出满足约束条件的一个解或满足约束条件下的解中的相对情况的最优解 优点 可求得最优解平均速度快 缺点 存叶子结点多，耗内存资源 注意：界限法使用广度优先搜索策略，尽早找到子节点 分类队列式分支界限法 按照先进先出原则选取下一个扩展节点 优先队列式分支界限法 按照优先级选取优先级最高的节点 步骤得到分析数据 得到要使用界限法的数据 根节点扩展 从根节点扩展出所有子节点，对每一个子节点判定是否满足约定条件，满足放入活表中，否则舍弃 选择节点 根据分类中的界限法选择活表中的节点 重复求解 重复上述2、3步骤，直至活表中的节点为空 算法应用 主要解决装载问题，即一个容器如何装入物品满足所需要求","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/categories/数据结构/"},{"name":"算法","slug":"数据结构/算法","permalink":"http://www.yiyuclub.club/categories/数据结构/算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"http://www.yiyuclub.club/tags/算法/"},{"name":"迭代","slug":"迭代","permalink":"http://www.yiyuclub.club/tags/迭代/"}]},{"title":"数据结构（算法---迭代）","slug":"数据结构（算法-迭代）","date":"2019-07-19T00:30:17.000Z","updated":"2019-07-19T00:56:03.833Z","comments":true,"path":"2019/07/19/数据结构（算法-迭代）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/19/数据结构（算法-迭代）/","excerpt":"数据结构（算法—迭代）","text":"数据结构（算法—迭代） 概念定义 不断用旧变量值推导出新变量值的过程，而新值又是下次迭代的旧值，如此循环。 特点 ① 常用while坐循环② 迭代次数未知③ 迭代结束后才能得到得迭代的值 分类精确迭代 迭代后的解是个精确的值例子：质因数的分解，最大公约数，进制转换，谷角猜想 近似迭代 迭代后的解是个近似的值例子：二分法，求定积分 步骤确定变量 确定一个因为迭代而不断改变的值 确定迭代公式 确定因为迭代，从原有的值变成现在的值之间的公式 确定迭代控制条件 即迭代何时开始与结束 迭代模型定义 英文名：RUP（Rational Unified Process）中文名：统一软件开发过程，统一软件过程 方法 按每时间段拿出新的样品，新的样品在旧的样品下加入新的需求功能，如此迭代，直至项目周期结束或无限接近客户需求 缺点 周期长成本很高","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/categories/数据结构/"},{"name":"算法","slug":"数据结构/算法","permalink":"http://www.yiyuclub.club/categories/数据结构/算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"http://www.yiyuclub.club/tags/算法/"},{"name":"迭代","slug":"迭代","permalink":"http://www.yiyuclub.club/tags/迭代/"}]},{"title":"数据结构（算法---分治）","slug":"数据结构（算法-分治）","date":"2019-07-18T03:07:06.000Z","updated":"2019-07-18T03:07:32.239Z","comments":true,"path":"2019/07/18/数据结构（算法-分治）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/18/数据结构（算法-分治）/","excerpt":"数据结构（算法—分治）","text":"数据结构（算法—分治） 1.概念定义 把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并 思路 对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解 注意：规模愈大求解愈慢，小则较快 2.适用条件① 问题不断分解成小问题后可以解决 ② 可以分解为若干个相同小问题 ③ 子问题的解能合并为父问题的解 ④ 各子问题相互独立 3.基本操作① 将初始问题分解为若干个相互独立形式与初始问题相同的子问题 ② 若子问题简单则直接解决，否则按照①步骤继续分解 ③ 将子问题向上合并，最后得出初始问题的解 4.算法应用① 二分搜索 ② 大整数乘法 ③ Strassen矩阵乘法 ④ 棋盘覆盖 ⑤ 合并排序 ⑥ 快速排序 ⑦ 线性时间选择 ⑧ 最接近点对问题 ⑨ 循环赛日程表 ⑩ 汉诺塔","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/categories/数据结构/"},{"name":"算法","slug":"数据结构/算法","permalink":"http://www.yiyuclub.club/categories/数据结构/算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"http://www.yiyuclub.club/tags/算法/"},{"name":"贪心","slug":"贪心","permalink":"http://www.yiyuclub.club/tags/贪心/"}]},{"title":"数据结构（算法---贪心）","slug":"数据结构（算法-贪心）","date":"2019-07-18T02:47:03.000Z","updated":"2019-07-18T02:47:38.975Z","comments":true,"path":"2019/07/18/数据结构（算法-贪心）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/18/数据结构（算法-贪心）/","excerpt":"数据结构（算法—贪心）","text":"数据结构（算法—贪心） 1.概念定义 不从整体考虑，做到局部最优选择，已到达全局的优化选择其不一定达到最优解 思路 自顶向下，从一个基本解开始，不断向最优解靠近，直到算法不能进行 2.贪心优解条件贪心选择 所求问题的整体最优解可以通过一系列局部最优的选采用从顶向下、以迭代的方法做出相继选择，每做一次贪心选择就将所求问题简化为一个规模更小的子问题 最优子结构 当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质 3.基本操作① 分析某一数学问题 ② 把全局的数学问题划分为各个小项 ③ 把每一个小项求解，如果不是最优继续分解，直到得到最优解 ④ 把最优解向上合成（即局部最优解合成全局最优解） 4.算法缺陷① 不能保证其为最优解 ② 其有范围性，不能保证最大最小解 ③ 范围约束性 5.算法应用背包问题（1）题目 一背包，只能存放 40g物品，有4个物品，如何放入才能使其总价值最大？ （2）策略： ① 总价值最高 ② 总重量最轻 ③ 单位重量价值最大 注意：此题贪心算法得不到最优解 马踏棋盘（1）题目 在8×8方格的棋盘上，从任意指定方格出发，为马寻找一条走遍棋盘每一格并且只经过一次的一条路径 （2）思路 ① 确定初始坐标x，y ② 得到解则返回，否则继续向下传入坐标 ③ 递归得到解","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/categories/数据结构/"},{"name":"算法","slug":"数据结构/算法","permalink":"http://www.yiyuclub.club/categories/数据结构/算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"http://www.yiyuclub.club/tags/算法/"},{"name":"贪心","slug":"贪心","permalink":"http://www.yiyuclub.club/tags/贪心/"}]},{"title":"数据结构（算法---递归）","slug":"数据结构（算法-递归）","date":"2019-07-18T02:00:16.000Z","updated":"2019-07-19T00:39:48.671Z","comments":true,"path":"2019/07/18/数据结构（算法-递归）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/18/数据结构（算法-递归）/","excerpt":"数据结构（算法—递归）","text":"数据结构（算法—递归） 1.概念定义 在程序中不断反复调用自身来达到求解问题的方法在方法内通过语句调用该方法 优点 代码简介清晰方便阅读 缺点 并没有减少内存消耗递归比非递归要慢些，故其增加时间成本递归深度过大，还可能出现溢出，死循环 注意：递归需要设置return返回，不然会无限循环 2.分类直接递归 在此方法中调用方法本身 间接递归 接地调用方法如：a - b - b - a- b - b -a 3.记忆化（memoization）定义 在使用递归时，可能存在，本次递归中已经计算了参数为n的值，下次递归中又计算了参数为n的值即消除重复计算值 解决方法 用散列表（哈希表）存储键值（即 key为 n，value为递归计算的结果） 实施方法① 实例化哈希表 ② 在递归开始时，寻找key为n的键是否存在，存在就直接返回对应的值 ③ 不存在就往下计算，将最后结束时，将n语计算的结果存入哈希表中，以方便下次递归获取数据 4.时间复杂度基本公式 O(T)=R∗O(s),R为递归调用的数量、O(s)为一次调用花费的时间复杂度记忆化可大幅度降低R的值 4.空间复杂度复杂度递归相关空间（1）定义： 由递归直接引起的内存开销，即用于跟踪递归函数调用的堆栈 （2）消耗空间的内容： 函数调用的返回地址传递给函数调用的参数函数调用中的局部变量 注意： 由于栈函数调用结束会释放，故调用时空间成本低但如果递归过多，超过了堆栈大小，会造成溢出 非递归相关空间定义： 与递归过程没有直接关系的内存空间通常包括为全局变量分配的空间（通常在堆中） 尾递归定义 递归调用是递归函数中的最后一条指令在函数中应该只有一次递归调用","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/categories/数据结构/"},{"name":"算法","slug":"数据结构/算法","permalink":"http://www.yiyuclub.club/categories/数据结构/算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"http://www.yiyuclub.club/tags/算法/"},{"name":"递归","slug":"递归","permalink":"http://www.yiyuclub.club/tags/递归/"}]},{"title":"数据结构（算法---递推）","slug":"数据结构（算法-递推）","date":"2019-07-18T00:55:15.000Z","updated":"2019-07-18T00:55:59.849Z","comments":true,"path":"2019/07/18/数据结构（算法-递推）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/18/数据结构（算法-递推）/","excerpt":"数据结构（哈希表）","text":"数据结构（哈希表） 1.概念 根据已知的条件，按照某种规律推导出新的数据 2.类别顺推法 从前往后推导，得到下标为0，1，2……i-1的解 逆推法 从后往前推导，得到下标为i-1，i-2，i-3……0的解 3.实施步骤确定递推变量 其为变量或数组等，如上面的i 建立递推关系 确定递推关系的依据，如上面逐渐+1（-1） 初始化边界条件 根据场景的条件确定递推变量的初始值，如上面的0（i-1） 对递推进行控制 满足什么条件结束，如上面的当i满足某种条件时结束 4.应用分析斐波纳契数列（兔子数）（1）题目 如果一对两个月大的兔子以后每一个月都可以生一对小兔子，而一对新生的兔子出生两个月后才可以生小兔子。也就是说，1月份出生，3月份才可产仔。那么假定一年内没有发生兔子死亡事件，那么1年后共有多少对兔子呢？ （2）规律(对数)： 1 1 2 3 5 8 13 21 … （3）推导公式 a[i] = a[i-1] + a[i-2],i &gt;= 3(整数) （4）java代码实现 //递推兔子数 public int getRubCount(int n){ //n为月数 int[] a = new int[n]; int count = 0; //初始化1、2月为1对 a[0] = a[1] = 1; // if(n&lt;=2){ System.out.println(&quot;1&quot;); return 1; }else{ for (int i = 3 ; i &lt; n ;i++ ){ a[i] = a[i-1] + a[i-2]; System.out.println(a[i]); count = a[i]; } return count; } }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/categories/数据结构/"},{"name":"算法","slug":"数据结构/算法","permalink":"http://www.yiyuclub.club/categories/数据结构/算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"http://www.yiyuclub.club/tags/算法/"},{"name":"递推","slug":"递推","permalink":"http://www.yiyuclub.club/tags/递推/"}]},{"title":"数据结构（哈希表）","slug":"数据结构（哈希表）","date":"2019-07-17T09:03:41.000Z","updated":"2019-07-17T09:09:51.343Z","comments":true,"path":"2019/07/17/数据结构（哈希表）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/17/数据结构（哈希表）/","excerpt":"数据结构（哈希表）","text":"数据结构（哈希表） 1.概念名称 hash table、哈希表、散列表。 定义 给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址,称为哈希(Hash）表，f(key)为哈希函数（散列函数）。 步骤 得到一个 key计算 key 的 hashValue根据 hashValue 值定位到 data[hashValue] 2.函数构造方法定义 即f(key)函数方法，得到计算后的地址,即 key-value的value但计算中会出现地址重复，即哈希冲突 直接定制法（1）公式：H(key) = a*key + b （2）注解：调用公式得到地址，如果该地址已有值，向下一个地址找，直到有空的 数字分析法（1）注解：在一组有规律的的数字中，选取若干个分布均匀的数字作为散列码（可以对这些数字作出同样的加减乘除已减少重复率）—–（即选取r进制数数码分布较为均匀的若干位作为散列地址） 平方取中法（1）注解：取关键字的平方值的中间几位作为散列地址 除留余数法（1）公式：H(key) = key % p，p小于表长（但最接近或等于表长的质数p） （2）注解：调用公式得到地址，如果该地址已有值，向下一个地址找，直到有空的 折叠法（1）注解：关键字分割成位数相同的几部分，然后取这几部份的叠加和作为散列地址 随机数法（1）注解：选择一随机函数，取关键字的随机值作为散列地址 3.哈希冲突定义 函数构造方法中得到的哈希地址可能重复造成冲突 解决方案（1）开放定址法 公式：Hi = (H(key)+di) % m(m表示散列表表长，di为增量序列)di取法有三种：① 线性探测法：di=1,2,3，…，m-1② 平方探测法：di=1^2,-1^2,2^2,-2^2，⑶^2，…，±（k)^2,(k&lt;=m/2）③ 伪随机数法: di=伪随机数列中的值 （2）链地址法（哈希桶） 将冲突的值，添加到其后一位新的链表中，如链表中还冲突，再往后一位新的链表中添加，直至不冲突 （3）公共溢出区法 建立一个公共溢出区,存放冲突的数据适用于数据量少的情况 （4）再散列法 多次散列得到的地址。直至不冲突为止花费大量时间","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/categories/数据结构/"},{"name":"哈希表","slug":"数据结构/哈希表","permalink":"http://www.yiyuclub.club/categories/数据结构/哈希表/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/tags/数据结构/"},{"name":"哈希表","slug":"哈希表","permalink":"http://www.yiyuclub.club/tags/哈希表/"}]},{"title":"数据结构（java队列-链队列）","slug":"数据结构（java队列-链队列）","date":"2019-07-17T01:44:56.000Z","updated":"2019-07-17T01:45:23.555Z","comments":true,"path":"2019/07/17/数据结构（java队列-链队列）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/17/数据结构（java队列-链队列）/","excerpt":"数据结构（java队列-链队列）","text":"数据结构（java队列-链队列） 1.说明 一般使用单链表操作 2.链队列实体类 节点类（QueueNode）和队列类（LinkQueue） 节点属性//数据和下节点坐标 public Object data; public QueueNode next; 节点构造函数//初始化 public QueueNode(Object data) { this.data = data; this.next = null; } 队列属性//头结点和尾节点、大小 private QueueNode front; private QueueNode rear; private int maxSize; 队列构造函数//初始化 public LinkQueue() { this.front = this.rear = null; this.maxSize = 0; } 3.方法判空//判断是否为空 public boolean isEmpty() { return front==null?true:false; } 判断溢出 队列理论上不会溢出 获取队列头public QueueNode getFront() { if(!isEmpty()){ return front; } return null; } 获取队列长度//获取队列长度 public int getSize() { if(!isEmpty()){ return maxSize; } return 0; } 清空//清空 public void clear() { front=rear=null; maxSize = 0; } 入队public boolean push(String data) { QueueNode queueNode = new QueueNode(data); try { if(isEmpty()){ front = rear = queueNode; }else{ rear.next = queueNode; rear = queueNode; } maxSize++; return true; } catch (Exception e) { return false; } } 出队public boolean pop() { if(!isEmpty()){ QueueNode qn = front; front = front.next; if(qn == rear){ rear = null; } maxSize--; return true; } return false; } 4.测试测试public class TestQueue { public static void main(String[] args){ LinkQueue lq = new LinkQueue(); System.out.println(&quot;-----------&quot;); System.out.println(&quot;是否为空：&quot;+lq.isEmpty()); System.out.println(&quot;队列大小：&quot;+lq.getSize()); System.out.println(&quot;-----------&quot;); lq.push(&quot;yiyu1&quot;); lq.push(&quot;yiyu2&quot;); lq.push(&quot;yiyu3&quot;); lq.push(&quot;yiyu4&quot;); System.out.println(&quot;是否为空：&quot;+lq.isEmpty()); System.out.println(&quot;队列大小：&quot;+lq.getSize()); System.out.println(&quot;头数据：&quot;+lq.getFront().data); System.out.println(&quot;-----------&quot;); lq.pop(); System.out.println(&quot;是否为空：&quot;+lq.isEmpty()); System.out.println(&quot;队列大小：&quot;+lq.getSize()); System.out.println(&quot;头数据：&quot;+lq.getFront().data); System.out.println(&quot;-----------&quot;); lq.clear(); System.out.println(&quot;是否为空：&quot;+lq.isEmpty()); System.out.println(&quot;队列大小：&quot;+lq.getSize()); } } 输出结果----------- 是否为空：true 队列大小：0 ----------- 是否为空：false 队列大小：4 头数据：yiyu1 ----------- 是否为空：false 队列大小：3 头数据：yiyu2 ----------- 是否为空：true 队列大小：0","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/categories/数据结构/"},{"name":"队列","slug":"数据结构/队列","permalink":"http://www.yiyuclub.club/categories/数据结构/队列/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.yiyuclub.club/tags/java/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/tags/数据结构/"},{"name":"队列","slug":"队列","permalink":"http://www.yiyuclub.club/tags/队列/"}]},{"title":"数据结构（java队列-循环队列）","slug":"数据结构（java队列-循环队列）","date":"2019-07-16T08:16:14.000Z","updated":"2019-07-16T08:17:38.779Z","comments":true,"path":"2019/07/16/数据结构（java队列-循环队列）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/16/数据结构（java队列-循环队列）/","excerpt":"数据结构（java队列-循环队列）","text":"数据结构（java队列-循环队列） 1.说明 循环队列中，由于需要认为空出一块区域，故数组的front和rear之间的空间为null 2.循环队列实体类属性private int front; private int rear; private int maxsize; private Object data[]; 构造函数//设置自定义大小的队列 public CirculateQueue(int maxSize) { this.front = 0; this.rear = 0; this.maxsize = maxSize; this.data = new Object[maxSize]; } 3.方法判空//判断是否为空 public boolean isEmpty(){ if(this.rear==this.front){ return true; } return false; } 判断溢出//判断是否满 public boolean isFull(){ if(this.front ==((this.rear+1) % maxsize)){ System.out.println(&quot;front&quot;+front+&quot;,rear:&quot;+rear); return true; } return false; } 获取队列头//获取队列头 public Object getQueueHead(){ if(this.rear != 0){ //数组的front位置即位头 return this.data[this.front]; } return null; } 获取队列长度//获取队列长度 public Object getQueueLength(){ if(front &lt; rear){ return this.rear-this.front; }else{ return maxsize - front + rear; } } 清空//清空 public boolean clearQueue(){ if(maxsize&gt;0){ this.front = 0; this.rear = 0; return true; } return false; } 入队public boolean push(Object ob){ if(isFull()){ return false; }else{ this.data[this.rear] = ob; this.rear = (this.rear + 1) % this.maxsize; return true; } } 出队//出队 public boolean pop(){ if(isEmpty()){ return false; }else{ data[this.front]=null; this.front = (this.front + 1) % maxsize; return true; } } 打印//打印 public void printStack() { ; if (front &lt; rear) { for (int i = this.front; i &lt; maxsize; i++) { System.out.println(this.data[i]); } } else { for (int i = this.front; i &lt; maxsize; i++) { System.out.println(this.data[i]); if (i == maxsize - 1) { i = 0; for (int j = i; j &lt; rear + 1; j++) { System.out.println(this.data[j]); } break; } } } } 4.测试测试public class TestQueue { public static void main(String[] args){ CirculateQueue sq = new CirculateQueue(4); System.out.println(&quot;空栈：&quot;+sq.isEmpty()+&quot;---满栈&quot;+ sq.isFull()); System.out.println(&quot;------------------&quot;); System.out.println(&quot;入队&quot;); sq.push(&quot;yiyu1&quot;); sq.push(&quot;yiyu2&quot;); sq.push(&quot;yiyu3&quot;); System.out.println(&quot;队头：&quot;+sq.getQueueHead()); System.out.println(&quot;长度：&quot;+sq.getQueueLength()); System.out.println(&quot;空栈：&quot;+sq.isEmpty()+&quot;---满栈&quot;+ sq.isFull()); sq.printStack(); System.out.println(&quot;------------------&quot;); System.out.println(&quot;出队&quot;); sq.pop(); System.out.println(&quot;队头：&quot;+sq.getQueueHead()); System.out.println(&quot;长度：&quot;+sq.getQueueLength()); System.out.println(&quot;空栈：&quot;+sq.isEmpty()+&quot;---满栈&quot;+ sq.isFull()); sq.printStack(); System.out.println(&quot;------------------&quot;); System.out.println(&quot;入队&quot;); sq.push(&quot;yiyu4&quot;); System.out.println(&quot;队头：&quot;+sq.getQueueHead()); System.out.println(&quot;长度：&quot;+sq.getQueueLength()); System.out.println(&quot;空栈：&quot;+sq.isEmpty()+&quot;---满栈&quot;+ sq.isFull()); sq.printStack(); System.out.println(&quot;------------------&quot;); System.out.println(&quot;清空&quot;); sq.clearQueue(); System.out.println(&quot;队头：&quot;+sq.getQueueHead()); System.out.println(&quot;长度：&quot;+sq.getQueueLength()); System.out.println(&quot;空栈：&quot;+sq.isEmpty()+&quot;---满栈&quot;+ sq.isFull()); } } 输出结果空栈：true---满栈false ------------------ 入队 队头：yiyu1 长度：3 front0,rear:3 空栈：false---满栈true yiyu1 yiyu2 yiyu3 null ------------------ 出队 队头：yiyu2 长度：2 空栈：false---满栈false yiyu2 yiyu3 null ------------------ 入队 队头：yiyu2 长度：3 front1,rear:0 空栈：false---满栈true yiyu2 yiyu3 yiyu4 null ------------------ 清空 队头：null 长度：4 空栈：true---满栈false","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/categories/数据结构/"},{"name":"队列","slug":"数据结构/队列","permalink":"http://www.yiyuclub.club/categories/数据结构/队列/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.yiyuclub.club/tags/java/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/tags/数据结构/"},{"name":"队列","slug":"队列","permalink":"http://www.yiyuclub.club/tags/队列/"}]},{"title":"数据结构（java队列-顺序队列）","slug":"数据结构（java队列-顺序队列）","date":"2019-07-15T08:20:49.000Z","updated":"2019-07-16T01:41:32.643Z","comments":true,"path":"2019/07/15/数据结构（java队列-顺序队列）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/15/数据结构（java队列-顺序队列）/","excerpt":"数据结构（java队列-顺序队列）","text":"数据结构（java队列-顺序队列） 1.说明 顺序队列由于rear和front都会往后移动，会造成队列显示已满而数组为空的现象 2.顺序队列实体类属性private int front; private int rear; private int maxsize; private Object data[]; 构造函数//设置自定义大小的队列 public SequenceQueue(int maxSize) { this.front = 0; this.rear = 0; this.maxsize = maxSize; this.data = new Object[maxSize]; } 3.方法判空//判断是否为空 public boolean isEmpty(){ //rear == front if(this.rear==this.front){ return true; } return false; } 判断溢出//判断是否满 public boolean isFull(){ //rear达到数组最大 if(this.rear==maxsize){ return true; } return false; } 获取队列头//获取队列头 public Object getQueueHead(){ if(this.rear != 0){ //数组的front位置即位头 return this.data[this.front]; } return null; } 获取队列长度//获取队列长度 public Object getQueueLength(){ if(this.rear != 0){ return this.rear-this.front; } return false; } 清空//清空 public boolean clearQueue(){ if(maxsize&gt;0){ this.front = 0; this.rear = 0; return true; } return false; } 入队//入队 public boolean push(Object ob){ if(isFull()){ return false; }else{ //尾部赋值 this.data[this.rear] = ob; //未达到数组上限，rear后移 if(this.rear&lt;maxsize){ this.rear++; } return true; } } 出队//出队 public boolean pop(){ if(isEmpty()){ return false; }else{ //未达到尾部，rear后移 if(this.front&lt;this.rear){ this.front++; } return true; } } 打印//打印front和rear之间的数据 public void printStack(){ for (int i = this.front;i&lt;this.rear ; i++){ System.out.println(this.data[i]); } } 4.测试测试public class TestQueue { public static void main(String[] args){ SequenceQueue sq = new SequenceQueue(4); System.out.println(&quot;空栈：&quot;+sq.isEmpty()+&quot;---满栈&quot;+ sq.isFull()); System.out.println(&quot;------------------&quot;); System.out.println(&quot;入队&quot;); sq.push(&quot;yiyu1&quot;); sq.push(&quot;yiyu2&quot;); sq.push(&quot;yiyu3&quot;); System.out.println(&quot;队头：&quot;+sq.getQueueHead()); System.out.println(&quot;长度：&quot;+sq.getQueueLength()); System.out.println(&quot;空栈：&quot;+sq.isEmpty()+&quot;---满栈&quot;+ sq.isFull()); sq.printStack(); System.out.println(&quot;------------------&quot;); System.out.println(&quot;出队&quot;); sq.pop(); System.out.println(&quot;队头：&quot;+sq.getQueueHead()); System.out.println(&quot;长度：&quot;+sq.getQueueLength()); System.out.println(&quot;空栈：&quot;+sq.isEmpty()+&quot;---满栈&quot;+ sq.isFull()); sq.printStack(); System.out.println(&quot;------------------&quot;); System.out.println(&quot;入队&quot;); sq.push(&quot;yiyu4&quot;); System.out.println(&quot;队头：&quot;+sq.getQueueHead()); System.out.println(&quot;长度：&quot;+sq.getQueueLength()); System.out.println(&quot;空栈：&quot;+sq.isEmpty()+&quot;---满栈&quot;+ sq.isFull()); sq.printStack(); System.out.println(&quot;------------------&quot;); System.out.println(&quot;清空&quot;); sq.clearQueue(); System.out.println(&quot;队头：&quot;+sq.getQueueHead()); System.out.println(&quot;长度：&quot;+sq.getQueueLength()); System.out.println(&quot;空栈：&quot;+sq.isEmpty()+&quot;---满栈&quot;+ sq.isFull()); } } 输出结果空栈：true---满栈false ------------------ 入队 队头：yiyu1 长度：3 空栈：false---满栈false yiyu1 yiyu2 yiyu3 ------------------ 出队 队头：yiyu2 长度：2 空栈：false---满栈false yiyu2 yiyu3 ------------------ 入队 队头：yiyu2 长度：3 空栈：false---满栈true yiyu2 yiyu3 yiyu4 ------------------ 清空 队头：null 长度：false 空栈：true---满栈false","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/categories/数据结构/"},{"name":"队列","slug":"数据结构/队列","permalink":"http://www.yiyuclub.club/categories/数据结构/队列/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.yiyuclub.club/tags/java/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/tags/数据结构/"},{"name":"队列","slug":"队列","permalink":"http://www.yiyuclub.club/tags/队列/"}]},{"title":"数据结构（队列结构）","slug":"数据结构（队列结构）","date":"2019-07-15T07:52:25.000Z","updated":"2019-07-17T00:51:36.652Z","comments":true,"path":"2019/07/15/数据结构（队列结构）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/15/数据结构（队列结构）/","excerpt":"数据结构（队列结构）","text":"数据结构（队列结构） 1.概念 元素从尾部进入，从头部出来对队列的操作，只能在队头和队尾先进先出，后进后出 假溢出 队尾已达到上限不可再入队单队列中还有空位置 注：解决方案：采用循环队列 基础设置 添加头结点和尾节点头结点和尾节点相等即为空队列 图解 2.存储方式顺序队列 即顺序存储结构在内存中开辟一个连续的空间用来存储数据 链队列 即链式存储结构用链表指针来指示数据的存储位置 顺序与链的对比 顺序队列建立时指定（有长度限制，前端数据无法释放，假溢出）链队无长度限制，不会满，但是消耗更多的内存空间存储指针 3.常见操作 创建队列判空判满入队出队清空队列获取队头元素获取队列的长度 4.循环队列 将存储队列元素的数组首位相连，形成闭环 新问题 无论是队列空还是满，都会造成 front=rear解决方案①：使用计数器记录队列个数解决方案②：浪费一个单元（队列头指针上一个和队列尾指针的下个位置上呈现“满”的标志）—常用 特征 队列空条件：front = rear 队列满条件：front = （rear+1）% n, n为数组大小，队列大小为n-1 队列长度：（n + rear - front）% n","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/categories/数据结构/"},{"name":"队列","slug":"数据结构/队列","permalink":"http://www.yiyuclub.club/categories/数据结构/队列/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/tags/数据结构/"},{"name":"队列","slug":"队列","permalink":"http://www.yiyuclub.club/tags/队列/"}]},{"title":"数据结构（java栈操作--顺序）","slug":"数据结构（java栈操作-顺序）","date":"2019-07-15T02:26:13.000Z","updated":"2019-07-15T03:15:53.838Z","comments":true,"path":"2019/07/15/数据结构（java栈操作-顺序）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/15/数据结构（java栈操作-顺序）/","excerpt":"数据结构（java栈操作–顺序）","text":"数据结构（java栈操作–顺序） 1.栈类的定义属性private Object data[];//栈内元素 private int top;//栈顶指针 private int size;//栈大小 构造函数public SequenceStack(int stackSize) { this.data = new Object[stackSize];//初始化栈大小 this.top = -1;//top指针为-1 this.size = stackSize;//初始化栈大小 } 2.判断是否空栈//栈是否为空 public boolean isEmpty(){ //top=-1表明没有新元素入栈 return this.top &lt;= -1?true:false; } 3.判断是否满栈//是否满栈 public boolean isFull(){ //如果栈顶指针下标和栈大小一样，满栈 return this.size-1 == this.top?true:false; } 4.进栈//进栈 public boolean push(Object ob){ if(isFull()){ //满栈 return false; }else{ //数组最后一位放置新元素（即插入栈顶元素） this.data[++top] = ob; return true; } } 5.出栈//进栈 public boolean pop(){ if(isEmpty()){ //空栈 return false; }else{ //数组最后一个下标删除（即删除栈顶元素） --top; return true; } } 6.打印//打印栈元素 public void printStack(){ for (Object ob:this.data){ System.out.println(ob); } } 7.测试public class TestStack { public static void main(String[] args){ SequenceStack stack = new SequenceStack(2); stack.push(&quot;yiyu1&quot;); stack.push(&quot;yiyu2&quot;); stack.push(&quot;yiyu3&quot;); System.out.println(&quot;空栈：&quot;+stack.isEmpty()+&quot;---满栈&quot;+ stack.isFull()); stack.printStack(); } }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/categories/数据结构/"},{"name":"栈","slug":"数据结构/栈","permalink":"http://www.yiyuclub.club/categories/数据结构/栈/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.yiyuclub.club/tags/java/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/tags/数据结构/"},{"name":"栈","slug":"栈","permalink":"http://www.yiyuclub.club/tags/栈/"}]},{"title":"数据结构（栈结构）","slug":"数据结构（栈结构）","date":"2019-07-15T01:15:37.000Z","updated":"2019-07-15T03:09:22.703Z","comments":true,"path":"2019/07/15/数据结构（栈结构）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/15/数据结构（栈结构）/","excerpt":"数据结构（栈结构）","text":"数据结构（栈结构） 1.概念 只能从一端入一端出的线性结构表（出入都是同一个出口）对栈的操作（添加、删除）只能在栈顶先进后出，后进先出 空栈 栈中不含有任何元素 图解 2.存储方式 每个栈都有个栈顶指针，其值为 -1（随着第一个入栈元素移动，后续的指针加1） 顺序存储（顺序栈） 利用一组连续的内存单元依次存放栈底到栈顶的元素将若干个链节点串联 链接存储（链栈） 用链表左为栈的存储结构 顺序与链的对比 顺序栈定长（连续空间，需指定大小），链栈变长（不连续空间，增加指针域，更耗空间）顺序栈需实现堆栈共享（可能造成溢出），链栈不需堆栈共享（不溢出，但结构不连续，会更耗空间） 3.常见定义退栈 删除栈顶元素 进栈 添加新的元素 上溢 栈满时，进行进栈操作 进栈 空栈时，进行退栈操作 4.基本操作方式 ① 构造栈② 判断栈空③ 判断栈满④ 进栈操作⑤ 出栈操作⑥ 不变指针去栈顶元素（待续）","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/categories/数据结构/"},{"name":"栈","slug":"数据结构/栈","permalink":"http://www.yiyuclub.club/categories/数据结构/栈/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/tags/数据结构/"},{"name":"栈","slug":"栈","permalink":"http://www.yiyuclub.club/tags/栈/"}]},{"title":"数据结构（数据逻辑结构分类）","slug":"数据结构（数据逻辑结构分类）","date":"2019-07-15T01:04:07.000Z","updated":"2019-07-19T07:41:40.647Z","comments":true,"path":"2019/07/15/数据结构（数据逻辑结构分类）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/15/数据结构（数据逻辑结构分类）/","excerpt":"数据结构（数据逻辑结构分类）","text":"数据结构（数据逻辑结构分类） 1.逻辑结构划分图 2.线性结构 线性表 线性表 一般线性表：线性表特殊线性表：栈、队列、串 3.集合结构 null 4.树形结构 树二叉树 5.图形结构 有向图无向图 时间复杂度 在时间上花费的量 空间复杂度 在空间上使用量是否发生变化(Θ(1)表示大小未改变 稳定性 排序前和排序后相等的值顺序不变","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/categories/数据结构/"},{"name":"逻辑结构","slug":"数据结构/逻辑结构","permalink":"http://www.yiyuclub.club/categories/数据结构/逻辑结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/tags/数据结构/"},{"name":"逻辑结构","slug":"逻辑结构","permalink":"http://www.yiyuclub.club/tags/逻辑结构/"}]},{"title":"数据结构（java堆基本操作）","slug":"数据结构（java堆基本操作）","date":"2019-07-11T01:16:59.000Z","updated":"2019-07-15T01:01:15.842Z","comments":true,"path":"2019/07/11/数据结构（java堆基本操作）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/11/数据结构（java堆基本操作）/","excerpt":"数据结构（java堆基本操作）","text":"数据结构（java堆基本操作） 1.前提说明 由于 int类型去余取整，子节点无论左右只要除以2，都可以得到父节点数组的下标数组下标从0开始（第一个元素下标为0）节点下标从1开始（根节点下标为1） 2.类属性 THead 类 属性private Integer[] data; private Integer size; 构造函数 //自动扩展比传入的数组大小大一 THead(Integer[] str) { this.size = str.length + 1; this.data = new Integer[this.size]; for (int i = 0; i &lt; this.size; i++) { try { data[i] = str[i]; } catch (Exception e) { data[i] = null; } } } 3.打印//循环遍历打印数组 public void printHead(Integer[] data) { for (int str : data) { System.out.println(str); } } 4.插入public void insertHeap(int ob) { //n为数组data长度 int n = this.size; //由于数组从0开始，需减1 this.data[n - 1] = ob; //调用最大堆方法 MaxHeap(this.data, n); //打印 printHead(this.data); } 5.最大堆public void MaxHeap(Integer[] ob, int n) { //传入数组不为空 if (ob != null) { //保证n-1&gt;0,和判断最后一位是否大于它的父节点 while (n &gt; 1 &amp;&amp; ob[n - 1] &gt; ob[n / 2 - 1]) { //父节点与传入的值对换 int temp = ob[n - 1]; ob[n - 1] = ob[n / 2 - 1]; ob[n / 2 - 1] = temp; //n变为父节点的下标（n-1） n = n / 2; } } } 6.最小堆 ob[n - 1] &lt; ob[n / 2 - 1] 即可 7.堆化待续","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/categories/数据结构/"},{"name":"堆","slug":"数据结构/堆","permalink":"http://www.yiyuclub.club/categories/数据结构/堆/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.yiyuclub.club/tags/java/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/tags/数据结构/"},{"name":"堆","slug":"堆","permalink":"http://www.yiyuclub.club/tags/堆/"}]},{"title":"数据结构（堆结构）","slug":"数据结构（堆结构）","date":"2019-07-10T09:00:08.000Z","updated":"2019-07-12T06:51:07.131Z","comments":true,"path":"2019/07/10/数据结构（堆结构）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/10/数据结构（堆结构）/","excerpt":"数据结构（堆结构）","text":"数据结构（堆结构） 1.概念定义 堆是一个完全二叉树结构是一个数组按照完全二叉树的方式排序 最大堆 父节点永远比子节点大，即根大于左右两节点 最小堆 父节点永远比子节点小，即根小于左右两节点 图解 注意： 数据结构堆栈结构和内存中的堆栈是不同概念 最大堆中最大元素一定位于第一位，最小元素不一定再最后一位，但一定是个叶子节点 最小堆同理 堆相对二叉树查询较慢，插入删除较快 上浮 shiftUp 最大堆中，如果一个节点比它父节点大，则与父节点置换（子节点是往上的过程）最小堆中，如果一个节点比它父节点小，则与父节点置换（子节点是往上的过程） 下沉 shiftDown 最大堆中，如果一个节点比它子节点小（子节点左右先比较），则与子节点置换（父节点是往下的过程）最小堆中，如果一个节点比它子节点大（子节点左右先比较），则与子节点置换（父节点是往下的过程） 图解 插入 insert 在堆的尾部添加新新节点，然后对其进行 shiftUp 移除 remove 删除堆头部的最大（小）值，把最后一个节点放到根节点，然后对其进行 shiftDown 搜索 search 时间复杂度：O(n)相对二叉树较慢 堆排序 heapSort 待补充 常见实现方式 使用数组存储二叉树 （1）左边：左边节点数组下标为其父节点的2倍( leftNode = Parent * 2 )，故为左节点为偶数 （2）右边：右边节点数组下标为其父节点的2倍+1( leftNode = Parent*2 + 1 )，右节点为奇数 堆化 heapify 算法复杂度：O(n) 数组转最大堆 对数组进行堆化堆化后第一个根元素是最大值","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/categories/数据结构/"},{"name":"堆","slug":"数据结构/堆","permalink":"http://www.yiyuclub.club/categories/数据结构/堆/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/tags/数据结构/"},{"name":"堆","slug":"堆","permalink":"http://www.yiyuclub.club/tags/堆/"}]},{"title":"数据结构（java二叉树---遍历）","slug":"数据结构（java二叉树-遍历）","date":"2019-07-10T07:32:07.000Z","updated":"2019-07-10T08:53:29.817Z","comments":true,"path":"2019/07/10/数据结构（java二叉树-遍历）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/10/数据结构（java二叉树-遍历）/","excerpt":"数据结构（java二叉树—遍历）","text":"数据结构（java二叉树—遍历） 1.基本定义节点类//类名 BinaryTreeNode //属性 public String data; public BinaryTreeNode leftNode; public BinaryTreeNode rightNode; 二叉树类//二叉树类 BinaryTree //属性 private BinaryTreeNode rootNode; //方法 get set省略 2.先序遍历递归方式 //先序遍历 public void showOrderByFirst(BinaryTreeNode node){ if(node == null){ return; }else{ System.out.println(node.data); showOrderByFirst(node.getLeftNode()); showOrderByFirst(node.getRightNode()); } } 3.中序遍历递归方式//中序遍历 public void showOrderByMiddle(BinaryTreeNode node){ if(node == null){ return; }else{ showOrderByMiddle(node.getLeftNode()); System.out.println(node.data); showOrderByMiddle(node.getRightNode()); } } 4.后序遍历递归方式//后序遍历 public void showOrderByLast(BinaryTreeNode node){ if(node == null){ return; }else{ showOrderByLast(node.getLeftNode()); showOrderByLast(node.getRightNode()); System.out.println(node.data); } } 4.层序遍历//层序遍历 public void showOrderByFlood(BinaryTreeNode node) { if (node == null) { return; } Queue&lt;BinaryTreeNode&gt; qe = new LinkedList&lt;BinaryTreeNode&gt;(); qe.add(node); while (!qe.isEmpty()) { BinaryTreeNode binaryTreeNode = qe.poll(); System.out.println(binaryTreeNode.data); if (binaryTreeNode.leftNode != null) { qe.add(binaryTreeNode.leftNode); } if (binaryTreeNode.rightNode != null) { qe.add(binaryTreeNode.rightNode); } } }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/categories/数据结构/"},{"name":"二叉树","slug":"数据结构/二叉树","permalink":"http://www.yiyuclub.club/categories/数据结构/二叉树/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.yiyuclub.club/tags/java/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/tags/数据结构/"},{"name":"二叉树","slug":"二叉树","permalink":"http://www.yiyuclub.club/tags/二叉树/"}]},{"title":"数据结构（java二叉树基本操作）","slug":"数据结构（java二叉树基本操作）","date":"2019-07-09T03:30:44.000Z","updated":"2019-07-10T07:32:22.896Z","comments":true,"path":"2019/07/09/数据结构（java二叉树基本操作）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/09/数据结构（java二叉树基本操作）/","excerpt":"数据结构（树结构）","text":"数据结构（树结构） 1.创建定义节点类public class BinaryTreeNode { public String data; public BinaryTreeNode leftNode; public BinaryTreeNode rightNode; //初始化 public BinaryTreeNode() { this.data = null; this.leftNode = null; this.rightNode = null; } public BinaryTreeNode(String data) { this.data = data; } public BinaryTreeNode(String data, BinaryTreeNode leftNode, BinaryTreeNode rightNode) { this.data = data; this.leftNode = leftNode; this.rightNode = rightNode; } //get set省略 } 定义tree类public class BinaryTree { private BinaryTreeNode rootNode; //初始化二叉树 public BinaryTree(){} public BinaryTree(BinaryTreeNode root){ this.rootNode = root; } public void setRoot(BinaryTreeNode root){ this.rootNode = root; } public BinaryTreeNode getRoot(){ return rootNode; } } 方式 ①: 创建根节点②：初始化空二叉树 public class TestBinaryTree { public static void main(String[] agrs){ //创建根节点 BinaryTreeNode root = new BinaryTreeNode(&quot;yiyu&quot;); //初始化空二叉树 BinaryTree tree = new BinaryTree(root); //测试 输出&quot;hhs&quot; System.out.println(tree.getRoot().data); } } 2.销毁树方式 调用3，传入根节点即可 3.清空某子树方式 使用递归的方式删除节点 //删除节点 public void clearTreeNode(BinaryTreeNode node){ if(node == null){ return; } if(node==rootNode){ rootNode = null; return; } if( node!= null){ clearTreeNode(node.leftNode); clearTreeNode(node.rightNode); node = null; return; } } 4.判断树是否为空 判断根节点是否存在即可 //判断树是否为空 public boolean isEmpty(){ if(rootNode == null){ return true; } return false; } 5.树的高度 传入根节点可查寻树的高度传入某节点可得到：该节点（包括该节点）以下的节点高度 // 二叉树某节点下的高度 public int getBinaryTreeHeight(BinaryTreeNode node){ if(node == null){ return 0; }else{ int left = getBinaryTreeHeight(node.leftNode); int right = getBinaryTreeHeight(node.rightNode); if(left&gt;right){ return left + 1 ; }else { return right + 1 ; } } } 6.获取树根节点private BinaryTreeNode rootNode; public void setRoot(BinaryTreeNode root){ this.rootNode = root; } public BinaryTreeNode getRoot(){ return rootNode; } 7.获取节点总数//求二叉树节点数 public int getBinaryTreeSize(BinaryTreeNode node){ if(node == null){ return 0; } else{ return 1 + getBinaryTreeSize(node.leftNode)+getBinaryTreeSize(node.rightNode); } } 8.赋值 设置左节点设置右节点 public void addLeftNode(BinaryTreeNode parent,BinaryTreeNode leftNode){ parent.setLeftNode(leftNode); } public void addRightNode(BinaryTreeNode parent,BinaryTreeNode rightNode){ parent.setRightNode(rightNode); } 9.得到父节点//求二叉树父节点 public BinaryTreeNode getBinaryTreeParentNode(BinaryTreeNode parentNode, BinaryTreeNode node) { if (parentNode == null) { return null; } if (parentNode.getRightNode() == node || parentNode.getLeftNode() == node) { return parentNode; //如果子树的根节点的左右孩子之一是待查节点，则返回子树的根节点 } BinaryTreeNode parent = null; if (getBinaryTreeParentNode(parentNode.getLeftNode(), node) != null) { parent = getBinaryTreeParentNode(parentNode.getLeftNode(), node); return parent; } else { parent = getBinaryTreeParentNode(parentNode.getRightNode(), node); return parent; } } 10.获取左子节点//获取某个节点的左子树 public BinaryTreeNode getLeftTree(BinaryTreeNode node){ return node.leftNode; } 11.获取右子节点//获取某个节点的右子树 public BinaryTreeNode getRightTree(BinaryTreeNode node){ return node.rightNode; }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/categories/数据结构/"},{"name":"二叉树","slug":"数据结构/二叉树","permalink":"http://www.yiyuclub.club/categories/数据结构/二叉树/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.yiyuclub.club/tags/java/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/tags/数据结构/"},{"name":"二叉树","slug":"二叉树","permalink":"http://www.yiyuclub.club/tags/二叉树/"}]},{"title":"数据结构（树结构）","slug":"数据结构（树结构）","date":"2019-07-09T03:09:38.000Z","updated":"2019-07-09T03:32:49.848Z","comments":true,"path":"2019/07/09/数据结构（树结构）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/09/数据结构（树结构）/","excerpt":"数据结构（树结构）","text":"数据结构（树结构） 1.概念二叉树定义： 一个节点可分为左右两个子节点，子节点又可以继续划分左右两个子节点，如此递归。 节点： 最多只有一个父节点最多只有两个子节点没有子节点的称为叶子除根节点外，左为奇数，右为偶数 度： 每个节点有且只有一个入度每个节点最多只有两个出度 高度： 离根节点最远的叶子节点到根节点的行数（包括叶子节点和根节点两行）每个树节点必然少于：2的h次方（h为高度）每行节点最多只有：2的h-1次方 完全二叉树 ###。定义： 所有父节点下的子节点都是最大值，且集中于左边完全二叉树不一定是满二叉树 满二叉树 树最后一层没有任何子节点，所有的父节点都有两个节点满二叉树是一棵特殊的完全二叉树 注意：下图既不是完全二叉树也不是满二叉树 二叉树的遍历先序遍历定义： 顺序：根-左-右 （所有顺序都按从左到右的顺序）注意：先遍历左边所有节点在遍历右边所有节点 图： 中序遍历定义： 顺序：左-根-右 （所有顺序都按从左到根到右的顺序）注意：先遍历左边节点再往上，然后到根节点，最后遍历右边节点在往上 图： 后序遍历定义： 顺序：从第一层开始从左到右遍历 （所有顺序都按从左到右的顺序）注意：先遍左，再遍历右，往上，如此递归 图： 层序遍历定义： 顺序：从第一层开始从左到右遍历 （所有顺序都按从左到右的顺序）注意：先遍历根节点上，到下一层遍历左边节点，再遍历右边节点，再下一层，如此递归 图： 二叉树的序列化序列化 将二叉树结构化数据转化成可顺序传输的数据流 反序列化 与序列化相反 二叉搜索树(Binary Search Tree)定义 任一节点，其值不小于左子树所有节点的值，不大于右子输所有节点的值该节点是左子树中的最大节点，是右子树中的最小节点又称为二叉排序树","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/categories/数据结构/"},{"name":"二叉树","slug":"数据结构/二叉树","permalink":"http://www.yiyuclub.club/categories/数据结构/二叉树/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/tags/数据结构/"},{"name":"二叉树","slug":"二叉树","permalink":"http://www.yiyuclub.club/tags/二叉树/"}]},{"title":"数据结构（java链表）","slug":"数据结构（java链表）","date":"2019-07-08T01:21:22.000Z","updated":"2019-07-09T01:51:23.124Z","comments":true,"path":"2019/07/08/数据结构（java链表）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/08/数据结构（java链表）/","excerpt":"数据结构（java链表）","text":"数据结构（java链表） 1.单向链表基本实现（新增）（1）实体类Node： public class Node { //测试数据 public Integer data; //节点 public Node next; public Node() { } public Node(int data) { this.data = data; } public Node(int data, Node next) { this.data = data; this.next = next; } } （2）添加代码： //测试类中定义了static 头节点 static Node head; //添加代码 public void addData(int data){ Node newNode = new Node(data); //如果没有头节点则新建 if(head == null){ head = newNode; return; } Node temp = head; //寻找到最后一个尾节点 while(temp.next!= null){ temp = temp.next; } temp.next = newNode; return; } （3）打印： public void printData(){ if(head == null){ System.out.println(head.data); }else{ System.out.println(head.data); Node temp = head.next; while (temp != null){ System.out.println(temp.data); temp=temp.next; } return; } （4）测试： public static void main(String[] args){ //实例化 TestNode test = new TestNode(); //无限输入 while (true){ Scanner scanner = new Scanner(System.in); Integer next = scanner.nextInt(); //添加 test.addData(next); //删除 System.out.println(&quot;是否删除&quot;); Scanner scanner2 = new Scanner(System.in); Integer delete = scanner2.nextInt(); if(delete==1){ System.out.println(&quot;删除索引号&quot;); Scanner scanner3 = new Scanner(System.in); Integer index= scanner3.nextInt(); boolean result = test.deleteNode(index); System.out.println(&quot;删除结束，结果：&quot;+result); } test.printData(); } } 删除操作 public boolean deleteNode(Integer index){ //判断小于1的index if(index&lt;1){ System.out.println(&quot;索引值过小，请从1开始&quot;); return false; } //判断等于1的index if(index == 1){ head = head.next; return true; } Node nowNode= head.next; Node upNode = head; int count = 2; //判断大于1的index，从head的下一位开始遍历，范围2到n-1 while(nowNode.next!=null){ if(count == index){ //让上一位的next地址记录要删除的node下一位的地址 upNode.next = nowNode.next; upNode.next.data = nowNode.next.data; return true; } count++; upNode =upNode.next; nowNode= nowNode.next; } //判断最后一位的node if(nowNode.next == null){ 把最后一位前一位对其的next地址置空 upNode.next=null; return true; } return false; } 注：单项循环链表就是把最后一个节点的next设置为head即可，在增改操作时注意更换最后一个node的next 2.双向链表新增操作（1）实体类Node： public class Node { public Integer data; // 下一个node public Node next; // 上一个node public Node up; public Node() { } public Node(int data) { this.data = data; } public Node(int data, Node next,Node up) { this.data = data; this.next = next; this.up = up; } } (2)添加代码： //双向链表 public void addSideNode(Integer well){ Node newNode = new Node(well); //头节点为空 if(head == null){ head = newNode; head.up = null; return; } Node temp = head; //从head遍历到最后一个节点 while (temp.next != null){ temp = temp.next; System.out.println(&quot;位置:&quot;+temp.data); } //最后一个节点的next和up赋值 temp.next = newNode; temp.next.up=temp; } (3)打印： public void printSideNode(){ //头节点为空 if(head==null){ System.out.println(&quot;链表为空&quot;); return; } //头节点数据 System.out.println(head.data); Node temp = head.next; //头节点后的数据 while (temp!=null){ System.out.println(temp.data); System.out.println(&quot;其上一个node的data为：&quot;+temp.up.data); temp = temp.next; } System.out.println(&quot;遍历结束&quot;); return; } （4）测试： public static void main(String[] args){ TestNode test = new TestNode(); while (true){ Scanner scanner1 = new Scanner(System.in); Integer next = scanner1.nextInt(); test.addSideNode(next); System.out.println(&quot;是否删除&quot;); Scanner scanner2 = new Scanner(System.in); Integer delete = scanner2.nextInt(); if(delete==1){ System.out.println(&quot;删除索引号&quot;); Scanner scanner3 = new Scanner(System.in); Integer index= scanner3.nextInt(); boolean result = test.deleteSideNode(index); System.out.println(&quot;删除结束，结果：&quot;+result); } test.printSideNode(); } } 删除操作public boolean deleteSideNode(Integer index){ //索引小于1处理 if(index&lt;1){ System.out.println(&quot;索引值需大于1&quot;); return false; } //索引==1 删除头节点 if(index==1){ //头节点置换为其的下一位，且下一位的up置null head = head.next; head.next.up = null; return true; } Node temp = head.next; Node upTemp = head; int count = 2; //遍历节点，范围2到n-1 while(temp.next != null){ if(count == index ){ System.out.println(&quot;正在删除：&quot;+temp.data); //该node的下游节点关联到该node的山游节点 temp.next.up = upTemp; //该node的上游节点关联到该node的下游节点 upTemp.next = temp.next; } upTemp = upTemp.next; temp = temp.next; count++; } //删除最后一位节点代码 if(temp.next == null){ upTemp.next=null; return true; } return false; } 注：双向循环链表就是把最后一个节点的next设置为head即可，head的上一个节点up设置为链表最后一个节点即可，在增删增草注意替换即可","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/categories/数据结构/"},{"name":"链表","slug":"数据结构/链表","permalink":"http://www.yiyuclub.club/categories/数据结构/链表/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.yiyuclub.club/tags/java/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/tags/数据结构/"},{"name":"链表","slug":"链表","permalink":"http://www.yiyuclub.club/tags/链表/"}]},{"title":"数据结构（链表）","slug":"数据结构（链表）","date":"2019-07-05T01:57:18.000Z","updated":"2019-07-08T01:21:03.377Z","comments":true,"path":"2019/07/05/数据结构（链表）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/05/数据结构（链表）/","excerpt":"数据结构（链表）","text":"数据结构（链表） 1.概念 非连续的内存空间通过指针连接各个单元（指针域增加了空间开销）不需要提前指定内存大小头节点后的第一个节点为首节点 2.复杂度 查询：没有序号标记，需要遍历数据，故时间复杂度为：O(n)插入：调整指针记录即可，故时间复杂度为：O(1) 2.单向链表节点 节点分为两部分一部分保存节点信息一部分保存下一节点地址最后一个节点的后一部分指向null 新增 更改前后节点指向地址即可 删除 更改前后节点指向地址即可 2.双向链表节点 节点分为三部分一部分保存节点信息一部分保存上一节点地址一部分保存下一节点地址最后一个节点的后一部分指向null 注：新增和删除，更改各节点指向其他节点的位置即可 双向循环链表 头节点和尾节点相连","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/categories/数据结构/"},{"name":"链表","slug":"数据结构/链表","permalink":"http://www.yiyuclub.club/categories/数据结构/链表/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.yiyuclub.club/tags/java/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/tags/数据结构/"},{"name":"链表","slug":"链表","permalink":"http://www.yiyuclub.club/tags/链表/"}]},{"title":"数据结构（java数组）","slug":"数据结构（java数组）","date":"2019-07-05T01:21:31.000Z","updated":"2019-07-08T01:21:14.118Z","comments":true,"path":"2019/07/05/数据结构（java数组）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/05/数据结构（java数组）/","excerpt":"数据结构（java数组）","text":"数据结构（java数组） 1.数组定义语法1元素类型[] 数组名 = new 元素类型[元素个数或数组长度]; 例子 ： //分配 0 1 2三个空间 int[] arr = new int[2]; 语法2元素类型[] 数组名 = new 元素类型[]{元素1，元素1，……}; 例子 ： //分配 0 1 2三个空间对应数据1 2 3 int[] arr = new int[1,2,3]; //可简写 int[] arr = {1,2,3}; 二维数组数组类型[][] 数组名 = new 数组类型[一维数组的个数][每一个一维数组中元素的个数]; 例子： int [][] arr = new int[][]{ {111,12,13,14},{21,22,23,24},{31,32,33,34}}; 2.数组大小 java 中使用 length 属性获取大小（不是length()） 数据超出数组范围会报异常：ArrayIndexOutOfBoundsException 数组长度是固定的 3.数组遍历一般采用for循环遍历 例子： public static void main(String[] args) { int[] arr = { 1, 2, 3, 4 }; for (int i = 0; i &lt; 4; i++) { System.out.println(arr[i]); // 输出1 2 3 4，arr[0] 值为 1 } } 4.数组异常空指针异常 提示：NullPointerException问题原因：数据引用对象指向了空对象（即null），而使用了此对象的属性或方法 数组越界异常 提示：ArrayIndexOutOfBoundsException问题原因：数据超出数组范围会报异常，即索引值不存在 5.数组基本操作排序 使用 sort() 方法此方法会升序排序 toString 将数组内容以字符串形式返回 按值查找 使用 binarySearch() ，有值返回其索引值（0开始的索引值）使用时先将数组排序排序 length 返回数组大小","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/categories/数据结构/"},{"name":"数组","slug":"数据结构/数组","permalink":"http://www.yiyuclub.club/categories/数据结构/数组/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.yiyuclub.club/tags/java/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/tags/数据结构/"},{"name":"数组","slug":"数组","permalink":"http://www.yiyuclub.club/tags/数组/"}]},{"title":"数据结构（数组结构）","slug":"数据结构（数组结构）","date":"2019-07-05T00:47:34.000Z","updated":"2019-07-19T07:40:49.814Z","comments":true,"path":"2019/07/05/数据结构（数组结构）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/05/数据结构（数组结构）/","excerpt":"数据结构（数组结构）","text":"数据结构（数组结构） 1.概念 一块连续的内存空间在分配内存的时候确定个数，定长，无法改变大小从0开始编号 2.图解新增 删除 复杂度时间复杂度 新增: 数据需要移动，故时间复杂度大体与移动个数有关–&gt; O(n) 查询：数据是一组连续空间，为每一个数都排了序，查找时按序号即可找到–&gt; O(1) 总结 查找快新增删除慢","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/categories/数据结构/"},{"name":"数组","slug":"数据结构/数组","permalink":"http://www.yiyuclub.club/categories/数据结构/数组/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.yiyuclub.club/tags/数据结构/"},{"name":"数组","slug":"数组","permalink":"http://www.yiyuclub.club/tags/数组/"}]},{"title":"MYSQL知识整理（MYSQL安装---centos7环境）","slug":"MYSQL知识整理（MYSQL安装-centos7环境）","date":"2019-07-04T01:55:45.000Z","updated":"2019-07-04T07:47:46.106Z","comments":true,"path":"2019/07/04/MYSQL知识整理（MYSQL安装-centos7环境）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/04/MYSQL知识整理（MYSQL安装-centos7环境）/","excerpt":"MYSQL知识整理（MYSQL安装—centos7环境）","text":"MYSQL知识整理（MYSQL安装—centos7环境） 1.安装前的检查注：如果第一次安装mysql，可以跳过,此次版本为8.0.13 ① 输入命令检查mysql是否已存在:rpm -qa | grep mysql ② 1步骤不存在则跳过下面，输入命令删除文件:yum remove mysql-xxx-xxx(其为上图所列的文件名称) ③ 查找mysql配置文件:find / -name mysql ④ 删除mysql配置文件:rm -rf -var/lib/mysql 由于我下centos7的版本有mariadb（mysql的分支），需删除否则可能报错 ① 输入命令检查mariadb 是否已存在:rpm -qa | grep mariadb ② 1步骤不存在则跳过下面，输入命令删除文件:yum remove mariadb文件名(其为上述所列的文件名称) ③ 删除mariadb文件：yum -y remove mariadb文件名 2.安装mysql① 打开centos7并连接，最好登录为root权限的用户 ② 输入地址进入mysql官网相关地址：https://dev.mysql.com/downloads/repo/yum/ ③ 由于使用在线下载，用到yum与wget，点击如图界面获取地址（可按自己方式获取链接） ④ 输入命令下载（链接为上述链接）：wget https://repo.mysql.com//mysql80-community-release-el7-3.noarch.rpm ⑤ 安装rpm包（时间略久）rpm -ivh mysql80-community-release-el7-3.noarch.rpm ⑥ 安装mysql：yum install mysql-community-server 注：此过程会有两部y/n，y即可 3.mysql设置文件介绍 cnf 配置：/etc/my.cnf日志：/var/log/var/log/mysqld.log启动脚本：/usr/lib/systemd/system/mysqld.servicesocket：/var/run/mysqld/mysqld.pid 开机自启 systemctl start mysqld.servicesystemctl enable mysqld.service 密码查看临时密码： mysql安装结束，其会有个临时密码输入命令查看：cat /var/log/mysqld.log | grep password 更改密码：① 进入mysql界面，mysql -uroot -p,输入临时密码 ② 修改密码：ALTER USER ‘root‘@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘root1234’ ③ 如果未更改，初始策略等级较高，会报错： ④ 降低验证等级： set global validate_password.policy=0; (策略等级，如数字密码等)set global validate_password.length=1; （长度） 注：5.*版本修改命令为： set global validate_password_policy=0;set global validate_password_length=1; ⑤ 再次修改密码、成功 4.远程连接win10连接① win10安装好mysql图形操作软件（这里是Navicat） ② 关闭centos7防火墙 systemctl stop firewalld （关闭）systemctl disable firewalld（开机关闭） ③ 由于安装后默认权限只允许localhost,新建一用户，输入： use mysql; update user set host = &quot;%&quot; where user=&apos;root&apos;; create user &apos;hhs&apos;@&apos;%&apos; identified by &apos;root1234&apos;; grant all privileges on *.* to &apos;hhs&apos;@&apos;%&apos; with grant option; ④ Navicat输入ip、用户名、密码连接成功","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/categories/MYSQL/"},{"name":"MYSQL安装","slug":"MYSQL/MYSQL安装","permalink":"http://www.yiyuclub.club/categories/MYSQL/MYSQL安装/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.yiyuclub.club/tags/数据库/"},{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/tags/MYSQL/"},{"name":"centos7","slug":"centos7","permalink":"http://www.yiyuclub.club/tags/centos7/"}]},{"title":"MYSQL知识整理（MYSQL优化---SQL优化）","slug":"MYSQL知识整理（MYSQL优化-SQL优化）","date":"2019-07-04T01:36:09.000Z","updated":"2019-07-04T01:39:08.678Z","comments":true,"path":"2019/07/04/MYSQL知识整理（MYSQL优化-SQL优化）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/04/MYSQL知识整理（MYSQL优化-SQL优化）/","excerpt":"MYSQL知识整理（MYSQL优化—SQL优化）","text":"MYSQL知识整理（MYSQL优化—SQL优化）","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/categories/MYSQL/"},{"name":"MYSQL优化","slug":"MYSQL/MYSQL优化","permalink":"http://www.yiyuclub.club/categories/MYSQL/MYSQL优化/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.yiyuclub.club/tags/数据库/"},{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/tags/MYSQL/"}]},{"title":"MYSQL知识整理（MYSQL优化---优化方案）","slug":"MYSQL知识整理（MYSQL优化-优化方案）","date":"2019-07-04T00:43:50.000Z","updated":"2019-07-04T01:34:33.190Z","comments":true,"path":"2019/07/04/MYSQL知识整理（MYSQL优化-优化方案）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/04/MYSQL知识整理（MYSQL优化-优化方案）/","excerpt":"MYSQL知识整理（MYSQL优化—优化方案）","text":"MYSQL知识整理（MYSQL优化—优化方案） 1.概念mysql查询过程图 优化目的 提高安全性提高性能 注：开发中数据库的稳定性是重中之重 优化参与者 数据库管理员业务部门负责人及相关成员架构师设计参与者开发编程者硬件及系统管理员存储管理员 优化先后分析图 按成本：硬件&gt;系统配置&gt;数据库表结构&gt;SQL及索引按成效：硬件&lt;系统配置&lt;数据库表结构&lt;SQL及索引 优化工具（1）检查工具 mysql客户端：操作数据库 msyqladmin：mysql客户端，可进行管理操作 mysqlshow：功能强大的查看shell命令 show [SESSION | GLOBAL] variables：查看数据库参数信息 SHOW [SESSION | GLOBAL] STATUS：查看数据库的状态信息 information_schema：获取元数据的方法 SHOW ENGINE INNODB STATUS：Innodb引擎的所有状态 SHOW PROCESSLIST： 查看当前所有连接session状态 explain ：获取查询语句的执行计划 show index：查看表的索引信息 slow-log：记录慢查询语句 mysqldumpslow：分析slowlog文件的 2.数据库优化检查卡顿步骤 ① 查看slowlog，分析slowlog，分析出查询慢的语句 ② 按照一定优先级，进行一个一个的排查所有慢语句 ③ 分析top sql，进行explain调试，查看语句执行时间 ④ 调整索引或语句本身。 设计优化 执行计划索引SQL改写 架构优化 高可用架构高性能架构分库分表 数据库参数优化（1）参数调整 thread_concurrency：并发线程数量个数 sort_buffer_size：排序缓存 read_buffer_size： 顺序读取缓存 read_rnd_buffer_size：随机读取缓存 key_buffer_size ：索引缓存 thread_cache_size ： (1G—&gt;8, 2G—&gt;16, 3G—&gt;32, &gt;3G—&gt;64) （2）客户端连接参数 max_connections：最大连接数，看交易笔数设置max_connect_errors：最大错误连接数，能大则大connect_timeout： 连接超时max_user_connections ： 最大用户连接数skip-name-resolve ：跳过域名解析wait_timeout： 等待超时back_log： 可以在堆栈中的连接数量 （3）sql参数 query_cache_size： 查询缓存(不超过GB) 存储引擎 default-storage-engine innodb_buffer_pool_size # 没有固定大小，50%测试值，看看情况再微调。但是尽量设置不要超过物理内存70% innodb_file_per_table=(1,0) innodb_flush_log_at_trx_commit=(0,1,2) # 1是最安全的，0是性能最高，2折中 binlog_sync Innodb_flush_method=(O_DIRECT, fdatasync) innodb_log_buffer_size # 100M以下 innodb_log_file_size # 100M 以下 innodb_log_files_in_group # 5个成员以下,一般2-3个够用（iblogfile0-N) innodb_max_dirty_pages_pct # 达到百分之75的时候刷写 内存脏页到磁盘 log_binmax_binlog_cache_size # 可以不设置 max_binlog_size # 可以不设置 innodb_additional_mem_pool_size #小于2G内存的机器，推荐值是20M。32G内存以上100M 3.系统优化CPU vmstat、sar top、htop、nmon、mpstat查看问题一般为更换硬件 内存 free 、ps -aux查看问题一般为更换硬件 磁盘与网络 iostat、ss、netstat、iptraf、iftop、lsof查看问题避免使用swapaid、no lvm、 ext4或xfs、ssd、IO调度策略 4.应用优化mysql选取 该系统或硬件是否能与mysql很好的结合 防火墙 关闭iptables、selinux等其他无用服务 如： chkconfig –level 23456 acpid off chkconfig –level 23456 anacron off chkconfig –level 23456 autofs off chkconfig –level 23456 avahi-daemon off chkconfig –level 23456 bluetooth off chkconfig –level 23456 cups off chkconfig –level 23456 firstboot off chkconfig –level 23456 haldaemon off chkconfig –level 23456 hplip off chkconfig –level 23456 ip6tables off chkconfig –level 23456 iptables off chkconfig –level 23456 isdn off chkconfig –level 23456 pcscd off chkconfig –level 23456 sendmail off chkconfig –level 23456 yum-updatesd off 图形界面 做为服务器的数据库不要安装或打开图形界面，减小开销 5.硬件优化服务器 数据库类型的选择 CPU的选择 内存容量大小的选择 磁盘类型和大小的选择 cpu cpu核数的选择 cpu主频的选择 内存 内存大小选择 内存速度选择 存储 磁盘大小选择 I/O速度选择 网络 交换机 路由器 网线 网卡 HBA卡 网速 参考资料地址 [1] https://www.cnblogs.com/clsn/p/8214048.html#auto_id_1","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/categories/MYSQL/"},{"name":"MYSQL优化","slug":"MYSQL/MYSQL优化","permalink":"http://www.yiyuclub.club/categories/MYSQL/MYSQL优化/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.yiyuclub.club/tags/数据库/"},{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/tags/MYSQL/"}]},{"title":"MYSQL知识整理（MYSQL主从复制-----基本原理）","slug":"MYSQL知识整理（MYSQL主从复制-基本原理）","date":"2019-07-03T00:48:11.000Z","updated":"2019-07-03T03:02:00.686Z","comments":true,"path":"2019/07/03/MYSQL知识整理（MYSQL主从复制-基本原理）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/03/MYSQL知识整理（MYSQL主从复制-基本原理）/","excerpt":"MYSQL知识整理（MYSQL主从复制—–基本原理）","text":"MYSQL知识整理（MYSQL主从复制—–基本原理） 1.概念主从复制定义 一个MySQL数据库服务器主节点的数据复制到一个或多个从子节点 方式 默认为异步复制模式 用途 读写分离：可以划分读服务器和写服务器 故障分析：节点发生故障可以迅速切换其他服务器 高可用HA：通过尽量缩短因日常维护操作（计划）和突发的系统崩溃（非计划）所导致的停机时间，以提高系统和应用的可用性 易扩展：容易增加子数据库服务器节点，减少大数据下哥服务器压力 主从形式 单主单从 单主多从 多主单从 多主复制 联级复制 2.复制原理涉及线程 主节点线程子节点I/O线程子节点线程 主节点线程 ① 子节点连接主节点② 主节点创建log dump线程(此线程每个子节点创建一个)发送log_bin文件（log_bin发送完成前会上锁） 子节点I/O线程 ① 子节点start slave，I/O线程被创建② 请求主库中更新的bin-log③ I/O线程接收主节点binlog dump④ 请求的信息保存在本地relay-log 子节点线程 读取relay log中的内容 完整过程 ① 的I/O进程连接主节点，请求日志内容 ② 主节点接收从节点的I/O请求，返回指定日志指定位置之后的日志信息，返回给从节点（返回信息中除了日志所包含的信息之外，还包括本次返回的信息的bin-log file 的以及bin-log position） ③ 从节点的I/O进程接收内容，将接收到的日志内容更新到本机relay log，并将读取到的binary log文件名和位置保存到master-info 文件中，以便在下一次读取的时候能够清楚的告诉Master“我需要从某个bin-log的哪个位置开始往后的日志内容，请发给我”； ④ 子节点线程检测到relay-log中新增加了内容后，会将relay-log的内容解析成在祝节点上实际执行过的操作，并在本数据库中执行。 3.模式异步模式 英文名“mysql async-mode” 默认的主从复制模式 主节点不会主动push bin log到子节点（故有可能导致同步不一致） 半同步模式 英文名“mysql semi-sync” 主节点只要接收到其中一台子节点的返回信息，就会commit 或者需要等待直到超时时间然后切换成异步模式再提交 数据延迟减小，事务安全 性能降低、响应变长 全同步模式 主节点和子节点全部执行了commit并确认才会向客户端返回成功 （1）binlog记录格式 基于SQL语句的复制(SBR)：记录sql语句在bin log中 基于行的复制（RBR）：将SQL语句分解为基于Row更改的语句并记录在bin log中（只记录修改的样子） 混合模式复制（MBR）：对于一般的复制使用STATEMENT模式保存到binlog；对于STATEMENT模式无法复制的操作则使用ROW模式来保存 （2）GTID复制模式 无需找到binlog和pos点只需要知道主节点的ip，端口，以及账号密码就行，因为复制是自动的，MySQL会通过内部机制GTID自动找点同步 GIID原理: 主节点更新数据时，会在事务前产生GTID，一起记录到binlog日志中 从节点的I/O线程将变更的bin log，写入到本地的relay log中 SQL线程从relay log中获取GTID，然后对比本地binlog是否有记录（所以MySQL从节点必须要开启binary log） 如果有记录，说明该GTID的事务已经执行，从节点会忽略 如果没有记录，从节点就会从relay log中执行该GTID的事务，并记录到bin log 在解析过程中会判断是否有主键，如果没有就用二级索引，如果有就用全部扫描 主从复制配置① 在主数据库my.cnf添加三行，并重启： //将mysql二进制日志取名为mysql-bin log-bin=mysql-bin //二进制日志的格式，有三种：statement/row/mixed,具体分别不多做解释，这里使用mixed binlog_format=mixed //为服务器设置一个独一无二的id便于区分，这里使用ip地址的最后一位充当server-id server-id=101 ② 子数据库my.cnf也添加这三行（参数的值不同），并重启 ③ 为主数据库分配权限 GRANT replication slave ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;root&apos;; 注： replication slave:复制权限.：可以操作的数据库第一个root：用户名%：所有电脑皆可使用第二个root：密码 ④ 查看参数记录： show master status ⑤ 在子数据库中输入： MASTER_HOST : 设置要连接的主服务器的ip地址 MASTER_USER : 设置要连接的主服务器的用户名 MASTER_PASSWORD : 设置要连接的主服务器的密码 MASTER_LOG_FILE : 设置要连接的主服务器的bin日志的日志名称，即第3步得到的信息 MASTER_LOG_POS : 设置要连接的主服务器的bin日志的记录位置，即第3步得到的信息，（这里注意，最后一项不需要加引号。否则配置失败） ⑥ 开启子数据库：start slave ⑦ 输入：show slave status;（为yes即成功）","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/categories/MYSQL/"},{"name":"MYSQL主从复制","slug":"MYSQL/MYSQL主从复制","permalink":"http://www.yiyuclub.club/categories/MYSQL/MYSQL主从复制/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.yiyuclub.club/tags/数据库/"},{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/tags/MYSQL/"}]},{"title":"MYSQL知识整理（MYSQL锁机制---锁分类）","slug":"MYSQL知识整理（MYSQL锁机制-锁分类）","date":"2019-07-02T01:37:24.000Z","updated":"2019-07-03T00:50:48.264Z","comments":true,"path":"2019/07/02/MYSQL知识整理（MYSQL锁机制-锁分类）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/02/MYSQL知识整理（MYSQL锁机制-锁分类）/","excerpt":"MYSQL知识整理（MYSQL锁机制—锁分类）","text":"MYSQL知识整理（MYSQL锁机制—锁分类） 悲观锁定义 认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作悲观的把每次操作当成危险操作，每次都必须获取锁才能操作英文：Pessimistic Lock 特点 先获取锁，再进行业务操作 使用场景 不适合“读”操作频繁的场合适合“写”操作频繁的场合4 内容 行锁（包括：共享锁，排他锁）表锁（包括：读锁，写锁） 乐观锁定义 乐观的认为数据不会被修改，不进行业务处理不会拿锁数据只有被业务处理操作时才会获得锁英文：Optimistic Lock 特点 先进行业务操作，不到万不得已不去拿锁 使用场景 不适合“写”操作频繁的场合适合“读”操作频繁的场合 表级锁读锁定义： 获得锁的前提时没有其他线程对该数据的写锁与读锁其他和本线程都可以读操作，都不可以写操作获得锁的线程如果对其他行进行读操作，会报 “tablename was not locked with LOCK TABLES” 基本语句（显式）： //上锁 LOCK TABLE table_name [ AS alias_name ] READ //解锁 UNLOCK table_name 写锁定义： 获得锁的前提时没有其他线程对该数据的写锁只能该线程对数据进行写操作，其他线程不可对其做任何操作被增加写锁的表，其他请求无法在对该表增加读锁和写锁可以指定锁的优先级 基本语句（显式）： //上锁 OCK TABLE table_name [AS alias_name] [ LOW_PRIORITY ] WRITE //解锁 UNLOCK table_name 行级锁共享锁(S LOCK)定义： 无x锁才可获得s锁被s锁的数据仍可被其他线程获得锁 基本语句（显式）： SELECT ...LOCK IN SHARE MODE; 排他锁(X LOCK)定义： 无x锁才可获得x锁 基本语句： SELECT ...LOCK FOR UPDATE; 引擎支持 对比名称 MyISAM InnoDB BDB 行锁 否 是 否 ｜ 页锁 否 否 是 ｜ 表锁 是 是 是 ｜ 注： BDB已经被InnoDB所取代InnoDB行锁是通过给索引上的索引项加锁来实现的 不同锁的对比 名称 开销 加锁速度 死锁 粒度 并 发性能 表所 小 快 不会 高 低 行锁 大 慢 会 低 高 页锁 中 中 会 中 一般 注：表锁适合查询和少量更新的操作，行锁适合大量更新的操作","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/categories/MYSQL/"},{"name":"MYSQL锁机制","slug":"MYSQL/MYSQL锁机制","permalink":"http://www.yiyuclub.club/categories/MYSQL/MYSQL锁机制/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.yiyuclub.club/tags/数据库/"},{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/tags/MYSQL/"}]},{"title":"MYSQL知识整理（MYSQL性能优化---查询截取分析）","slug":"MYSQL知识整理（MYSQL性能优化-查询截取分析）","date":"2019-07-02T00:09:27.000Z","updated":"2019-07-02T01:29:49.911Z","comments":true,"path":"2019/07/02/MYSQL知识整理（MYSQL性能优化-查询截取分析）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/02/MYSQL知识整理（MYSQL性能优化-查询截取分析）/","excerpt":"MYSQL知识整理（MYSQL性能优化—查询截取分析）","text":"MYSQL知识整理（MYSQL性能优化—查询截取分析） 1.查询优化永远小表驱动大表select * from tableA where exists ( 子查询语句) 解释： 把主数据放到子数据中做查询条件，根据条件决定主数据是否查询如主数据数据大于子数据，优先用in查询做子查询如主数据数据小于子数据，优先用exists子查询 order by 关键字优化（1）mysql排序： FileSort:效率低Index:MySQL扫描索引本身完成排序(即使用索引定义的排序),效率高 注意：当ORDER BY语句使用索引最左前列，并且Where子句与ORDER BY子句条件列组合满足索引最左前列时，使用index （2）FileSort介绍 尽量在索引时排序，否则会启动filesort（双路排序和单路排序）算法 双路排序：两次扫描磁盘，最终得到数据，读取行指针和orderby列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出。从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段(读两次磁盘，速度较慢) 单路排序：从磁盘读取查询需要的所有列，按照order by列在buffer对他们进行排序，然后扫描排序后的列表进行输出（速率较快，但i/o操作多，占用内存大） （3）优化策略 增大sort_buffer-size参数的设置增大max_length_for_sort_data参数的设置 （4）为排序使用索引 group by 关键字优化 group by实质是先排序后进行分组，遵照索引建的最佳左前缀 当无法使用索引列，增大max_length_for_sort_data参数的设置+增大sort buffer size参数的设置 where高于having，能写在where限定的条件就不要去having限定 2.慢查询日志介绍 其为日志记录，用来记录在MySQL中响应时间超过阀值的语句（具体指运行时间超过long_query_time值的SQL），可以根据long_query_time的值进行分析 使用（1）使用说明 其默认不开启，需手动开启 状态查看：SHOW VARIABLES LIKE ‘%slow_query_log%’; 开启//手动开启，重启数据库会关闭 SET GLOBAL slow_query_log = 1; //修改配置文件my.cnf才能永久开启 slow_query_log=1 slow_query_log_file=/var/lib/mysql/why-solw.log 记录何内容//查询时间，默认10.000000 SHOW VARIABLES LIKE &apos;%long_query_time%&apos;; //更改 SET GLOBAL long_query_time = 3; 注意：其会记录响应时间超过这个参数值的内容（此值可修改） 3.批量数据脚本步骤（1）建表 建立所需要的表 （2）设置参数log_bin_trust_function_creators 不设置，可能报 this fuction is none of ‘deterministric’… （3）创建函数，保证每条数据不同 随机产生各字段所需内容 （4）创建存储过程 （5）调用存储过程 4.Show Profile介绍 mysql提供可以用来分析当前会话中语句执行的资源消耗情况，可以用于SQL的调优的测量，默认情况下，参数处于关闭状态，并保存最近15次的运行结果。 开启状态//默认关闭 SHOW VARIABLES LIKE &apos;profiling&apos; 开启方式SET profiling = ON; 查看show profiles; 问题数据show profile cpu,block,io for query type内容： ALL:所有开销信息BLOCK IO：IO相关信息CPU：cpu开销IPC：发送和接受开销MEMORY：内存开销PAGE FALUTS：页面错误开销SOURCE：source_function,source_file,source_line开销SWAPS：交换次数开销CONTEXT SWITCHES ：上下文切换开销 常见问题 converting HEAP to MyISAM 查询结果太大，内存不足Creating tmp table 创建临时表Copying to tmp table on disk 把内存中临时表复制到磁盘，危险locked 5.全局查询日志介绍 保存mysql所有sql的执行记录 用于测试环境，不建议在生产环境中使用 查看SHOW VARIABLES LIKE &apos;%general%&apos; 开启方式SET global general = １; set global log_output=&apos;table&apos; 或修改配置文件my.cnf，非配置重启后失效","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/categories/MYSQL/"},{"name":"MYSQL性能优化","slug":"MYSQL/MYSQL性能优化","permalink":"http://www.yiyuclub.club/categories/MYSQL/MYSQL性能优化/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.yiyuclub.club/tags/数据库/"},{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/tags/MYSQL/"}]},{"title":"MYSQL知识整理（MYSQL性能优化---索引优化）","slug":"MYSQL知识整理（MYSQL性能优化-索引优化）","date":"2019-07-01T01:44:16.000Z","updated":"2019-07-02T00:08:29.963Z","comments":true,"path":"2019/07/01/MYSQL知识整理（MYSQL性能优化-索引优化）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/01/MYSQL知识整理（MYSQL性能优化-索引优化）/","excerpt":"MYSQL知识整理（MYSQL性能优化—索引优化）","text":"MYSQL知识整理（MYSQL性能优化—索引优化） 1.索引介绍作用 快速定位数据,加快查询速度 缺点 增加磁盘的开销写数据：需要更新索引，对数据库是个很大的开销，降低表更新、添加和删除的速度 使用场景 表记录数据多查询次数多 索引类型（1）普通索引 定义：无任何限制 基本语句 CREATE INDEX indexName ON tablename(column1[,column2,……]) （2）唯一索引 定义：列值唯一可空 基本语句 CREATE TABLE tablename (ID INT NOTNULL, username VARCHAR(16) NOT NULL, PRIMARY KEY(ID) ); （3）组合索引 定义：选择表中某些数据作为索引列 基本语句 CREATE INDEX username_city_age ON mytable(username,city,age); 注：组合索引列id,usename，password相当于建立“id,usename，password”、“id,usename”、“id”,从左边的列开始组合，无单独的password和username，故顺序对于组合所以十分重要 （4）全文索引 定义：只适用MyISAM，对文本域进行索引（char、varchar、text），非常消耗硬盘空间 基本语句 CREATE FULLTEXT INDEX indexname ON tablename(column) 查看索引基本语句 show index from tablename; 或 show keys from tablename 2.性能优化性能瓶颈定位 mpstat, iostat, sar，vmstat使用索引，使用EXPLAIN分析查询以及调整MySQL的内部配置 查询与索引优化分析（1）show 命令; 查看MySQL状态及变量，找到系统的瓶颈show global status、show variables等 （2）慢查询日志 开启方式： ①：在配置文件my.cnf中在[mysqld]一行下面加入3个配置参数，并重启mysql服务 slow_query_log = 1 //0关闭 1开启 slow_query_log_file = /usr/local/mysql/data/slow-query.log //慢查询日志存放地点 long_query_time = 1 //表示查询超过1秒才记录 ②：通过命令行设置变量来即时启动慢日志查询 mysql&gt; set global slow_query_log =on; mysql&gt; set long_query_time = 0.01; mysql&gt; set global slow_query_log_file= &quot;/usr/local/mysql/data/slow-query.log&quot;; （3）explain分析查询 EXPLAIN字段：Table：显示这一行的数据是关于哪张表的type：这是最重要的字段之一，显示查询使用了何种类型。从最好到最差的连接类型为system、const、eq_reg、ref、range、index和ALLpossible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。key：实际使用的索引。如果为NULL，则没有使用索引。key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好ref：显示索引的哪一列被使用了，如果可能的话，是一个常数rows：MySQL认为必须检索的用来返回请求数据的行数Extra：关于MYSQL如何解析查询的额外信息 （4）profiling分析查询 查询状态： show variables like &apos;%profiling%&apos;;//off表示未开启 或 select @@profiling; //0表示未开启 开启与关闭语句： set profiling=1; //开启 set profiling=0; //关闭 查询语句： SHOW PROFILE [type [, type] ... ] [FOR QUERY n] type: ALL:显示所有的开销信息 BLOCK IO:显示块IO相关开销 CPU:显示用户CPU时间、系统CPU时间 IPC:显示发送和接收相关开销信息 PAGE FAULTS:显示页面错误相关开销信息 SWAPS:显示交换次数相关开销的信息 3.索引优化连接请求的变量（1）max_connections—MySQL的最大连接数 查看： mysql&gt;show variables like ‘max_connections’ 最大连接数 mysql&gt;show status like ‘max_used_connections’ 响应的连接数 max_used_connections / max_connections * 100% （理想值≈ 85%） 修改（/etc/my.cnf文件）： max_connections = 1024 数值过小：ERROR 1040: Too many connectionsmax_used_connections跟max_connections相同那么就是max_connections设置过低或者超过服务器负载上限了，低于10%则设置过大 (2)back_log—暂存的连接数量 连接请求的变量连接请求的变量连接请求的变量连接请求的变量连接请求的变量","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/categories/MYSQL/"},{"name":"MYSQL性能优化","slug":"MYSQL/MYSQL性能优化","permalink":"http://www.yiyuclub.club/categories/MYSQL/MYSQL性能优化/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.yiyuclub.club/tags/数据库/"},{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/tags/MYSQL/"}]},{"title":"MYSQL知识整理（MYSQL性能优化---性能因素分析）","slug":"MYSQL知识整理（MYSQL性能优化-性能因素分析）","date":"2019-07-01T01:27:20.000Z","updated":"2019-07-01T01:43:03.086Z","comments":true,"path":"2019/07/01/MYSQL知识整理（MYSQL性能优化-性能因素分析）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/01/MYSQL知识整理（MYSQL性能优化-性能因素分析）/","excerpt":"MYSQL知识整理（MYSQL性能优化—性能因素分析）","text":"MYSQL知识整理（MYSQL性能优化—性能因素分析） 1.商业需求对性能的影响 不合理需求造成资源投入产出比过低 是否创建单独功能表 无需使用实时刷新时使用实时刷新 MyISAM 和Innodb 选取 2.系统架构及实现的影响数据是否存放类型合理 二进制多媒体数据:是否存放图片 、视频等类型文件，其会造成内存资源匮乏 超大文本数据：造成性能低下，空间占用浪费问题 是否使用缓存 Cache机制 ：大量的查询会浪费系统资源消耗，可采用Cache，加快查询速率 3.其他因素查询语句对性能的影响 查询语句的优化 数据库Schema设计对性能的影响 优化表设计 硬件选择对性能的影响 硬件按需选取及性能优化","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/categories/MYSQL/"},{"name":"MYSQL性能优化","slug":"MYSQL/MYSQL性能优化","permalink":"http://www.yiyuclub.club/categories/MYSQL/MYSQL性能优化/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.yiyuclub.club/tags/数据库/"},{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/tags/MYSQL/"}]},{"title":"MYSQL知识整理（MYSQL基础--流程控制结构）","slug":"MYSQL知识整理（MYSQL基础-流程控制结构）","date":"2019-07-01T00:22:19.000Z","updated":"2019-07-01T00:54:56.280Z","comments":true,"path":"2019/07/01/MYSQL知识整理（MYSQL基础-流程控制结构）/","link":"","permalink":"http://www.yiyuclub.club/2019/07/01/MYSQL知识整理（MYSQL基础-流程控制结构）/","excerpt":"MYSQL知识整理（MYSQL基础–流程控制结构）","text":"MYSQL知识整理（MYSQL基础–流程控制结构） 1.结构介绍 结构名称 定义 顺序结构 默认，按顺序执行 分支结构 设置多条执行方向，按条件选择一条执行 循环结构 按条件，重复执行一段代码 2.顺序结构定义：按代码编写顺序自上而下执行，为默认。 3.分支结构IF函数定义：双分支方向选择 基本语句： if(表达式1,表达式2,表达式3) 注：表达式1成立返回表达式2，否则表达式3 CASE结构定义：根据条件判断选择分支方向，类似switch 基本语句： case 变量|表达式|字段 when 要判断的值 then 返回的值1或语句1; when 要判断的值 then 返回的值2或语句2; ... else 要返回的值n或语句n; end case; IF结构定义：根据条件判断选择分支方向，类似IF 基本语句： if 条件1 then 语句1; else if 条件2 then 语句2; ... else 语句n; #可以省略 end if; 3.循环结构while定义：根据条件判断是否执行，类似while，先判断后执行（可能0次执行） 基本语句： while 循环条件 do 循环体; end while ; while定义：无限循环循环体，类似死锁，可使用LEAVE退出 基本语句： loop 循环体; end loop repeat定义：根据条件判断是否执行， 先执行后判断（至少1次执行） 基本语句： repeat 循环体; until 结束循环的条件 end repeat","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/categories/MYSQL/"},{"name":"MYSQL基础","slug":"MYSQL/MYSQL基础","permalink":"http://www.yiyuclub.club/categories/MYSQL/MYSQL基础/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.yiyuclub.club/tags/数据库/"},{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/tags/MYSQL/"}]},{"title":"MYSQL知识整理（MYSQL性能优化---架构介绍）","slug":"MYSQL知识整理（MYSQL性能优化-架构介绍）","date":"2019-06-28T01:05:41.000Z","updated":"2019-07-03T00:50:12.349Z","comments":true,"path":"2019/06/28/MYSQL知识整理（MYSQL性能优化-架构介绍）/","link":"","permalink":"http://www.yiyuclub.club/2019/06/28/MYSQL知识整理（MYSQL性能优化-架构介绍）/","excerpt":"MYSQL知识整理（MYSQL性能优化—架构介绍）","text":"MYSQL知识整理（MYSQL性能优化—架构介绍） 1.基本内容 mysql内核sql优化工程师mysql服务器的优化查询语句优化主重复制软硬件升级容灾备份sql编程 2.逻辑架构介绍（1）连接层 最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似tcp/ip的通信。主要完成一些类似于连接处理、授权认证以及相关的安全方案。在该层上引起了线程池的的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全连接。服务器也会为安全接入的每个客户端验证它锁具有的操作权限 （2）服务层 第二层架构主要完成大多数的核心服务功能。如SQL接口，并完成缓存的查询。SQL的分析和优化以及部分内置函数的执行。所有跨存储引擎的功能也在这层实现。如过程、函数等、在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定查询表的顺序，是否利用索引等。最后生成相应的执行操作。如果是select语句。服务器会查询内部的缓存。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提高系统的性能 （3）引擎层 存储引擎层，存储引擎真正的负责mysq中数据的存储和提取。服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同。这样我们可以根据自己的实际需要进行选取。常用的有Innodb、MyIsam等 （4）存储层 数据存储层，主要将数据存储在运行于裸设备的文件系统上，并完成与存储引擎的交互 （5）细项分析 Connectors ：不同语言中与SQL的交互 Management Serveices &amp; Utilities： 系统管理和控制工具 Connection Pool: 连接池 管理缓冲用户连接，线程处理等需要缓存的需求。 负责监听对 MySQL Server 的各种请求，接收连接请求，转发所有连接请求到线程管理模块。每一个连接上 MySQL Server 的客户端请求都会被分配 （或创建）一个连接线程为其单独服务。而连接线程的主要工作就是负责 MySQL Server 与客户端的通信， 接受客户端的命令请求，传递 Server 端的结果信息等。线程管理模块则负责管理维护这些连接线程。包括线程的创建，线程的 cache 等。 SQL Interface: SQL接口。接受用户的SQL命令，并且返回用户需要查询的结果 Parser: 解析器。SQL命令传递到解析器的时候会被解析器验证和解析。解析器是由Lex和YACC实现的，是一个很长的脚本。 在 MySQL中我们习惯将所有 Client 端发送给Server 端的命令都称为 query ，在 MySQL Server 里面，连接线程接收到客户端的一个 Query 后， 会直接将该 query 传递给专门负责将各种 Query 进行分类然后转发给各个对应的处理模块。主要功能： a . 将SQL语句进行语义和语法的分析，分解成数据结构，然后按照不同的操作类型进行分类，然后做出针对性的转发到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。 b. 如果在分解构成中遇到错误，那么就说明这个sql语句是不合理的 Optimizer: 查询优化器。SQL语句在查询之前会使用查询优化器对查询进行优化。就是优化客户端请求的 query（sql语句） ，根据客户端请求的 query 语句，和数据库中的一些统计信息，在一系列算法的基础上进行分析，得出一个最优的策略，告诉后面的程序如何取得这个 query 语句的结果 他使用的是“选取-投影-联接”策略进行查询。 Cache和Buffer： 查询缓存。他的主要功能是将客户端提交 给MySQL 的 Select 类 query 请求的返回结果集 cache 到内存中，与该 query 的一个 hash 值 做一个对应。该 Query所取数据的基表发生任何数据的变化之后， MySQL 会自动使该 query 的Cache 失效。在读写比例非常高的应用系统中， Query Cache 对性能的提高是非常显著的。当然它对内存 的消耗也是非常大的。 如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 存储引擎接口：存储引擎接口模块可以说是 MySQL 数据库中最有特色的一点了。目前各种数据库产品中，基本上只有 MySQL 可以实现其底层数据存储引擎的插件式管理。这个模块实际上只是 一个抽象类，但正是因为它成功地将各种数据处理高度抽象化，才成就了今天 MySQL 可插拔存储引擎的特色。 3.引擎对比查看引擎show engines; 查看引擎 show variables like &apos;%storage_engine%&apos;;#查看默认与当前的存储引擎 引擎对比细项 对比名称 MyISAM InnoDB 主外键 不支持 支持 事务 不支持 支持 行表锁 表锁，即使操作一条记录也会锁住整个表，不适合高并发的 行锁，操作时候只锁住某一行，不对其他行有影响适合高并发的操作操作 缓存 只缓存索引，不缓存真实数据 不仅缓存索引还要缓存真实数据，对内存要求.比较高，而且内存大小对性能有决定性的影响 空间 小 大 注重点 性能 事务 mysql是否集成 是 是","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/categories/MYSQL/"},{"name":"MYSQL性能优化","slug":"MYSQL/MYSQL性能优化","permalink":"http://www.yiyuclub.club/categories/MYSQL/MYSQL性能优化/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.yiyuclub.club/tags/数据库/"},{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/tags/MYSQL/"}]},{"title":"Hello World","slug":"hexo_test","date":"2019-06-24T09:13:28.050Z","updated":"2019-06-24T09:13:28.050Z","comments":true,"path":"2019/06/24/hexo_test/","link":"","permalink":"http://www.yiyuclub.club/2019/06/24/hexo_test/","excerpt":"hexo简单小命令","text":"hexo简单小命令 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"MYSQL知识整理（MYSQL基础--函数）","slug":"MYSQL知识整理（MYSQL基础-函数）","date":"2019-06-24T02:51:53.000Z","updated":"2019-06-24T09:13:28.050Z","comments":true,"path":"2019/06/24/MYSQL知识整理（MYSQL基础-函数）/","link":"","permalink":"http://www.yiyuclub.club/2019/06/24/MYSQL知识整理（MYSQL基础-函数）/","excerpt":"MYSQL知识整理（MYSQL基础–函数）","text":"MYSQL知识整理（MYSQL基础–函数） 1.概念定义 是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给定参数（如果该存储过程带有参数）来调用执行它 优点 灵活性：可完成复杂运算及使用组件化：存储过程可被多次调用速度较快：预编译网络流量低：各个操作使用调用方式，降低负载安全性较高：能权限操作限制 2.基本操作基本语句CREATE FUNCTION fu_name ([func_parameter[,...]]) RETURNS type [characteristic ...] routine_body 注： fc_name：参数是存储函数的名称 func_parameter：表示存储函数的参数列表 RETURNS type：指定返回值的类型 characteristic：参数指定存储函数的特性 routine_body：SQL代码的内容，用BEGIN…END来标志SQL代码的开始和结束 例子： CREATE FUNCTION name_from_employee (emp_id INT ) RETURNS VARCHAR(20) BEGIN RETURN (SELECT name FROM employee WHERE num=emp_id ); END 变量的声明及赋值声明： DECLARE var_name[,...] type [DEFAULT value] //例子 DECLARE my_sql INT DEFAULT 10 ; 赋值： SET var_name = expr [, var_name = expr] ... //例子 SET my_sql = 30 ; select into赋值 SELECT col_name[,…] INTO var_name[,…] FROM table_name WEHRE condition 调用语句函数名即可，如getYear(); 删除语句DROP FUNCTION 函数名 查看语句SHOW CREATE FUNCTION 方法名 3.定义条件和处理程序定义条件基本语句： DECLARE condition_name CONDITION FOR condition_value condition_value: SQLSTATE [VALUE] sqlstate_value | mysql_error_code 注： condition_name：参数表示条件的名称 condition_value：参数表示条件的类型 sqlstate_value：参数和mysql_error_code参数都可以表示MySQL的错误。例如ERROR 1146(42S02)中，sqlstate_value值是42S02，mysql_error_code值是1146 处理程序基本语句 DECLARE handler_type HANDLER FOR condition_value[,...] sp_statement handler_type: CONTINUE | EXIT | UNDO condition_value: SQLSTATE [VALUE] sqlstate_value | condition_name | SQLWARNING | NOT FOUND | SQLEXCEPTION | mysql_error_code 注： handler_type：参数指明错误的处理方式，分别是CONTINUE、EXIT和UNDO CONTINUE：表示遇到错误不进行处理，继续向下执行 EXIT表示遇到错误后马上退出 UNDO表示遇到错误后撤回之前的操作，MySQL中暂时还不支持这种处理方式 condition_value：参数指明错误类型，该参数有6个取值 sqlstate_value和mysql_error_code与条件定义中的是同一个意思condition_name：DECLARE定义的条件名称 SQLWARNING：表示所有以01开头的sqlstate_value值 NOT FOUND：表示所有以02开头的sqlstate_value值 SQLEXCEPTION表示所有没有被SQLWARNING或NOT FOUND捕获的sqlstate_value值。sp_statemen表示一些存储过程或函数的执行语句 程序捕获方式： //方法一：捕获sqlstate_value DECLARE CONTINUE HANDLER FOR SQLSTATE &apos;42S02&apos; SET @info=&apos;CAN NOT FIND&apos;; //方法二：捕获mysql_error_code DECLARE CONTINUE HANDLER FOR 1146 SET @info=&apos;CAN NOT FIND&apos;; //方法三：先定义条件，然后调用 DECLARE can_not_find CONDITION FOR 1146 ; DECLARE CONTINUE HANDLER FOR can_not_find SET @info=&apos;CAN NOT FIND&apos;; //方法四：使用SQLWARNING DECLARE EXIT HANDLER FOR SQLWARNING SET @info=&apos;ERROR&apos;; //方法五：使用NOT FOUND DECLARE EXIT HANDLER FOR NOT FOUND SET @info=&apos;CAN NOT FIND&apos;; //方法六：使用SQLEXCEPTION DECLARE EXIT HANDLER FOR SQLEXCEPTION SET @info=&apos;ERROR&apos;;","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/categories/MYSQL/"},{"name":"MYSQL基础","slug":"MYSQL/MYSQL基础","permalink":"http://www.yiyuclub.club/categories/MYSQL/MYSQL基础/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.yiyuclub.club/tags/数据库/"},{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/tags/MYSQL/"}]},{"title":"MYSQL知识整理（MYSQL基础--变量）","slug":"MYSQL知识整理（MYSQL基础-变量）","date":"2019-06-24T02:04:41.000Z","updated":"2019-06-24T09:13:28.050Z","comments":true,"path":"2019/06/24/MYSQL知识整理（MYSQL基础-变量）/","link":"","permalink":"http://www.yiyuclub.club/2019/06/24/MYSQL知识整理（MYSQL基础-变量）/","excerpt":"MYSQL知识整理（MYSQL基础–变量）","text":"MYSQL知识整理（MYSQL基础–变量） 变量分类① 用户自定义变量 局部变量会话变量（用户变量） ② 系统变量 会话变量全局变量 系统变量基本语句： 第一种（default生命默认值）： declare user_name varchar default &apos;yiyu&apos;； 第二种： set user_name=&apos;yiyu&apos;; 第三种： select into 语句 局部变量（用户）定义：作用于sql语块中，作用域仅限于该语句块内 例子(k为局部变量) drop procedure if exists bianliang; create procedure bianliang ( in i int, in j int ) begin declare k int default 0; set k = i * j; select k as k; end; 会话变量（用户）定义：为服务器为每个客户端连接维护的变量，每个客户端只能更改自己的变量 例子： //设值 set session user_name = value; set @@session.user_name = value; set user_name = value; //取值 select @@user_name select @@session.user_name; show session variables like &quot;%user%&quot;;//模糊查询法 全话变量（用户）定义：一般是用于初始化系统参数，生命周期直至重启或关闭，更改时需SUPER权限，并且重启后会被初始化为默认值。 例子： //设值 set global user_name = value; set @@global.user_name = value; //取值 select @@global.user_name; show global variables like &quot;%user%&quot;; 注：如果global写明时，默认为session (其有GLOBAL、SESSION或者LOCAL) 用户自定义变量定义： 由字母、数字、“.”、“_”和“$”组成级别：会话级别（session）作用域：其对应的客户端链接，断开即失效不区分大小写变量类型：整形、浮点型、二进制与非二进制串和NULL 设值语句： SET @user_name = expr[, @var_name = expr] ... 注：为了解决某些冲突问题，赋值有“=”和“:=”两种 例子： SET @user1=1, @user2=2, @user3:=4; SELECT @suer1, @user2, @user3, @user4 := @user1+@user2+@user3; 注： 不要在同一个非SET语句中同时赋值并使用同一个用户自定义变量变量的值是在SQL发送到客户端后才计算的","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/categories/MYSQL/"},{"name":"MYSQL基础","slug":"MYSQL/MYSQL基础","permalink":"http://www.yiyuclub.club/categories/MYSQL/MYSQL基础/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.yiyuclub.club/tags/数据库/"},{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/tags/MYSQL/"}]},{"title":"MYSQL知识整理（MYSQL基础--存储过程）","slug":"MYSQL知识整理（MYSQL基础-存储过程）","date":"2019-06-24T01:32:58.000Z","updated":"2019-06-24T09:13:28.050Z","comments":true,"path":"2019/06/24/MYSQL知识整理（MYSQL基础-存储过程）/","link":"","permalink":"http://www.yiyuclub.club/2019/06/24/MYSQL知识整理（MYSQL基础-存储过程）/","excerpt":"MYSQL知识整理（MYSQL基础–存储过程）","text":"MYSQL知识整理（MYSQL基础–存储过程） 1.概念定义 是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给定参数（如果该存储过程带有参数）来调用执行它 优点 灵活性：可完成复杂运算及使用组件化：存储过程可被多次调用速度较快：预编译网络流量低：各个操作使用调用方式，降低负载安全性较高：能权限操作限制 2.基本操作基本语句//类型一 CREATE PROCEDURE 过程名([[IN|OUT|INOUT] 参数名 数据类型[,[IN|OUT|INOUT] 参数名 数据类型…]]) [特性 ...] 过程体 //类型二 DELIMITER // CREATE PROCEDURE myproc ( OUT s int ) BEGIN SELECT COUNT(*) INTO s FROM students; END // DELIMITER ; 注： “//“：为分隔符，表明其中间的内容为存储过程，否则为sql语句（$） 在mysql中，其语句遇到”;”回车后会执行此句，但有时候不想如此，用DELIMITER，其中间的内容遇到”;”回车后不会立即执行，而是全部加载完成后再执行 多个参数用”,”分隔 参数类型：IN（必须在调用存储过程时指定，该参数的值不能被返回）,OUT（该值可在存储过程内部被改变，并可返回）,INOUT（用时指定，并且可被改变和返回） 过程体：使用BEGIN与END进行标识,如果只有一句话，其可省略 可使用set（赋值）和declare（声明） 更改只能更改名字及定义，内容不可更换 带@的参数为用户变量 调用语句//定义过程 create procedure getcount( in count int, declear sum int, set price = 100 ) begin set sum:=count+price; end //输出1000 call getcount(10) 删除语句DROP PROCEDURE 存储过程名 查看语句SHOW CREATE PROCEDURE 存储过程名","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/categories/MYSQL/"},{"name":"MYSQL基础","slug":"MYSQL/MYSQL基础","permalink":"http://www.yiyuclub.club/categories/MYSQL/MYSQL基础/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.yiyuclub.club/tags/数据库/"},{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/tags/MYSQL/"}]},{"title":"MYSQL知识整理（MYSQL基础--视图）","slug":"MYSQL知识整理（MYSQL基础-视图）","date":"2019-06-21T01:39:41.000Z","updated":"2019-06-24T09:13:28.050Z","comments":true,"path":"2019/06/21/MYSQL知识整理（MYSQL基础-视图）/","link":"","permalink":"http://www.yiyuclub.club/2019/06/21/MYSQL知识整理（MYSQL基础-视图）/","excerpt":"MYSQL知识整理（MYSQL基础–视图）","text":"MYSQL知识整理（MYSQL基础–视图） 1.定义 数据库中的虚拟逻辑表，自定义展现基表（用来创建视图的表） 2.好处 简单：数据为已经过滤好的集合，无需关系复杂的表结构安全：用户只能看到视图规定的数据独立：基表的增加对视图无影响 注：为了保障数据安全性，提高查询效率 3.基本语句CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement [WITH [CASCADED | LOCAL] CHECK OPTION] 简化： create view &lt;视图名称&gt;[(column_list)] as select语句 with check option; 例子： create view userView(编号,名字,性别,密码)asselect userID,username,usersex,password from userInfowhere sex=’男’with check option; 注：多表同理，视图名后面的列的数量必须匹配select子句中的列的数量 4.视图查看查看视图信息： show create view viewname 查看数图数据： select * from viewname; 5.视图更改基本格式： create or replace view view_name as select ALTER格式： ALTER [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] [DEFINER = { user | CURRENT_USER }] [SQL SECURITY { DEFINER | INVOKER }] VIEW view_name [(column_list)] AS select_statement [WITH [CASCADED | LOCAL] CHECK OPTION] 注：修改视图是指修改数据库中已存在的表的定义，当基表的某些字段发生改变时，可以通过修改视图来保持视图和基本表之间一致 6.视图删除基本语句: DROP VIEW [IF EXISTS] view_name [, view_name] ... 注：只能删除视图的定义，不会删除数据 7.视图无法处理 ①select子句中包含distinct ②select子句中包含组函数 ③select语句中包含group by子句 ④select语句中包含order by子句 ⑤select语句中包含union 、union all等集合运算符 ⑥where子句中包含相关子查询 ⑦from子句中包含多个表 ⑧如果视图中有计算列，则不能更新 ⑨如果基表中有某个具有非空约束的列未出现在视图定义中，则不能做insert操作 8.WITH CHECK OPTION作用 对视图所做的DML操作的结果，不能违反视图的WHERE条件的限制.未返回抛出异常 检查程度 ①WITH CASCADED CHECK OPTION：检查所有的视图例如：嵌套视图及其底层的视图 ②WITH LOCAL CHECK OPTION：只检查将要更新的视图本身对嵌套视图不检查其底层的视图 ALGORITHM选项 定义：处理定义视图的select语句中使用的方法 ①UNDEFINED：MySQL将自动选择所要使用的算法（默认） ②MERGE：将视图的语句与视图定义合并起来，使得视图定义的某一部分取代语句的对应部分 ③TEMPTABLE：将视图的结果存入临时表，然后使用临时表执行语句 DEFINER选项 定义:出谁是视图的创建者或定义者 ①definer= ‘用户名‘@’登录主机’ ②如果不指定该选项，则创建视图的用户就是定义者，指定关键字CURRENT_USER(当前用户)和不指定该选项效果相同 SQL SECURITY选项 定义：视图的select权限 ①SQL SECURITY DEFINER：定义(创建)视图的用户必须对视图所访问的表具有select权限，也就是说将来其他用户访问表的时候以定义者的身份，此时其他用户并没有访问权限。（默认） ②SQL SECURITY INVOKER：访问视图的用户必须对视图所访问的表具有select权限。","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/categories/MYSQL/"},{"name":"MYSQL基础","slug":"MYSQL/MYSQL基础","permalink":"http://www.yiyuclub.club/categories/MYSQL/MYSQL基础/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.yiyuclub.club/tags/数据库/"},{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/tags/MYSQL/"}]},{"title":"MYSQL知识整理（MYSQL基础--TCL事务控制语言）","slug":"MYSQL知识整理（MYSQL基础-TCL事务控制语言）","date":"2019-06-21T00:58:31.000Z","updated":"2019-06-24T09:13:28.050Z","comments":true,"path":"2019/06/21/MYSQL知识整理（MYSQL基础-TCL事务控制语言）/","link":"","permalink":"http://www.yiyuclub.club/2019/06/21/MYSQL知识整理（MYSQL基础-TCL事务控制语言）/","excerpt":"MYSQL知识整理（MYSQL基础–TCL事务控制语言）","text":"MYSQL知识整理（MYSQL基础–TCL事务控制语言） 1.概念 一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行 2.特性 原子性：一个事务不可再分割，要么都执行要么都不执行一致性：一个事务执行会使数据从一个一致状态切换到另外一个一致状态隔离性：一个事务的执行不受其他事务的干扰持久性：一个事务一旦提交，则会永久的改变数据库的数据 3.事务的隔离级别 名称 脏读 不可重复度 幻度 read uncommitted 是 是 是 read committed 否 是 是 repeatable read 否 否 是 serializable 否 否 否 读未提交（read uncommited）：即事务对数据库数据所做的修改，在事务未提交之前，可以被其他事务看到。A事务对数据库数据做的修改，在A事务未提交时，事务B可读到A事务对数据所做的修改。容易产生的问题：脏读。由于事务B可读到事务A所做的修改，但是A并没有提交，如果事务A执行过程中发生异常回滚，则会导致事务B读到的是错误数据，即脏数据 读已提交（read commited）：A、B两个数据同时对数据库中同一条数据做修改，A事务开启，读取数据，此时，B事务也开启，读取数据，并对数据做出修改，然后提交，此时事务A继续执行，执行完后，再次读取数据，发现两次读取的结果不一样，由此产生不可重复读的问题。 可重复读（repeatable read）：A事务读取数据库数据，在处理业务的过程中事务B读取数据并修改完成后，事务A再次读取数据时，所得结果和之前读取的数据一致，并且事务A提交后，不会损害数据的一致性。可能产生的问题：幻读。如：事务A开启，读取用户x的age为15，B事务开启age读取用户x的age并加1，此时用户x的age为16，A事务继续执行，将用户x的age加1，提交后，发现x用户的age值为17.从用户的角度来看，数据的一致性并没有被破坏，但A事务可能将读取到的数据15返回给用户，导致幻读。 串行化（serializable）：表上的一个事务开启后，在该事务提交之前，其他事务不能对表中的数据做任何修改。该隔离级别会锁表。 注： mysql中默认 第三个隔离级别 repeatable read 查看隔离级别，select @@tx_isolation; 设置隔离级别，set session|global transaction isolation level 隔离级别 查看事务自动提交是否开启(on表示开启，off表示关闭)，SHOW VARIABLES LIKE ‘autocommit’ 查看数据库支持的存储引擎，SHOW ENGINES innodb支持事务，而myisam、memory等不支持事务 4.事务的创建隐式 定义：没有明显的开启和结束标记，一般insert、update、delete等会自动触发 显式 定义：有明显的开启和结束标记，需先设置自动提交功能为禁用（set autocommit=0;1为开启）START TRANSACTION能强制开启事务 开启步骤： 1：set autocommit=0;2：编写事务中的条件语句，如insert、update、delete等3：commit命令提交事务4：如果想要回滚事务，rollback（savepoint 节点名，为设置保存点） 5.事务机制定义 MyISAM存储引擎采用的是表级锁InnoDB存储引擎采用的是行级锁、也支表级锁 锁 共享读锁/共享锁（lock table 表名 read，S锁）—自己只能读，其他（读-可以，写-堵塞）独占写锁/排它锁（lock table 表名 write，X锁）—自己可读可写，其他（读-堵塞，写-堵塞） 注：释放方式（unlock table） MyISAM表锁定义：MyISAM只支持表锁，锁的是整张表，读取数据的时候会加S锁，增删改的时候会加X锁 InnoDB表锁定义：innoDB既支持表锁也支持行锁，可以锁行级别的数据，增删改的时候会对数据对象（可能是一行或者多行或者一张表）加X锁，读取的时候一般不加锁 行锁定义：行锁就是锁一条数据","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/categories/MYSQL/"},{"name":"MYSQL基础","slug":"MYSQL/MYSQL基础","permalink":"http://www.yiyuclub.club/categories/MYSQL/MYSQL基础/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.yiyuclub.club/tags/数据库/"},{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/tags/MYSQL/"}]},{"title":"MYSQL知识整理（MYSQL基础--DML数据操作语言）","slug":"MYSQL知识整理（MYSQL基础-DML数据操作语言）","date":"2019-06-20T00:54:06.000Z","updated":"2019-06-24T09:13:28.050Z","comments":true,"path":"2019/06/20/MYSQL知识整理（MYSQL基础-DML数据操作语言）/","link":"","permalink":"http://www.yiyuclub.club/2019/06/20/MYSQL知识整理（MYSQL基础-DML数据操作语言）/","excerpt":"MYSQL知识整理（MYSQL基础–DML数据操作语言）","text":"MYSQL知识整理（MYSQL基础–DML数据操作语言） 1.数据库插入基本语句INSERT INTO table_name ( field1, field2,...fieldN ) VALUES( value1, value2,...valueN ) 例子： insert into userInfo (userID,username,password) values(2,&apos;yiyu&apos;,&apos;123456&apos;) 注：如果插入所有列，( field1, field2,…fieldN )可省略 例子： insert into userInfo values(2,’yiyu’,’123456’,’哈哈哈’) 插入多值INSERT INTO table_name (field1, field2,...fieldN) VALUES (value1, value2,...valueN ), (value1, value2,...valueN ),..., (value1, value2,...valueN ); 例子： insert into userInfo (userID,username,password) values(1,’yiyu1’,’123456’)，values(2,’yiyu2’,’789’)，values(3,’yiyu3’,’abc’) 插入查询语句INSERT INTO table_name (column_list) SELECT (column_list) FROM table_name WHERE (condition) 例子： insert into userInfo (userID,username,password) select userID,username,password from userInfo where username =&apos;yiyu&apos; 2.数据库更新 基本语句UPDATE table_name SET field1=value1, field2=value2,... [WHERE condition] 解释： 更新自疑惑多个字段可设置条件更新指定字段value可以使函数，如REPLACE(field1 ‘yiyu’, ‘yiyuhaha’)where 条件语句可以使子查询 例子： UPDATE userInfo SET username=&apos;yiyu&apos;, password=123456 WHERE userID=10 作用在多表的更新UPDATE table_nameA a join table_nameB b on a. column_name1=b. column_name1 SET a.column_name1 = value1, a.column_name2=value2,……, a.column_namen=valuen WHERE b. column_name2&gt;20 注：根据table_nameB的条件更新table_nameA的数据 例子： update userInfo a join personIfo b on a.userID=b.userID set a.username=&apos;yiyu&apos;,a.password=123456 where b.personID =100 数据库删除基本语句DELETE FROM table_name [WHERE condition] 注：where条件可以使子查询 例子： delete drom userInfo where userID = 2 作用在多表的删除 delete from userInfo a join personInfo b on a.userID=b.userIDwhere b.personID = 100 注：根据b条件删除a的数据","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/categories/MYSQL/"},{"name":"MYSQL基础","slug":"MYSQL/MYSQL基础","permalink":"http://www.yiyuclub.club/categories/MYSQL/MYSQL基础/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.yiyuclub.club/tags/数据库/"},{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/tags/MYSQL/"}]},{"title":"MYSQL知识整理（MYSQL基础--DDL数据定义语言）","slug":"MYSQL知识整理（MYSQL基础-DDL数据定义语言）","date":"2019-06-20T00:54:06.000Z","updated":"2019-06-24T09:13:28.050Z","comments":true,"path":"2019/06/20/MYSQL知识整理（MYSQL基础-DDL数据定义语言）/","link":"","permalink":"http://www.yiyuclub.club/2019/06/20/MYSQL知识整理（MYSQL基础-DDL数据定义语言）/","excerpt":"MYSQL知识整理（MYSQL基础–DDL数据定义语言）","text":"MYSQL知识整理（MYSQL基础–DDL数据定义语言） 1.库的管理创建create database [if not exists]库名 [character set 字符集名]; 例子： create database IF NOT EXISTS userInfo SET gbk； 或 create database userInfo； 注：创建时库已存在会提示已存在 修改ALTER DATABASE 库名 [character set 字符集名]; 例子：ALTER DATABASE userInfo CHARACTER SET gbk; 注：由于此操作不安全，风险大，不建议 删除DROP DATABASE IF EXISTS 库名; 例子： DROP DATABASE IF EXISTS userInfo; 注：存在删除，不存在不删除 2.表的管理创建create table if not exists 表名( 列名 列的类型【(长度) 约束】, … [PRIMARY KEY (主键)] ) 例子： create table if not exists userInfo( userID int AUTO_INCREMENT, username varchar(20) NOT NULL, password varchar(30), PRIMARY KEY (userID) ) 修改修改列名： alter table 表名 change column 旧列名 新列名 类型; 修改类型约束： alter table 表名 modify column 列名 新类型 【新约束】; 新增列： alter table 表名 add column 列名 类型 【first|after 字段名】; 删除列： alter table 表名 drop column 列名; 修改表名： alter table 表名 rename 【to】 新表名; 删除DROP TABLE IF EXISTS 表名; 复制仅复制表结构： CREATE TABLE copy LIKE author; 仅复制表数据： CREATE TABLE 新表名 SELECT * FROM 旧表名; 复制表的结构+数据： CREATE TABLE 新表名 SELECT 列名1，列名2，...，列名n FROM 旧表名 WHERE condition; 仅复制某些字段： CREATE TABLE 新表名 SELECT 列名1，列名2，...，列名n FROM 旧表名 WHERE 0; 跨库复制： CREATE TABLE 新表名 SELECT 列名1，列名2，...，列名n FROM 旧库名.旧表名; 3.数据类型日期和时间类型 类型名称 定义 date ‘2019-6-21’ time ‘08 : 21 : 55’ datetime ‘2019-6-21 08 : 22 : 06’ timestamp ‘会随其他字段修改的时候自动刷新’ year ‘2019’ 字符串型 类型名称 定义 char(n) ‘定长，可至255字符’ varchar(n) ‘变长，可至65535字符’ tinytext ‘变长，可至255字符’ mediumtext ‘变长，可至2的24次方-1字符’ longtext ‘变长，2的32次方-1字符’ text ‘变长，可至65535字符’ 注： char(n) ,长度为n，实际长度不足补空格，实际字符串后不可有空格，检索速度快与varcharvarchar(n)，长度为实际字符个数+1，可直接创建索引,检索速度大于texttext，不能指定长度，长度为实际字符个数+2，创建索引要指定前多少个字符 整型 类型名称 定义 tinyint(m) ‘1个字节 范围(-128~127)’ smallint(m) ‘2个字节 范围(-32768~32767)’ mediumint(m) ‘3个字节 范围(-8388608~8388607)’ int(m) ‘4个字节 范围(-2147483648~2147483647)’ bigint(m) ‘8个字节 范围(+-9.22*10的18次方)’ 注：加入unsigned，范围加倍 浮点型 类型名称 定义 float(m,d) ‘单精度浮点型，8位精度(4字节)，m总个数，d小数位’ double(m,d) ‘双精度浮点型，16位精度(8字节)，m总个数，d小数位’ 定点型 类型名称 定义 decimal(m,d) ‘存放精确值， m&lt;65 是总个数，d&lt;30 且 d&lt;m 是小数位’ 二进制数据 类型名称 定义 _BLOB ‘二进制存储，不区分大小写，数据需整体读入，无需指定字符集’ TINYBLOB ‘最大255字节的二进制’ TINYTEXT ‘最大255字节的文本’ _text ‘以文本方式存储，区分大小写，可指定字符集’ MEDIUMBLOB ‘最大16777215字节的二进制’ MEDIUMTEXT ‘最大16777215字节的文本’ LONGBLOB ‘最大4294967295字节的二进制’ LONGTEXT ‘最大4294967295字节的文本’ 汉字编码 UTF－8：一个汉字＝3个字节 GBK：一个汉字＝2个字节 4.常见约束 类型关键字 定义 NULL ‘null值，该列不能为空’ NOT NULL ‘非nul值，该列可以为空’ DEFAULT ‘默认值’ PRIMARY KEY ‘主键’ AUTO_INCREMENT ‘自增，整型数据’ UNSIGNED ‘无符号’ CHARACTER SET name ‘设置值字符集’ UNIQUE ‘每一列的值唯一’ PRIMARY KEY ‘外键’ CHECK ‘检查字段的值是否为指定的值。mysql不支持’","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/categories/MYSQL/"},{"name":"MYSQL基础","slug":"MYSQL/MYSQL基础","permalink":"http://www.yiyuclub.club/categories/MYSQL/MYSQL基础/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.yiyuclub.club/tags/数据库/"},{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/tags/MYSQL/"}]},{"title":"MYSQL知识整理（MYSQL基础--DQL数据查询语言）","slug":"MYSQL知识整理（MYSQL基础-DQL数据查询语言）","date":"2019-06-19T01:37:13.000Z","updated":"2019-06-24T09:13:28.050Z","comments":true,"path":"2019/06/19/MYSQL知识整理（MYSQL基础-DQL数据查询语言）/","link":"","permalink":"http://www.yiyuclub.club/2019/06/19/MYSQL知识整理（MYSQL基础-DQL数据查询语言）/","excerpt":"MYSQL知识整理（MYSQL基础–DQL数据查询语言）","text":"MYSQL知识整理（MYSQL基础–DQL数据查询语言） 1.基础查询查询语句： select * from tablename 2.条件查询查询语句： select * from tablename where filed = &apos;condiction&apos; 符号： &gt;、 &lt;、 &lt;=、 &gt;=、 =、 &lt;&gt; BETWEEN...AND in，如in(数据1，数据2) like（通配符%、_） is null and 或 &amp;&amp;、or 或 || not 或 ! 3.排序查询查询语句： select * from tablename order by filed1 ASC，filed2 desc 符号： asc 默认，升序 desc 降序 4.常见函数聚合函数 count()： 统计不为null的列max()：计算列最大值，如为字符串，使用字符串排序min()：计算列最小值，如为字符串，使用字符串排序sum()：计算列的和，如该列不为数字，其为0avg()：计算列平均值，如该列不为数字，其为0 数学函数 PI()：计算圆的面积 CEIL(-12.3)：向上取整,大于这个数的最小的整数，12 FLOOR(-12.3)：向下取整,小于这个数的最大整数，13 ROUND(12.54,-1)：四舍五入,第二个参数代表从小数点的第几位开始四舍五入,-1代表小数点前一位 ROUND(12.54)：小数点大于等于5，向上取整，13 ROUND(12.54,1)：#保留小数点后一位数，4小于5,向下取，12.5 ABS(-10)：取绝对值，10 RAND()：0-1左闭右开 POW(2,3)：幂运算，8 SQRT(25)：开方 字符串函数 LOWER(filed):转成小写 UPPER(filed):转成大写 CONCAT(‘e-‘,filed)：#拼接字符串 SUBSTR(‘yiyu’,1,3)：取子串,这里的1为初始位置,3是代表长度，yiy REPLACE(‘yiyuhaha’,’haha’,’niubi’)：替换 TRIM(‘ a a ‘)：清除前后空格 LENGTH(‘aa’)：长度 LPAD(‘abc’,10,’‘):左填充至第二个参数长度,用 RPAD(‘abc’,10,’‘):左填充至第二个参数长度,用 日期函数 NOW()：获取当前日期时间 SYSDATE()：获取当前系统日期时间 CURRENT_TIMESTAMP()：获取当前时间戳 CURRENT_TIME()：获取当前时间,时分秒 CURRENT_DATE()：获取当前日期:年月日 YEAR(NOW())：获取年 MONTH(date)：获取月 DAY(date)：获取得日 DATE_ADD(NOW(),interval 2 MONTH)：第一个参数日期的后2个月的时间 LAST_DAY(NOW())：传入时间的月份的最后一天 加密函数 MD5(‘yiyu’):无法逆转SHA(‘yiyu’)PASSWORD(‘yiyu’) 5.分组查询查询语句： select username,count(userclass) from username group by username having count(userclass)&gt;5 符号： group by：分组字段having ：分组条件 6.连接查询（多表查询）定义：如果查询涉及两个以上的表需连接查询 一 内连接基本语句： select 查询列表 from 表1 别名 inner join 表2 别名 on 连接条件; 解释： 可把 inner join on 省略 ，写成多表以英文逗号隔开 等值连接查询语句： select a.username,b.personname from userInfo a,personInfo b where a.userid=b.userid 解释： 多表等值关联（交集）多表中无顺序可言为每个表起别名（默认该表名称为其别名） 非等值连接查询语句： select a.username,a.userid from userInfo a,personInfo b where a.userid BETWEEN b.low AND b.high 解释： 条件为非等号where 列名 BETWEEN … AND ….根据 personInfo 的条件查询 userInfo 的数据 自连接（特殊等值连接）查询语句： select a.username,b.username from userInfo a,userInfo b where a.userid=b.userid 解释： 自己与自己连接（该表与该表的副本连接）解决同一个表，列与副本同一列逻辑关系的问题 二 外连接定义： 分为主、从表，不管从表是否匹配，主表必显示（即显示主表所有数据，从表无，置null） 左外链接查询语句： select a.username,b.personname from userInfo a left out join personInfo b on a.userid=b.userid 解释： 主表为userInfo，会显示所有此数据从表为personInfo,显示与主表关联的数据，如没有，显示null 右外链接查询语句： select a.username,b.personname from userInfo a right out join personInfo b on a.userid=b.userid 解释： 主表为personInfo，会显示所有此数据从表为userInfo,显示与主表关联的数据，如没有，显示null 全外链接查询语句： select a.username,b.personname from userInfo a full out join personInfo b on a.userid=b.userid 解释： 无主从表，表之间互围主从表会显示所有表的数据，如无关联，其两表相应部分设为nullmysql不支持此操作 三 交叉查询查询语句： SELECT a.username,b.username FROM useInfo a,personInfo b; 解释： 与表关系无关显示多表的笛卡尔积 7.子查询定义：一个查询是另一个查询的条件（可用于增、删、查、改） 列举select子查询： select * from userInfo where userID in（select userID from personInfo where personname=’yiyu’） 解释： 根据 personInfo 的条件查询关联的userInfo信息 in表示符合子查询的条件，not in为不符合（或等号皆可） 8.分页查询定义：根据限制查询对应数量的数据 基本语句： SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset 解释： offset为偏移量，表示从哪开始截取数据（不包含该值）row表示截取多少行数据 例子：截取1001-1010的数据 select * from orders where limit 1000,10; 9.联合查询定义：要查询的结果来自多个表，且多个表没有直接的连接关系，但查询的信息一致 基本语句： select * from userInfo union（all） select * from personInfo 解释： 多条查询语句的查询列数要一致多条查询语句的查询的每一列的类型和顺序要保持一致union 去重union all 包含重复项 注意：MYSQL 不支持intersect（交集）与minus（差集）","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/categories/MYSQL/"},{"name":"MYSQL基础","slug":"MYSQL/MYSQL基础","permalink":"http://www.yiyuclub.club/categories/MYSQL/MYSQL基础/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.yiyuclub.club/tags/数据库/"},{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/tags/MYSQL/"}]},{"title":"MYSQL知识整理（MYSQL基础--基础内容）","slug":"MYSQL知识整理（MYSQL基础-基础内容）","date":"2019-06-18T01:42:29.000Z","updated":"2019-06-24T09:13:28.050Z","comments":true,"path":"2019/06/18/MYSQL知识整理（MYSQL基础-基础内容）/","link":"","permalink":"http://www.yiyuclub.club/2019/06/18/MYSQL知识整理（MYSQL基础-基础内容）/","excerpt":"MYSQL知识整理（MYSQL基础–基础内容）","text":"MYSQL知识整理（MYSQL基础–基础内容） 1.相关概念百度百科： MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。 MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。 MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。 MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。 由于其社区版的性能卓越，搭配 PHP 和 Apache 可组成良好的开发环境。 2.配置文件 port：端口 basedir：mysql安装的绝对路径 datadir：mysql数据存放的绝对路径 socket：套接字文件（mysql.sock） plugin_dir：mysql plugin插件路径 log-error：mysql错误日志文件 symbolic-links：默认0，如果为1mysql数据库和表数据支持存储datadir目录之外的路径 local-infile：0表示关闭服务器从本地load功能，1打开 max-connections：设置mysql最大连接数 query_cache_limit：单个查询缓冲区大小（默认1M） query_cache_size：查询缓存的大小 query_cache_type：设置缓存的类型（0禁用；1缓存所有结果；2之缓存select语句通过sql_cache制定需要的缓存查询） max_user_connections：用户连接的最大值设置 wait_timeout:超时等待时间 connect_timeout:客户端与服务器连接时，服务器返回错误的握手协议前，等待数据包的最大时间（s） thread_cache_size：缓存空闲线程 key_buffer_size：指定索引缓冲区大小 join_buffer_size：join查询缓存大小 max_heap_table_size：设置用户可创建内存表大小 low_priority_updates：服务器降低些操作的优先级，1位以读为主 max_seeks_for_key：设置key查询最大查找次数 max_allowd_packet：设置消息传输最大值 sort_buffer_size：设置group by和order by性能 read_buffer_size：设置服务器读缓存区大小 max_connect_errors：客户端连接服务器失败，累计时间超过此值，服务器将会阻止此客户端后续所有访问 myisam_sort_buffer_size：服务器重建索引时允许创建最大临时文件的大小 tmp_table_size：设置临时内部堆积表的大小 read_rnd_buffer_size：设置服务器随机读取缓冲区的大小 open_file_limit：控制文件发开的个数 3.常用命令① 基本操作： 创建数据库： create database createname; 选择数据库 user databasename; 删除数据库(无提示) drop database name; 显示表 show tables; 标的详细描述 describe tablename; select去重 select distinct 删除数据库（有提示） mysqladmin drop databasename; 显示mysql版本和日期 select version(),current_date; ② mysql修改root密码 mysqladmin -u用户名 -p旧密码 password 新密码 ③ 授权（grant）查看权限：show grants(查看其他用户的加上 for dba@localhost) grant select on 数据库. to 用户名@登录主机 identified by “密码” grant select, insert, update, delete on testdb. to common_user@’%’ 创建表、索引、视图、存储过程、函数。。。等权限同理 撤销权限：revoke all on . from dba@localhost; ④ 数据库备份 备份：mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名mysqldump -h host -u root -p dbname &gt;dbname_backup.sql 恢复：mysqladmin -h myhost -u root -p create dbnamemysqldump -h host -u root -p dbname &lt; dbname_backup.sql ⑤ 启动连接 mysql -h主机地址 -u用户名 －p用户密码 启动MYSQL服务 net start mysql 停止MYSQL服务 net stop mysql 查看被监听的端口 netstat –na | findstr 3306 退出：quit exit 显示当前用户 SELECT USER(); 显示当前数据库 SELECT DATABASE(); 4.语法规范 其不区分大小写（规范：关键字函数名大写，表名列名小写） 命令结尾用英文分号（；）结束 换行，缩进（这行操作） 注释（单行：#文字；多行：/ 文字 /） 别名 （使用as或者空格） 去重（distinct） 加号（+）（加法运算，如为字符，系统自动转数值，成功加法运算） concat（str1,str2）:连接字符串 不要使用mysql保留字作为数据库名称，表名称，字段名称 5.sql的语言分类① DDL数据库定义语言： 定义：定义了不同的数据段、数据库、表、列、索引等数据库对象，主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上 常用：CREATE ALTER DROP TRUNCATE COMMENT RENAME ② DCL数据库控制语言： 定义：用来设置或更改数据库用户或角色权限的语句 常用：grant,deny,revoke ③ DML数据库操作语言： 定义：实现对数据库中的数据进行操作 常用：INSERT UPDATE DELETE MERGE CALL （EXPLAIN PLAN） （LOCK TABLE） ④ TCL事务控制语言： 定义：保证原子性、一致性、完整性、持久性 常用：SAVEPOINT ROLLBACK （SET ⑤ DQL数据查询语言 定义：按条件查询语句 常用：SELECR * FROM TABLENAME","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/categories/MYSQL/"},{"name":"MYSQL基础","slug":"MYSQL/MYSQL基础","permalink":"http://www.yiyuclub.club/categories/MYSQL/MYSQL基础/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.yiyuclub.club/tags/数据库/"},{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/tags/MYSQL/"}]},{"title":"（软考架构师笔记二十一）虚拟化、云计算与物联网","slug":"（软考架构师笔记二十一）虚拟化、云计算与物联网","date":"2019-06-12T02:37:57.000Z","updated":"2019-10-18T00:22:29.333Z","comments":true,"path":"2019/06/12/（软考架构师笔记二十一）虚拟化、云计算与物联网/","link":"","permalink":"http://www.yiyuclub.club/2019/06/12/（软考架构师笔记二十一）虚拟化、云计算与物联网/","excerpt":"（软考架构师笔记二十一）虚拟化、云计算与物联网","text":"（软考架构师笔记二十一）虚拟化、云计算与物联网 1.虚拟化（1）定义 ① 虚拟化代表着对计算资源的抽象，而不仅仅局限于虚拟机的概念 （2）分类① 平台虚拟化 是针对计算机和操作系统的虚拟化，通过使用控制程序（Control Program，也称为 VirtualMachine Monitor 或 Hypervisor），隐藏特定计算平台的实际物理特性，为用户提供抽象的、统一的、模拟的计算环境 全虚拟化：虚拟机模拟了完整的底层硬件，包括处理器、物理内存、时钟、外设等，使得为原始硬件设计的操作系统或其他系统软件完全不作任何修改就可以在虚拟机中运行 超虚拟化：是一种修改 Guest OS 部分访问特权状态的代码以便直接与 VMM 交互的技术 硬件辅助虚拟化：借助硬件（主要是主机处理器）的支持来实现高效的全虚拟化 部分虚拟化：VMM 只模拟部分底层硬件，因此客户机操作系统不作修改是无法在虚拟机中运行的，其他程序可能也需要进行修改 操作系统级虚拟化：是一种在服务器操作系统中使用的轻量级的虚拟化技术，内核通过创建多个虚拟的操作系统实例（内核和库）来隔离不同的进程，不同实例中的进程完全不了解对方的存在 ② 资源虚拟化： 针对特定的系统资源的虚拟化，比如内存、存储、网络资源等 ③ 应用程序虚拟化 应用程序虚拟化（Application Virtualization），包括仿真、模拟、解释技术使用了一种被称为动态二进制翻译的技术把对特权状态的访问转换成对影子状态的操作，从而避免了低效的 Trap-And-Emulate 的处理方式，这与超虚拟化相似，只不过超虚拟化是静态地修改程序代码 （3）虚拟化的模式 ① 单一资源多个逻辑表示： 只包含一个物理资源，但是它向消费者呈现的逻辑表示却仿佛它包含多个资源一样 ② 多个资源单一逻辑表示： 包含了多个组合资源，以便将这些资源表示为提供单一接口的单个逻辑表示形式 ③ 在多个资源之间提供单一逻辑表示： 包括一个以多个可用资源之一的形式表示的虚拟资源。虚拟资源会根据指定的条件来选择一个物理资源实现。 ④ 单个资源单一逻辑表示 用来表示单个资源的一种简单模式，就仿佛它是别的什么资源一样 ④ 复合或分层虚拟 是前面介绍的一种或多种模式的组合，它使用物理资源来提供丰富的功能集 它提供了底层所需要的功能，这些功能用于管理对资源、包含有关如何处理和使用信息的元数据，以及对信息进行处理的操作的全局命名和引用 2.云计算（1）定义 ① 是一种基于互联网的计算方式，通过这种方式，共享的软硬件资源和信息可以按需提供给计算机和其他设备 （2）核心思想： 将大量用网络连接的计算资源统一管理和调度，构成一个计算资源池向用户按需服务 （3）云 提供资源的网络 （4）云计算的特点： ① 计算资源集成提高设备计算能力 ② 分布式数据中心保证系统容灾能力 ③ 软硬件相互隔离减少设备依赖性 ④ 平台模块化设计体现高可扩展性 ⑤ 虚拟资源池为用户提供弹性服务 ⑥ 按需付费降低使用成本 （5）云计算的类型① 软件即服务（SaaS）： 基于互联网提供软件服务的软件应用模式 提供商为企业搭建信息化所需要的所有网络基础设施及软件、硬件运作平台，并负责所有前期的实施、后期的维护等一系列服务，企业无须购买软硬件、建设机房、招聘 IT人员，即可通过互联网使用信息系统 ② 平台即服务（PaaS）： 把服务器平台或者开发环境作为一种服务提供的商业模式，如将软件研发的平台作为一种服务，以 SaaS 的模式提交给用户 它能够提供企业进行定制化研发的中间件平台，同时涵盖数据库和应用服务器等。PaaS 可以提高在 Web 平台上利用的资源数量 ③ 基础设施即服务（laaS） 消费者通过 Internet 可以从完善的计算机基础设施获得服务 （6）云计算的应用 ① 云安全 通过网状的大量客户端对网络中软件行为的异常监测，获取互联网中木马、恶意程序的最新信息，推送到 Server 端进行自动分析和处理，再把病毒和木马的解决方案分发到每一个客户端 ② 云存储 指通过集群应用、网格技术或分布式文件系统等功能，将网络中大量各种不同类型的存储设备通过应用软件集合起来协同工作，共同对外提供数据存储和业务访问功能的一个系统 ③ 云呼叫 基于云计算技术而搭建的呼叫中心系统，企业无须购买任何软、硬件系统，只需具备人员、场地等基本条件，就可以快速拥有属于自己的呼叫中心，软硬件平台、通信资源、日常维护与服务由服务器商提供周期短、投入少、风险低、部署灵活、系统容量伸缩性强、运营维护成本低 ④ 云会议 基于云计算技术的一种高效、便捷、低成本的会议形式是视频会议与云计算的完美结合，带来了最便捷的远程会议体验 3.物联网（1）定义： 实现物物相连的互联网络 （2）内涵： 第一，物联网的核心和基础仍然是互联网，是在互联网基础上延伸和扩展的网络第二，其用户端延伸和扩展到了任何物体与物体之间，使其进行信息交换和通信 （3）功能： ① “内在智能”的传感器、移动终端、工业系统、楼控系统、家庭智能设施、视频监控系统等和“外在使能”② 提供安全可控乃至个性化的实时在线监测、定位追溯、报警联动、调度指挥、预案管理、远程控制、安全防范、远程维保、在线升级、统计报表、决策支持等管理和服务功能 （4）层次结构 ① 感知层（底层） ① 用途：用于识别物体、采集信息 ② 应用：包括二维码标签和识读器、RFID 标签和读写器、摄像头、GPS、传感器、M2M 终端、传感器网关 ③ 功能：识别物体、采集信息，与人体结构中皮肤和五官的作用类似 ④ 过程：它首先通过传感器、数码相机等设备，采集外部物理世界的数据，然后通过 RFID、条码、工业现场总线、蓝牙、红外等短距离传输技术传递数据。感知层所需要的关键技术包括检测技术、短距离无线通信技术 ② 网络层 ① 用途：传递信息和处理信息 ② 应用：包括通信网与互联网的融合网络、网络管理中心、信息中心和智能处理中心 ③ 功能：将感知层获取的信息进行传递和处理，类似于人体结构中的神经中枢和大脑 ④ 设施：将建立在现有的移动通信网和互联网基础上 ⑤ 所解决问题：传输和预处理感知层所获得数据的问题 ③ 应用层 ① 用途：广泛智能化（经过分析处理的感知数据，为用户提供丰富的特定服务） ② 应用：监控型（物流监控、污染监控）、查询型（智能检索、远程抄表）、控制型（智能交通、智能家居、路灯控制）和扫描型（手机钱包、高速公路不停车收费） ③ 功能：将感知层获取的信息进行传递和处理，类似于人体结构中的神经中枢和大脑 ④ 类别：应用程序层（进行数据处理，它涵盖了国民经济和社会的每一领域，包括电力、医疗、银行、交通、环保、物流、工业、农业、城市管理、家居生活等，其功能可包括支付、监控、安保、定位、盘点、预测等，可用于政府、企业、社会组织、家庭、个人等。这正是物联网作为深度信息化的重要体现）终端设备层（提供人机接口） ⑤ 所解决问题：信息处理和人机交互的问题 （5）相关领域与技术 ① 射频识别技术（称电子标签）（RFID） ① 通过无线电信号识别特定目标并读写相关数据，而无须识别系统与特定目标之间建立机械或光学接触 ② 采用非接触的自动识别技术:通过射频信号自动识别目标对象并获取相关数据，识别工作无须人工干预，可工作于各种恶劣环境 ③ RFID组成：标签（Tag）：由耦合元件及芯片组成，每个标签具有唯一的电子编码，附着在物体上标识目标对象阅读器（Reader）：读取（有时还可以写入）标签信息的设备，可设计为手持式或固定式天线（Antenna）：在标签和读取器间传递射频信号 ④ RFID原理：标签进入磁场后，接收解读器发出的射频信号，凭借感应电流所获得的能量发送出存储在芯片中的产品信息（Passive Tag，无源标签或被动标签），或者由标签主动发送某一频率的信号（Active Tag，有源标签或主动标签），解读器读取信息并解码后，送至中央信息系统进行有关数据处 ⑤ RFID系统组成：阅读器、电子标签（即应答器）、应用软件系统 ⑥ RFID系统原理：Reader 发射一特定频率的无线电波能量给 Transponder，用以驱动Transponder 电路将内部的数据送出，此时 Reader 便依序接收解读数据，送给应用程序作相应的处理 ⑦ 感应方式：感应耦合（Inductive Coupling）：低频的RFID后向散射耦合（Backscatter Coupling）：较高频RFID ⑧ 阅读器：耦合模块、收发模块、控制模块和接口单 ⑨ 阅读器交换方式：半双工通信方式（通过耦合给无源应答器提供能量和时序） ⑩ 应答器：是 RFID 系统的信息载体，耦合原件（线圈、微带天线等）和微芯片组成无源单元 ② 二维码技术 ① 定义：用某种特定的几何图形按一定规律在平面（二维方向上）分布的记录数据符号信息的黑白相间的图形，利用构成计算机内部逻辑基础的“0”、“1”比特流的概念，使用若干个与二进制相对应的几何形体来表示文字数值信息，通过图像输入设备或光电扫描设备自动识读以实现信息自动处理 ② 与条形码共性：每种码制有其特定的字符集、每个字符占有一定的宽度、具有一定的校验功能 ③ 常用码值：Data Matrix、Maxi Code、Aztec、 QR Code、Vericode、PDF417、Ultracode、Code 49、Code 16K ④ 方向：横向和纵向 ③ 传感网： 定义：由随机分布的，集成有传感器（传感器有很多种类型，包括温度、湿度、速度、气敏等）、数据处理单元和通信单元的微小节点，通过自组织的方式构成的无线网络 ④ M2M 定义：M2M 是将数据从一台终端传送到另一台终端，也就是机器与机器（Machine to Machine）的对话 （6）物联网的应用 物联网用途广泛，遍及智能交通、环境保护、政府工作、公共安全、平安家居、智能消防、工业监测、老人护理、个人健康等多个领域","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.yiyuclub.club/categories/学习笔记/"},{"name":"软考架构师","slug":"学习笔记/软考架构师","permalink":"http://www.yiyuclub.club/categories/学习笔记/软考架构师/"}],"tags":[{"name":"软考","slug":"软考","permalink":"http://www.yiyuclub.club/tags/软考/"},{"name":"架构师","slug":"架构师","permalink":"http://www.yiyuclub.club/tags/架构师/"}]},{"title":"（软考架构师笔记二十）应用数学","slug":"（软考架构师笔记二十）应用数学","date":"2019-06-12T00:46:18.000Z","updated":"2019-10-17T09:14:56.883Z","comments":true,"path":"2019/06/12/（软考架构师笔记二十）应用数学/","link":"","permalink":"http://www.yiyuclub.club/2019/06/12/（软考架构师笔记二十）应用数学/","excerpt":"（软考架构师笔记二十）应用数学","text":"（软考架构师笔记二十）应用数学 1.运筹方法（1）定义 ① 将生产、管理等事件中出现的一些带有普遍性的运筹问题加以提炼，然后利用数学方法进行解决 ② 步骤：确定目标、制订方案、建立模型、制订解法 2.网络计划技术（1）定义 ① 用网络分析的方法编制的计划 （2）关键路径法（CPM） ① 定义：通过网络分析研究工程费用与工期的关系，并找出在编制计划及计划执行过程中的关键路径 ② 活动：一项工程常被分为多个小的子工程，这些子工程称为活动 ③ AOV网：在有向图中，若以顶点表示活动，弧表示活动之间的先后关系 ④ AOE网：若以顶点表示事件，弧表示活动，权表示完成该活动所需的时间（称为活动历时或持续时间） ⑤ 完成工程最少时间（关键路径）：开始顶点到结束顶点最长路径 ⑥ 关键活动：关键路径上的活动（即线段），关键路径可以不止一条 关键路径步骤： 最早发生时间：每个节点从前往后寻找最长路径记录ve（第一个节点为0） 最迟发生时间：每个节点从后往前寻找， = 最迟发生时间（后一个） - 两节点长度。(最后一个节点最迟发生时间为整个项目最长路径) 寻找最早发生时间和最迟发生时间，相同即为关键路径节点 最早开始时间：等于当前边起始结点的最早发生时间 最晚开始时间：等于当前边指向结点的最迟发生时间-当前边的权值 最早完工时间：等于当前边指向结点的最早发生时间 最晚完工时间：等于当前边指向结点的最迟发生时间 （3）网络优化 ① 时间优化 ② 时间-资源优化 ③ 时间-费用优化 3.决策论（1）决策过程和模型构造决策行为的模型主 ① 面向结果的方法② 面向过程的方法 （2）面向决策结果 确定目标→收集信息→提出方案→方案选择→决策 （3）面向决策过程 预决策→决策→决策后 （4）决策模型 决策者可供选择的方案（替代方案）、行动或策略衡量选择方案的准则事件:不为决策者所控制的、客观存在的、将发生的状态每一事件的发生将会产生的某种结果决策者的价值观 （5）不确定型决策 决策者对环境情况一无所知，决策者根据自己的主观倾向进行决策 ① 乐观主义准则（最大最大准则（maxmax 准则）） 原则：“大中取大”对事物总抱有乐观和冒险的态度，不放弃任何获得最好结果的机会 ② 悲观主义准则（最大最小准则（maxmin 准则）） 原则：“小中取大”对事物抱有悲观和保守的态度，在各种最坏的可能结果中选择最好的 ③ 折中主义准则（赫尔威斯（Harwicz）准则） 对事物既不乐观冒险，也不悲观保守公式计算：cvi=α×max{aij}+(1−α)×min{aij} ④ 等可能准则（拉普拉斯（Laplace）准则） 无法事先确定每个自然状态出现的概率把每个状态出现的概率定为 1/n （n 是自然状态数） ⑤ 后悔值准则（为萨维奇（Savage）准则、最小机会损失准则） 每个自然状态的最大收益值（损失矩阵取为最小值），作为该自然状态的理想目标，并将该状态的其他值与最大值相减所得的差作为未达到理想目标的后悔值 （6）风险决策 决策者对客观情况不甚了解，但对将发生各事件的概率是已知的 ① 最大期望收益决策准则：从期望收益中选择最大值 ② 最小机会损失决策准则：从期望收益中选择最小值 （7）对策论（竞赛论或博弈论） 研究具有竞争（或斗争）性质现象的数学理论和方法 （8）数学建模 ① 数学模型 客观世界中的实际事物的一种数学简化，它常常是以某种意义上接近实际事物的抽象形式存在的 ② 数学语言： 为了使描述更具科学性、逻辑性、客观性和可重复性，人们采用一种普遍认为比较严格的语言来描述各种现象 ③ 数学建模的过程 ① 模型准备② 模型假设③ 模型建立④ 模型求解⑤ 模型分析⑥ 模型检验⑦ 模型应用 ④ 建模方法和思路 ① 直接分析法：根据对问题内在机理的认识，直接构造出模型② 类比法：根据类似问题的模型构造新模型③ 数据分析法:通过试验，获得与问题密切相关的大量数据，用统计分析方法进行建模④ 构想法:对将来可能发生的情况给出逻辑上合理的设想和描述，然后用已有的方法构造模型，并不断修正完善，直至用户比较满意为止","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.yiyuclub.club/categories/学习笔记/"},{"name":"软考架构师","slug":"学习笔记/软考架构师","permalink":"http://www.yiyuclub.club/categories/学习笔记/软考架构师/"}],"tags":[{"name":"软考","slug":"软考","permalink":"http://www.yiyuclub.club/tags/软考/"},{"name":"架构师","slug":"架构师","permalink":"http://www.yiyuclub.club/tags/架构师/"}]},{"title":"（软考架构师笔记十九）标准化知识","slug":"（软考架构师笔记十九）标准化知识","date":"2019-06-12T00:43:47.000Z","updated":"2019-10-17T03:20:41.793Z","comments":true,"path":"2019/06/12/（软考架构师笔记十九）标准化知识/","link":"","permalink":"http://www.yiyuclub.club/2019/06/12/（软考架构师笔记十九）标准化知识/","excerpt":"（软考架构师笔记十九）标准化知识","text":"（软考架构师笔记十九）标准化知识 1.标准化知识（1）定义 ① 标准：为在一定的范围内获得最佳秩序，对活动或其结果规定共同的和重复使用的规则或特性的文件 ② 标准化：在经济、技术、科学及管理等社会实践中，对重复性事物和概念通过制定、发布和实施标准达到统一，以获得最佳秩序和最大社会效益 2.标准分级与标准类型（1）标准分级 ① 国际标准：由国际联合机构制定和公布，提供各国参考的标准 ② 国家标准：由政府或国家级的机构制定或批准，适用于全国范围的标准 GB（或 GB/T）、ANSI、FIPS-NBS、BS、JIS ③ 行业标准：由行业机构、学术团体或国防机构制定，并适用于某个业务领域的标准 IEEE、GJB、DOD-STD、MIL-S、SJ ④ 区域/地方标准：由区域性国际联合机构制定和公布，提供区域内各国参考和执行的标准 ARS、EN、PAS ⑤ 企业标准：一些大型企业或机构，由于工作需要制定的适用于本企业或机构的标准 企业标准以 Q 字开头 （2）各级标准之间的关系 ① 对需要在全国范围内统一的技术要求，应当制定国家标准 ② 对没有国家标准而又需要在全国某个行业范围内统一的技术要求，可以制定行业标准。在公布国家标准之后，该项行业标 准即行废止 ③ 对没有国家标准和行业标准而又需要在省、自治区、直辖市范围内统一的工业产品的安全、卫生要求，可以制定地方标准。在公布国家标准或者行业标准之后，该项地方标准即行废止 ④ 企业生产的产品没有国家标准和行业标准的，应当制定企业标准，作为组织生产的依据。已有国家标准或者行业标准的，国家鼓励企业制定严于国家标准或者行业标准的企业标准，在企业内部适用 （3）强制性标准与推荐性标准 ① 定义： 《中华人民共和国标准化法》规定：国家标准、行业标准分为强制性标准和推荐性标准 ② 强制性标准： 保障人体健康，人身、财产安全的标准和法律、行政法规规定强制执行的标准 强制性国家标准以 GB 开头 ③ 推荐性标准 除强制性标准外的其他标准 推荐性国家标准以 GB/T 开头 ④ 强制性标准的两种形式： 全文强制形式：标准的全部技术内容需要强制 条文强制：标准中部分技术内容需要强制 ⑤ 强制性内容的范围： 有关国家安全的技术要求保障人体健康和人身、财产安全的要求产品及产品生产、储运和使用中的安全、卫生、环境保护、电磁兼容等技术要求工程建设的质量、安全、卫生、环境保护要求及国家需要控制的工程建设的其他要求污染物排放限值和环境质量要求保护动植物生命安全和健康的要求防止欺骗、保护消费者利益的要求国家需要控制的重要产品的技术要求","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.yiyuclub.club/categories/学习笔记/"},{"name":"软考架构师","slug":"学习笔记/软考架构师","permalink":"http://www.yiyuclub.club/categories/学习笔记/软考架构师/"}],"tags":[{"name":"软考","slug":"软考","permalink":"http://www.yiyuclub.club/tags/软考/"},{"name":"架构师","slug":"架构师","permalink":"http://www.yiyuclub.club/tags/架构师/"}]},{"title":"（软考架构师笔记十八）软件的知识产权保护","slug":"（软考架构师笔记十八）软件的知识产权保护","date":"2019-06-11T01:04:47.000Z","updated":"2019-10-17T03:13:02.297Z","comments":true,"path":"2019/06/11/（软考架构师笔记十八）软件的知识产权保护/","link":"","permalink":"http://www.yiyuclub.club/2019/06/11/（软考架构师笔记十八）软件的知识产权保护/","excerpt":"（软考架构师笔记十八）软件的知识产权保护","text":"（软考架构师笔记十八）软件的知识产权保护 1.概念（1）定义 其称为“智力成果权”、“智慧财产权”，指民事权利主体（自然人、法人）基于创造性的智力成果 （2）特点 无形性专有性地域性时间性 （3）相关法律法规 《著作权法》《计算机软件保护条件》《专利法》《商标法》《反不正当竞争法》 2.著作权法及实施条例（1）著作权法客体： ① 作品类型： 文字作品：包括小说、诗词、散文、论文等以文字形式表现的作品口述作品：是指即兴的演说、授课、法庭辩论等以口头语言形式表现的作品音乐、戏剧、曲艺、舞蹈、杂技作品美术、摄影作品电影、电视、录像作品工程设计、产品设计图纸及其说明地图、示意图等图形作品计算机软件法律、行政法规规定的其他作品 ② 职务作品 为完成单位工作任务所创作的作品，称为职务作品 该职务作品是利用单位的物质技术条件进行创作，并由单位承担责任的 有合同约定，其著作权属于单位(作者将仅享有署名权，其他著作权归单位享有) 著作权仍由作者享有，单位有权在业务范围内优先使用，并且在两年内，未经单位同意，作者不能够许可其他人、单位使用该作品 （2）著作权法的主体 ① 著作权人与受让者： 著作权人：又称为原始著作权人，是根据创作的事实进行确定的，创作、开发者将依法取得著作权资格（为他人创作进行的活动不算）受让者：又称为后继著作权人，是指没有参与创作，通过著作权转移活动成为享有著作权的人 ② 著作权人的确定： 根据创作事实确认，提意见不算多人参与，著作权共同所有合同作品可分割，可单独享有自己完成那部分的著作权著作权不明，作品原件的所有人可以行使除署名权以外的著作权（直到身份确认） 注意：委托关系，一般需合同约定，如无合同，著作权归受托人所有（创造作品的人） （3）著作权： ① 著作人对作品享有的权利 发表权：即决定作品是否公之于众的权利署名权：即表明作者身份，在作品上署名的权利修改权：即修改或者授权他人修改作品的权利保护作品完整权：即保护作品不受歪曲、篡改的权利使用权、使用许可权和获取报酬权、转让权：即以复制、表演、播放、展览、发行、摄制电影、电视、录像或者改编、翻译、注释、编辑等方式使用作品的权利；以及许可他人以上述方式使用作品，并由此获得报酬的权利 ② 著作权保护期限： 著作权属于公民：署名权、修改权、保护作品完整权的保护期没有任何限制，永远属于保护范围;发表权、使用权和获得报酬权的保护期为作者终生及其死亡后的50年（第50年的12月31日）。作者死亡后，著作权依照继承法进行转移 著作权属于单位：发表权、使用权和获得报酬权的保护期为 50 年（首次发表后的第50年的12月31日），若50年内未发表的，不予保护。但单位变更、终止后，其著作权由承受其权利义务的单位享有 ③ 使用许可权： 第三方需要使用时，需得到著作权人的使用许可，双方应签订相应的合同（合同不能超过10年）对于出版者、表演者、录音录像制作者、广播电台、电视台而言，在下列情况下使用作品，可以不经著作权人许可、不向其支付报酬。但应指名作者姓名、作品名称，不得侵犯其他著作权为个人学习、研究或者欣赏，使用他人已经发表的作品为介绍、评论某一个作品或者说明某一个问题，在作品中适当引用他人已经发表的作品为报道时间新闻，在报纸、期刊、广播、电视节目或者新闻记录影片中引用已经发表的作品报纸、期刊、广播电台、电视台刊登或者播放其他报纸、期刊、广播电台、电视台已经发表的社论、评论员文章报纸、期刊、广播电台、电视台刊登或者播放在公众集会上发表的讲话，但作者声明不许刊登、播放的除外为学校课堂教学或者科学研究，翻译或者少量复制已经发表的作品，供教学或者科研人员使用，但不得出版发行国家机关为执行公务使用已经发表的作品图书馆、档案馆、纪念馆、博物馆、美术馆等为陈列或者保存版本的需要，复制本馆收藏的作品免费表演已经发表的作品对设置或者陈列在室外公共场所的艺术作品进行临摹、绘画、摄影、录像将已经发表的汉族文字作品翻译成少数民族文字在国内出版发行将已经发表的作品改成盲文出版。 3. 计算机软件保护条例（1）《计算机软件保护条例》 1991 年 6 月通过，10 月 1 日正式实施最新版本是在 2001 年底通过，2002 年 1 月 1 日正式实施的客体是计算机软件受保护的软件必须由开发者独立开发，并且已经固定在某种有形物体上保护只是针对计算机软件和文档，并不包括开发软件所用的思想、处理过程、操作方法或数学概念 （1）著作权人的确定 合作开发：合约决定（若无，按开发部分分割） 职务开发：按工作开发的；使用了公司物质和技术条件并由公司承担责任的； 委托开发：如有合同属于委托人所有；若无则为受托人所有 （2）软件著作权 著作权属于公民（第17章）：直至死后50年著作权属于单位（第17章）：50年合法复制品所有人权利（第17章）使用许可的特例：用以学习，而以安装、显示、存储软件等方式使用软件，可以使用侵权责任：民事责任、刑事责任和行政责任 4.商标法及实施条例（1）定义： 可注册地商标：任何能够将自然人、法人及组织的商品与他人的商品区别开的可视性标志包括文字、图形、字母、数字、三维标志和颜色组合须报商标局核准注册包括商品商标、服务商标、集体商标，以及证明商标 （2）商标的使用 将商标用于商品、包装、容器、交易文书、广告宣传、展览，以及其商业活动中。 （3）商标的使用期限： 注册商标的有效期是 10 年，从核准通过、正式注册之日起开始计算。在有效期满之后，可以续注册，但必须在期满前 6 个月提出申请，如未在此期间提出申请的，则给予6个月的宽限期，在宽限期还未提出申请的，将注销其商标 （4）注册商标的申请：按使用者使用先后区分；若无法确定，则协商直至抽签 （5）注册商标专用权保护（下列为侵犯）： ① 未经商标注册人的许可，使用相同或近似商标 ② 销售侵犯商标专用权的商品（注：如果销售方不知道是侵权商品，并且能够证明自己是合法取得的，不承担相应责任） ③ 伪造他人注册商标，或销售这些伪造的注册商标 ④ 未经商标注册人同意，更换其注册商标，并将更换商标的商品投入市场 （6）注册商标使用的管理 当合法地注册了商标使用权后，就可以在商品、商品包装、说明书或者其他附着物上标明“注册商标”或者注册标记（包括©和®） 注意：如注册商标人死亡，1年内没有办理商标转移手续，其商标可被任何人注册 5.专利法及实施细则（1）定义 客体：发明创造，也就是其保护的对象 发明创造：指发明、实用新型和外观设计 发明：指对产品、方法或者其改进所提出的新的技术方案 实用新型：指对产品的形状、构造及其组合，提出的适于实用的新的技术方案 外观设计：指对产品的形状、图案及其组合，以及色彩与形状、图案的结合所作出的富有美感并适于工业应用的新设计 （2）申请专利权条件 新颖性创造性实用性 注意：对于科学发现、智力活动的规则和方法、疾病的诊断和治疗方法、动植物品种及用原子核变换方法获得的物质，不能够被授予专利权 （3）确定专利权人 ① 定义： 专利权归属于发明人或者设计人，这是指对发明创造作出创造性贡献的人 在发明创造过程中，只负责组织、提供方便、从事辅助工作的都不属于发明人或设计人 ② 职务发明：执行单位任务，或者利用本单位的物质技术条件所完成的发明创造，被视为职务发明创造 在本职工作中作出的发明创造 在履行单位交付的本职工作之外的任务所做出的发明创造 退职、退休或者调动工作后 1 年内做的，与其原来承担的任务相关的发明创造 ③ 合作发明、设计： 对于合作发明、设计的，其专利权应属共同所有，但可以根据合作方之间另行签订的合同来确定专利权的归属 ④ 委托发明： 一个单位或者个人接受其他单位或个人的委托，所完成的发明创造，若没有签订合同规定专利权归属，则专利权归属发明、设计者 非职务发明，则单位无权压制个人进行专利权申请。对于多个相类似的专利申请，则专利权归属最先提交的申请人 （4）专利权 ① 定义： 未经专利权人许可，实施专利的，就属于侵犯专利权，专利权人可以起诉，申请调解处 3 倍以下，或 5 万元以下的罚款专利诉讼的有效期是 2年，以专利权人得知侵权行为之日起计算 ② 不视为侵权行为 ① 对于专利权人制造、进口或者经专利权人许可而制造、进口的专利产品，或者依照专利方法直接获得的产品售出后，使用、许诺销售或者销售该产品 ② 在专利申请日前已经制造相同产品，使用相同方法或者已经作好制造、使用的必要准备，并且在原有范围内继续制造、使用 ③ 临时通过中国的国外运输工具，按其自身需要使用了专利 ④ 专为科学研究和实验而使用有关专利的。我国现行专利法规定的发明专利权保护期限为 20 年，实用新型和外观设计专利权的期限为 10 年，均从申请日开始计算。 （5）反不正当竞争法 ① 定义： 指经营者违反规定，损害其他经营者的合法权益，扰乱社会经济秩序的行为 ② 行为： 采用不正当的市场交易手段利用垄断的地位，来排挤其他经营者的公平竞争 利用政府职权，限定商品购买，以及对商品实施地方保护主义 利用财务或其他手段进行贿赂，以达到销售商品的目的 利用广告或者其他方法，对商品的质量、成分、性能、用途、生产者、有效期、产地等进行误导性的虚假宣传 以低于成本价进行销售，排挤竞争对手。不过对于鲜活商品、有效期将至及积压产品的处理，以及季节性降价，清债、转产、歇业等原因进行降价销售均不属于不正当竞争 搭售违背购买者意愿的商品 采用不正当的有奖销售。例如谎称有奖，却是内定人员中奖；利用有奖销售推销价高产品；奖金超过 5 000 元的抽奖式有奖销售 捏造、散布虚伪事实，损害对手商誉 串通投标，排挤对手 ③ 罚款说明 （1）对于假冒注册商标、姓名、认证、产地的不正当竞争行为根据《商标法》进行处罚；仿冒知名商标的，则可以根据情节处违法所得的 1 万～3 万元罚款，特别严重的追究刑事责任（2）通过贿赂达到销售目的，根据情节处以 1 万～20 万元罚款，严重的追究刑事责任。（3）利用独占地位进行经营，根据情节处以 5 万～20 万元罚款；借此销售质次价高商品的，则没收违法所得，并罚款 1 万～3 万元。（4）采用广告误导消费者，处以 1 万～20 万元罚款。（5）采用不合法的有奖销售的，根据情节处以 1 万～10 万元的罚款。（6）串通投标者，根据情节处以 1 万～20 万元的罚款。 ④ 侵犯商业秘密(按情节处以 1 万～20 万元罚款)： （1）以盗窃、利诱、胁迫等不正当手段获取别人的商业秘密（2）披露、使用以不正当手段获取的商业秘密（3）违反有关保守商业秘密的要求约定，披露、使用其掌握的商业秘密","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.yiyuclub.club/categories/学习笔记/"},{"name":"软考架构师","slug":"学习笔记/软考架构师","permalink":"http://www.yiyuclub.club/categories/学习笔记/软考架构师/"}],"tags":[{"name":"软考","slug":"软考","permalink":"http://www.yiyuclub.club/tags/软考/"},{"name":"架构师","slug":"架构师","permalink":"http://www.yiyuclub.club/tags/架构师/"}]},{"title":"（软考架构师笔记十七）系统的可靠性分析与设计","slug":"（软考架构师笔记十七）系统的可靠性分析与设计","date":"2019-06-11T00:02:39.000Z","updated":"2019-10-17T02:37:44.100Z","comments":true,"path":"2019/06/11/（软考架构师笔记十七）系统的可靠性分析与设计/","link":"","permalink":"http://www.yiyuclub.club/2019/06/11/（软考架构师笔记十七）系统的可靠性分析与设计/","excerpt":"（软考架构师笔记十七）系统的可靠性分析与设计","text":"（软考架构师笔记十七）系统的可靠性分析与设计 1.可靠性（1）可靠度 在 t=0 时系统正常的条件下，系统在时间区间[0,t]内能正常运行的概率(无故障的概率) （2）可用度 系统在时刻 t 可运行的概率（有故障货物故障都能运行的概率） （3）可维度 系统失效后，在时间间隔内被修复的概率 （4）平均无故障时间 从 t=0 时到故障发生时系统的持续运行时间的期望值，MTTF=1/λ（λ为失效率，是指器件或系统在单位时间内发生失效的预期次数） （5）平均故障修复时间 MTTR =1/ μ（μ修复率是指单位时间内可修复系统的平均次数） （6）平均故障间隔时间 MTBF = MTTR + MTTF 2.系统故障模型（1）故障的来源以及表现： 失效：硬件的物理改变故障：由于部件的失效、环境的物理干扰、操作错误或不正确的设计引起的硬件或软件中的错误状态错误（差错）：故障在程序或数据结构中的具体位置（以下三个为错误的表现方式）① 永久性：描述连续稳定的失效、故障或错误。在硬件中，永久性失效反映了不可恢复的物理改变② 间歇性：描述那些由于不稳定的硬件或变化着的硬件或软件状态所引起的、仅仅是偶然出现的故障或错误③ 瞬时性：描述那些由于暂时的环境条件而引起的故障或错误。 （2）几种常用的故障模型 ① 逻辑级的故障模型： 固定型故障：电路中元器件的输入或输出等线的逻辑固定为 0 或固定为 1短路故障：一个元件的输出线的逻辑值恒等于输入线的逻辑值元件的开路故障：元件的输出线悬空，逻辑值可根据具体电路来决定桥接故障：两条不应相连的线连接在一起而发生的故障 ② 数据结构级的故障： 独立差错：一个故障的影响表现为使一个二进制位发生改变算术差错：一个故障的影响表现为使一个数据的值增加或减少 2i(i=0,1,2,…)单向差错：一个故障的影响表现为使一个二进制向量中的某些位朝一个方向（0 或 1）改变。 （3）软件故障和软件差错： ① 定义： 指软件设计过程造成的与设计说明的不一致的情况，其在数据结构或程序输出中的表现称为软件差错 ② 软件差错类型： 非法转移：程序执行了说明中不存在的转移误转移：程序执行了尽管说明中存在，但依据当前控制数据不应进行的转移死循环：程序执行时间超过了规定界限空间溢出：程序使用的空间超过了规定的界限数据执行：指令计数器指向数据单元无理数据：程序输出的数据不合理 ③ 系统级的故障模型故障： 功能错误：即系统输出与系统设计说明的不一致 3. 系统配置方法（1）容错技术 ① 定义 保证系统在某些组成部分出现故障或差错时仍能正常工作的技术 错技术正是用于构造一种能够自动排除非致命性故障的系统，即容错系统 ② 单机容错技术： 自检技术：自检指系统在发生非致命性故障时能自动发现故障和确定故障的性质、部位，并自动采取措施更换和隔离产生故障的部件 冗余技术：如下 硬件冗余（增加硬件）软件冗余（增加程序，如同时采用不同算法或不同人编制的程序）时间冗余（如指令重复执行、程序重复执行）信息冗余（如增加数据位）； 冗余技术常用方法： 常使用重复线路（用多个相同品种和规格的元件或构件并联起来，当作一个元件或构件使用，只要有一个不出故障，系统就能够正常工作） 备份线路 ② 双机热备份技术 组成：是一种软硬件结合的较高容错应用方案。该方案是由两台服务器系统和一个外接共享磁盘阵列柜和相应的双机热备份软件组成 过程： 采用主、从系统之间相互按照一定的时间间隔发送通信信号保证主系统与备用系统的联系 模式： 双机热备模式（active/standby 方式）：active 服务器处于工作状态；而standby 服务器处于监控准备状态，服务器数据包括数据库数据同时往两台或多台服务器写入（通常各服务器采用 RAID 磁盘阵列卡），保证数据的即时同步。当 active 服务器出现故障时，通过软件诊测或手工方式将 standby 机器激活，保证应用在短时间内完全恢复正常使用 双机互备模式：两个相对独立的应用在两台机器同时运行，但彼此均设为备机，当某一台服务器出现故障时，另一台服务器可以在短时间内将故障服务器的应用接管过来，从而保证了应用的持续性，但对服务器的性能要求比较高 双机双工模式：集群的一种形式，两台服务器均处于活动状态，同时运行相同的应用，以保证整体系统的性能，也实现了负载均衡和互为备份，通常使用磁盘柜存储技术 ③ 服务器集群技术 定义： 指一组相互独立的服务器在网络中组合成为单一的系统工作，并以单一系统的模式加以管理 特点： 拥有一个共同的名称集群内任一系统上运行的服务可被所有的网络客户使用 功能： 协调管理各分离的构件出现的错误和故障，并可透明地向集群中加入构件 4.系统可靠性模型（1）时间模型： 一个软件中的故障数目在 t = 0 时是常数，随着故障被纠正，故障数目逐渐减少 （2）故障植入模型 一个面向错误数的数学模型，其目的是以程序的错误数作为衡量可靠性的标准 （3）数据模型： 在数据模型下，对于一个预先确定的输入环境，软件的可靠度定义为在 n 次连续运行中软件完成指定任务的概率 5.系统的可靠性分析和可靠度计算（1）组合模型 ① 需满足的条件： 系统只有两种状态：运行状态和失效状态系统可以划分成若干个不重叠的部件，每个部件也只有两种状态：运行状态和失效状态。部件的失效是独立的系统失效当且仅当系统中的剩余资源不满足系统运行的最低资源要求（系统的状态只依赖于部件的状态）时。已知每个部件的可靠性，可靠性指可用度或可靠度等概率参数 ② 基本思想 枚举所有系统状态计算每个系统状态的概率系统状态的概率是指系统处于该状态的概率把整个系统分解为简单的子系统，通过子系统的组合来计算整个系统的可靠性 ③ 系统类型： 串联系统并联系统串并联系统 （2）马尔柯夫模型 ① 核心概念 状态：在任何瞬间用以描述该系统所必须知道的一切状态转移：随着时间的流逝，因模块的失效和修复，系统发生的状态变化 基本思想： 给定状态的转移概率仅取决于当前的状态。系统从一个状态 i 转移到另一个状态 j 的转移率定义为单位时间内从状态 i 转移到状态 j 的概率 6.提高系统可靠性的措施（1）防止故障造成系统失效的两种技术 故障掩蔽技术：防止故障造成差错的各种技术系统重组技术：防止差错导致系统失效的各种技术 （2）硬件冗余 ① 常用技术： 三模冗余(TMR):三个相同的模块接收三个相同的输入，产生的三个结果送至多数表决器。表决器的输出取决于三个输入的多数，若有一个故障模块，则另两个正常模块的输出可将故障模块的输出掩蔽，从而不在表决器输出产生差错 （3）信息冗余： ① 定义 指通过在数据中附加冗余的信息以达到故障检测、故障掩蔽或容错的目的 ② 相关应用 海明校验码：是在 k个数据位之外加上 r 个校验位，从而形成一个 k+r 位的新的码字，使新的码字的码距比较均匀地拉大。把数据的每一个二进制位分配在几个不同的偶校验位的组合中，当某一位出错后，就会引起相关的几个校验位的值发生变化，不但可以发现出错，还能指出是哪一位出错，为进一步自动纠错提供了依据 循环冗余校验码（CRC）：在 K 位信息码后再添加 R 位的校验码，整个编码长度为 N 位，因此，这种编码又称(N,K)码。对于一个给定的(N,K)码，可以证明存在一个最高次幂为 N-K=R的多项式 G(x)。根据 G(x)可以生成 R 位的校验码，而 G(x)叫作这个 CRC 码的生成多项式 ③ 海明码生成步骤： 确定最小的校验位数 k，将它们记成 D1、D2、…、Dk，每个校验位符合不同的奇偶测试规定原有信息和 k 个校验位一起编成长为 m+k 位的新码字。选择 k 校验位（0 或 1）以满足必要的奇偶条件对所接收的信息作所需的 k 个奇偶检查如果所有的奇偶检查结果均正确，则认为信息无错误。 ④ CRC码生成步骤 将 x 的最高幂次为 R 的生成多项式 G(x)转换成对应的 R+1 位二进制数将信息码左移 R 位，相当于对应的信息多项式 C(x)×2R用生成多项式（二进制数）对信息码做模 2 除，得到 R 位的余数将余数拼到信息码左移后空出的位置，得到完整的 CRC 码。 7.备份与恢复（1）定义： 在系统其他地方创建数据与程序的电子复制，为重建系统中被破坏的或不正确的数据提供条件，备份最常用的技术是数据转储和建立日志文件 （2）数据转储： 静态转储：指在系统中无事务时进行的转储操作动态转储：指转储操作与用户事务并发进行，而且转储工作不会影响事务的运行，但它不能保证副本中的数据正确有效 （3）备份方式 脱机备份（冷备份）：是一种静态转储技术，备份系统所有的物理文件（控制文件、数据文件、重做日志和归档日志）和初始化文件联机备份（热备份）：是一种动态转储技术，由于只备份所需的文件，因而被看作是部分备份","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.yiyuclub.club/categories/学习笔记/"},{"name":"软考架构师","slug":"学习笔记/软考架构师","permalink":"http://www.yiyuclub.club/categories/学习笔记/软考架构师/"}],"tags":[{"name":"软考","slug":"软考","permalink":"http://www.yiyuclub.club/tags/软考/"},{"name":"架构师","slug":"架构师","permalink":"http://www.yiyuclub.club/tags/架构师/"}]},{"title":"redis知识汇总[初级]--数据类型（String）","slug":"redis知识汇总-初级-数据类型（String）","date":"2019-06-10T03:25:29.000Z","updated":"2019-06-24T09:13:28.050Z","comments":true,"path":"2019/06/10/redis知识汇总-初级-数据类型（String）/","link":"","permalink":"http://www.yiyuclub.club/2019/06/10/redis知识汇总-初级-数据类型（String）/","excerpt":"redis知识汇总[初级]–数据类型（String）","text":"redis知识汇总[初级]–数据类型（String） 1.append（1）命令：APPEND key value （2）介绍： ① key存在，value将会追加到原有值的后面② key不存在，将初始化设置该值（输入的设置） 127.0.0.1:6379&gt; append myname yiyu (integer) 4 127.0.0.1:6379&gt; get myname &quot;yiyu&quot; 127.0.0.1:6379&gt; append myname isman (integer) 9 127.0.0.1:6379&gt; get myname &quot;yiyuisman&quot; 2.bitcount（1）命令：BITCOUNT key [start] [end] （2）介绍： ① key存在，返回被设置为 1 的位的数量② key不存在，当做字符串处理，故为0③ -1 表示最后一个位，而 -2 表示倒数第二个位 //不存在 127.0.0.1:6379&gt; bitcount bcname (integer) 0 //存在 127.0.0.1:6379&gt; setbit sbname 20 1 (integer) 0 127.0.0.1:6379&gt; bitcount sbname (integer) 1 3.bitop（1）命令：BITOP operation destkey key [key …] （2）介绍： ① key存在，对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上② key不存在，默认字符串为0③ operation：AND（一个或多个逻辑并）、OR（一个或多个逻辑或）、NOT（此只能单个key，逻辑非）、XOR（一个或多个逻辑异或） //key不存在 127.0.0.1:6379&gt; BITOP AND and-result bit (integer) 0 //key存在 127.0.0.1:6379&gt; setbit topbit1 1 1 (integer) 0 127.0.0.1:6379&gt; setbit topbit2 3 1 (integer) 0 127.0.0.1:6379&gt; BITOP AND and-result topbit1 topbit2 (integer) 1 4.decr（1）命令：DECR key （2）介绍： ① key存在，改对应value减1② key不存在，value初始化0后减1③ value为不能加减的数，报错 //key不存在 127.0.0.1:6379&gt; decr decrcount2 (integer) -1 //key存在 127.0.0.1:6379&gt; set decrcount1 100 OK 127.0.0.1:6379&gt; decr decrcount1 (integer) 99 5.decrby（1）命令：DECRBY key decrement （2）介绍： ① key存在，改对应value减decrement② key不存在，value初始化0后减decrement③ value为不能加减的数，报错 //key不存在 127.0.0.1:6379&gt; decrby drcount 100 (integer) -100 //key存在 127.0.0.1:6379&gt; set drcount1 50 OK 127.0.0.1:6379&gt; decrby drcount1 2 (integer) 48 6.get（1）命令：GET key （2）介绍： ① key存在，返回对应value的值② key不存在，返回nil③ key非字符串，报错 //key不存在 127.0.0.1:6379&gt; get name1 (nil) //key存在 127.0.0.1:6379&gt; set gname yiyu OK 127.0.0.1:6379&gt; get gname &quot;yiyu&quot; 7.getbit（1）命令：GETBIT key offset （2）介绍： ① key存在，获取偏移量对应的value② key不存在，返回0（offset&gt;value 也会返回0） // key不存在返回0 127.0.0.1:6379&gt; getbit gbit 20190606 (integer) 0 //对存在的offset 获取 127.0.0.1:6379&gt; setbit sbit 20190606 1 (integer) 1 127.0.0.1:6379&gt; getbit sbit 20190606 (integer) 1 8.getrance（1）命令：GETRANGE key start end （2）介绍： key存在，返回该范围的字符串key不存在，返回””-1 表示最后一个字符， -2 表示倒数第二个 //已存在key 127.0.0.1:6379&gt; set rangename yiyu OK 127.0.0.1:6379&gt; get rangename &quot;yiyu&quot; //第一个字符为0开始 127.0.0.1:6379&gt; getrange rangename 1 2 &quot;iy&quot; //key不存在返回“” 127.0.0.1:6379&gt; getrange rangename1 1 2 &quot;&quot; 9.getset（1）命令：GETSET key value （2）介绍： key存在，设置新值，返回旧值（非字符串报错）key不存在，返回nil 127.0.0.1:6379&gt; getset gsname yiyu (nil) 127.0.0.1:6379&gt; getset gsname yiyuhahaha &quot;yiyu&quot; 11.incr（1）命令：INCR key （2）介绍: key存在：值增加1key不存在：初始化值0，在执行incr //对已存在key加一 127.0.0.1:6379&gt; set incrname1 20 OK 127.0.0.1:6379&gt; get incrname1 &quot;20&quot; 127.0.0.1:6379&gt; incr incrname1 (integer) 21 //对不存在key初始化0加一 127.0.0.1:6379&gt; incr incrname2 (integer) 1 12.incrby（1）命令：INCRBY key increment （2）介绍: key存在：值增加incrementkey不存在：初始化值0，在执行incr //对已存在的值加5 127.0.0.1:6379&gt; set incrbyname 10 OK 127.0.0.1:6379&gt; get incrbyname &quot;10&quot; 127.0.0.1:6379&gt; incrby incrbyname 5 (integer) 15 //对不存在的值初始化0加5 127.0.0.1:6379&gt; incrby incrbyname1 5 (integer) 5 13.incrbyfloat（1）命令：INCRBYFLOAT key increment （2）介绍: 与incrby同理，支持float数据 14.mget（1）命令：MGET key [key …] （2）介绍: key存在：返回valuekey不存在：不存在的key返回nil 127.0.0.1:6379&gt; msetnx mname1 1 mname2 2 (integer) 0 127.0.0.1:6379&gt; mget mname1 mname2 mname2 1) &quot;1&quot; 2) &quot;2&quot; 3) (nil) 15.msetnx（1）命令：MSETNX key value [key value …] （2）介绍: key存在：即使存在一个也会全部失败key不存在：设置多个key-value此操作为原子性操作 //key未存在 127.0.0.1:6379&gt; msetnx mname1 1 mname2 2 mname3 3 (integer) 1 127.0.0.1:6379&gt; mget mname1 mname2 mname3 1) “1” 2) “2” 3) “3” //存在个别key（存不进会失败但不会影响已存在的值） 127.0.0.1:6379&gt; msetnx mname4 4 mname1 1 (integer) 0 127.0.0.1:6379&gt; mget mname4 mname1 1) (nil) 2) “1” 16.psetex(1) 命令：PSETEX key milliseconds value （2）介绍： 与setex类似，只是时间换成毫秒 17.set（1）命令：SET key value [EX seconds] [PX milliseconds] [NX|XX] （2）介绍: key存在：value覆盖原值key不存在：关联key与valueEX seconds：key过期时间，单位秒PX millisecond：key过期时间，单位毫秒NX：等同命令SETNX key value（可以不存在时起作用）XX：与上同理 //设值 127.0.0.1:6379&gt; set myname yiyu OK 127.0.0.1:6379&gt; get myname &quot;yiyu&quot; //覆盖原值 127.0.0.1:6379&gt; set myname goodman OK 127.0.0.1:6379&gt; get myname &quot;goodman&quot; //设值时间 127.0.0.1:6379&gt; set myname yiyu EX 20 OK 127.0.0.1:6379&gt; GET myname &quot;yiyu&quot; //20s后 127.0.0.1:6379&gt; get myname (nil) 18.setbit（1）命令：SETBIT key offset value （2）介绍： ① key存在，设值偏移量的值② key不存在，生成新的字符串③ offset：偏移量，大于或等于0，小于2^32 //可用来记录当日是否登陆 127.0.0.1:6379&gt; setbit sbit 20190606 1 (integer) 0 127.0.0.1:6379&gt; getbit sbit 20190606 (integer) 1 19.setex（1）命令：SETEX key seconds value （2）介绍： 原子性操作key存在，value覆盖旧值key不存在，设置该值seconds ：设值key过期时间，单位秒 127.0.0.1:6379&gt; setex exname 20 yiyu OK 127.0.0.1:6379&gt; get exname &quot;yiyu&quot; //已过期 127.0.0.1:6379&gt; get exname (nil) 20.setnx（1）命令：SETNX key value （2）介绍： key存在，不做任何操作key不存在，设置该值 //设值（key不存在） 127.0.0.1:6379&gt; setnx nxname yiyu (integer) 1 127.0.0.1:6379&gt; get nxname &quot;yiyu&quot; //设置值（key存在） 127.0.0.1:6379&gt; setnx nxname hahaha (integer) 0 127.0.0.1:6379&gt; get nxname &quot;yiyu&quot; 21.setrance（1）命令：SETRANGE key offset value （2）介绍： key存在，从偏移量开始的位置设值key不存在，当做空白字符串处理设值 //对已存在的key设值 127.0.0.1:6379&gt; set rname yiyuhahaha OK 127.0.0.1:6379&gt; setrange rname 5 lalala (integer) 11 127.0.0.1:6379&gt; get rname &quot;yiyuhlalala&quot; //对未存在的key设值 127.0.0.1:6379&gt; setrange empty_name 2 &quot;yiyu&quot; (integer) 6 // 该偏移前的位置被空格替代 127.0.0.1:6379&gt; get empty_name &quot;\\x00\\x00yiyu&quot; 22.strlen（1）命令：strlen key （2）介绍: key存在：返回对应value的长度（value不是字符串返回错误）key不存在：返回0 127.0.0.1:6379&gt; strlen myname (integer) 9 127.0.0.1:6379&gt; strlen myname1 (integer) 0 127.0.0.1:6379&gt;","categories":[{"name":"框架","slug":"框架","permalink":"http://www.yiyuclub.club/categories/框架/"},{"name":"redis","slug":"框架/redis","permalink":"http://www.yiyuclub.club/categories/框架/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://www.yiyuclub.club/tags/redis/"},{"name":"框架","slug":"框架","permalink":"http://www.yiyuclub.club/tags/框架/"}]},{"title":"（软考架构师笔记十六）安全性和保密性设计","slug":"（软考架构师笔记十六）安全性和保密性设计","date":"2019-06-10T02:21:18.000Z","updated":"2019-06-24T09:13:28.066Z","comments":true,"path":"2019/06/10/（软考架构师笔记十六）安全性和保密性设计/","link":"","permalink":"http://www.yiyuclub.club/2019/06/10/（软考架构师笔记十六）安全性和保密性设计/","excerpt":"（软考架构师笔记十六）安全性和保密性设计","text":"（软考架构师笔记十六）安全性和保密性设计 1.安全性和保密性设计（1）信息安全 保证信息的保密性、完整性、真实性、占有性 （2）保密性 系统中的信息必须按照该信息拥有者的要求保证一定的秘密性，不会被未经许可的第三方非法获取 （3）完整性 系统中的信息应当安全、准确、有效，要求数据不能被非法改动或删除（数字签名、加密） （4）真实性 对信息的发送者身份的确认或系统中有关主体的身份确认，这样可以保证信息的可信度（数字签名，公钥加密） （5）占有性 保护信息赖以存储的节点、介质、载体等不被盗用或窃取（使用版权、专利、商业秘密性，提供物理的或逻辑的存取限制方法，维护和检查有关窃取文件的记录） 2.加密和解密（1）定义： 明文：信息的发送方准备好要发送信息的原始形式密文：对明文经过一系列变换后形成信息的另一种不能直接体现明文含义的形式加密：由明文转换为密文的过程加密算法：加密时所采用的一组规则或方法解密：再把密文还原成明文，以获得信息的具体内容解密算法：运用一系列与加密算法相对应的方法或规则密钥：加密、解密过程中，由通信双方掌握的参数信息控制具体的加密和解密过程 （2）对称密钥加密算法 ① 定义： 加密密钥与解密密钥相同，或者从一个很容易计算出另一个 ② 加密算法： DES(对称加密算法): 把要加密的明文分成 64 位的数据段作为输入，再使用根据 64 位密钥变化生成的 52 个子密钥，对输入的数据段依次进行初始置换、16 轮迭代、逆初始置换，然后得到 64 位密文 IDEA（国际数据加密算法）： 以 64 位为单位的，在加密前把要加密的明文按每 64 位作为一个数据段进行分割然后分别加密 还有Skipjack、3DES、GDES、 NewDES、Lucifer、FEAL N、LOKI 91、RC4、RC5 （3）非对称加密算法（双钥加密方法）： ① 定义： 加密和解密的密钥并不相同，或者从一个很难计算出另外一个 ② 问题： 密钥的生成、导入、存储、管理、分发等过程比较复杂 ③ 私钥： 在运算中，先产生一对密钥，其中之一是保密密钥，由用户自己保存，不能向外界泄漏 ④ 公钥： 可对外公开，甚至可在公共目录中列示 只有使用私钥才能解密用公钥加密的数据，同时使用私钥加密的数据只能用公钥解密 ⑤ 算法： RSA： 首先把需要加密的明文按比特位分成等长的数据段，使得每个数据段对应的十进制数小于 N，即数据段的长度小于 log2N。然后依次对每个明文数据段 m 做加密运算可以得到密文 c∶c = me mod N。相应的，解密时对密文数据段做解密运算就可以得到明文 m∶m = ce mod N 还有背包密码、McEliece、Diffe Hellman、Rabin、Ong Fiat Shamir、零知识证明的算法、椭圆曲线、EIGamal 等 3. 数字签名与数字水印（1）散列函数 报文：散列函数运算的输入信息消息摘要（散列码）：散列函数运算后所得到的结果 其特点： 不同内容的报文具有不同的散列码，而一旦原始报文有任何改变，哪怕改变一位信息，则通过散列函数计算后得到的散列码也将完全不同散列函数是单向的，即求解某一个报文的散列码非常容易，但是根据散列码来倒推原始报文是非常困难的对于任何一个报文，无法预知它的散列码散列码具有固定的长度，不管原始报文的长度如何，通过散列函数运算后的散列码都具有一样的长度 算法：MD5、SHA、HMAC （2）数字签名 ① 组成：签名算法和验证算法（签名算法和验证算法。通过使用签名算法签名一个消息，所得到的签名能够通过一个验证算法来验证签名的真实性和有效性）;通过数字签名可以有效地保证数据的完整性，防止第三方伪造或发送方的抵赖 ② 过程： 信息的发送方对信息利用自己的私钥进行签名，接着发送方把这个签名和信息一起发送给接收方。接收方收到信息后利用发送方的公钥来对其中的数字签名进行验证，确认其合法性 ③ 算法： RSA 结合 MD5 数字签名： 信息的发送方通过对信息进行散列运算生成一个消息摘要，接着发送方用自己的私钥对这个消息摘要进行加密，就形成发送方的数字签名。然后，把这个数字签名作为信息的附件和信息一起发送给信息的接收方。接收方收到信息后，首先对收到的信息进行与发送者相同的散列运算得到一个消息摘要，接着再用发送方的公钥来对信息中附加的数字签名进行解密得到发送方计算出的散列码。如果两个散列码相同，那么接收方就能确认该信息和数字签名是由发送方发出的 数字签名标准（DSS）： 收方在收到消息摘要和签名后将其作为验证函数的输入。验证函数还依赖于全局公钥和与发送方的私钥相匹配的公钥 PK，这样只有发送方用其自己的私钥才能产生有效的签名 还有EI Gamal、Fiat-Shamir、Guillon-Oucsquerrter、igital SignatureAlgorithm，数字签名算法）、椭圆曲线 （3）数字信封 ① 定义： 用加密技术来保证只有规定的特定收信人才能阅读通信的内容 ② 过程： 信息发送方采用对称密钥来加密信息内容，然后将此对称密钥用接收方的公开密钥来加密（这部分称数字信封），之后，将它和加密后的信息一起发送给接收方，接收方先用相应的私有密钥打开数字信封，得到对称密钥，然后使用对称密钥解开加密信息 4.数字证书与密钥管理（1）密钥分配中心（KDC）： 每一个用户都只保存自己的私钥 SK 和 KDC 的公钥 PKKDC，而在通信时再经由 KDC 获得其他用户的公钥 PK 或者仅仅在某一次通信中可以使用的对称密钥加密算法的临时密钥 K （2）数字证书和公开密钥基础设施 ① 数字证书： 定义： 利用一对互相匹配的密钥进行加密、解密。每个用户自己保存私钥，用它进行解密和签名；同时设定一个公钥，并由本人公开，为一组用户所共享，用于加密和验证签名 内容： 唯一标识证书所有者的名称唯一标识证书签发者的名称证书所有者的公开密钥证书签发者的数字签名证书的有效期证书的序列号 ② 公开密钥基础设施（PKI） 定义： 由数字证书、证书颁发机构（Certificate Authority，CA），以及对电子交易、通信等所涉及的各方的合法性进行检查和验证的其他注册机构组成的一套系统 目标：向广大的信息系统用户和应用程序提供公开密钥的管理服务 有效期控制机制： 数字证书的有效期证书撤销列表（Certificate Revocation List，CRL） 结构模型： 管理实体：PKI 服务的提供者端实体：PKI 服务的使用者证书库：一个分布式数据库，用于证书和 CRL 的存放和检索 CA： 是 PKI 框架中唯一能够发布和撤销证书的实体，维护证书的生命周期 RA（注册机构）： 负责处理用户请求，在验证了请求的有效性后，代替用户向 CA 提交 PKI 层次模型： 传输层：向上提供 PKI 报文的可靠传输，它可以是传输层协议或应用层协议密码服务层：向上提供加密、解密、数字签名、消息摘要等基本密码学服务，可由 RSA、MD5 等方法实现证书服务层：使用前面两层提供的加密和传输服务，向用户提供证书的请求、签发、发布、撤销和更新等服务 ③ 公钥加密体制：解决对称密钥加密体制中的密钥分配难以保密的问题而提出的 （3）X.509证书特点： 支持多种算法支持多种命名机制可以限制证书（公开密钥）的用途定义证书遵循的策略控制信任关系的传递 （4）X.509v3证书特点： 版本号序列号签名算法识别符发行者名称有效期主体名称主体的公开密钥信息发行者唯一识别符主体唯一标识符扩充域签名 4.安全协议（1）IPSec协议 ① 之前问题：在 TCP/IP 协议中，对 IP 数据包没有提供任何安全保护，攻击者可以通过网络嗅探、IP欺骗、连接截获等方法来攻击正常的 TCP/IP 通信 ② 定义： 该协议把密码技术应用在网络层，以向信息的发送方和接收方提供源地址验证、数据传输的完整性、存取控制、保密性等安全服务，保护通信免遭窃听、抵御网络攻击，而且更高层的应用层协议也可以直接或间接地使用这些安全服务，为其上层协议如TCP、UDP 等提供透明的安全保护服务，在 Internet 这样不安全的网络中为通信提供安全保证 ③ 原理： 发送方在发送数据前对数据实施加密，然后把密文数据发送到网络中去，开始传输。在整个传输过程中，数据都是以密文方式传输的，直到数据到达目的节点，才由接收方对密文进行解密，提取明文信息 ④ 安全关联（SA） 指提供通信安全服务的发送方和接收方之间的一种单向关系是构成 IPSec 的基础，它是进行通信的双方经协商建立起来的一种协定定义了两个 IPSec 系统之间的安全通信特征，并决定在该通信中为数据包提供的安全服务 ⑤ 安全策略（AH） 先将数据进行校验和加密，然后封装为 IP 包，从而实现无连接通信的数据完整性、数据源认证和防止重放攻击 ⑥ ESP 通过对数据包的数据进行加密来提供传输信息的保密性，从而实现了数据完整性、数据源认证、数据保密性的安全服务 ⑦ IP密钥交换（IKE） 它使用了 Internet 安全关联和密钥管理协议（Internet SecurityAssociation and Key Management Protocol，ISAKMP）、密钥确定协议 Oakley 和描述支持匿名和快速密钥刷新的密钥交换的 SKEME 协议 ⑧ IPSec 的工作模式 传输模式：首先将要传送的数据使用 IPSec 加密封装起来，再把相关的 IPSec 头插入 IP头和被保护的数据之间封装起来，然后从 IPSec 头读取 SPI 值得到相对的 SA，再利用 SA 所定的解密参数解出所加密的数据（通信和处理效率较高） 隧道模式：首先使用 SA 的相关信息将 IP 的数据包全部加密，接下来在前面加上 ESPHeader，然后把它们作为数据为它们再加上一个新的 IP 头。接收端收到 ESP 封包后，使用 ESP Header 内容中的 SPI 值提供的 SA，然后解出 ESP Header 后的装载数据，就可以取回原始的 IP 头与封包（安全性较高） （2）SSL ① 定义：用于安全传输数据的一种通信协议；采用公钥加密技术、对称密钥加密技术等保护两个应用之间的信息传输的机密性和完整性 ② 问题：不能保证传输信息的不可否认性 ③ 基本安全性： 通道是保密的，经过握手确定密钥之后，所有的消息被加密通道是被认证的，通信中的服务器端总是被认证，客户端可选认证通道是可靠的，用 MAC 对传送的消息进行完整性检查，保证通道上数据的完整性 ④ 组成： SSL 记录协议SSL 握手协议SSL 密码变更说明协议SSL 警告协议 （3）PGP 协议 ① 定义： 一套电子邮件加密方案用来对邮件加密以防止非授权者阅读，还能对邮件加上数字签名而使收信人可以确认邮件确实是由发送方发出的采用 IDEA 算法、对于加密信息采用 RSA 公钥加密算法，还采用了用于数字签名的消息摘要算法，加密前进行压缩处理等技术手段进行邮件加密的一套软件 ② 原理 ③ 密钥管理机制 5.计算机病毒与防治（1）定义： 指编制或者在计算机程序中插入的破坏计算机功能或者毁坏数据，影响计算机使用，并能自我复制的一组计算机指令或者程序代码 （2）周期： 潜伏阶段传染阶段触发阶段发作阶段 （3）特征： 传染性：病毒具有把自身复制到其他系统或文件等宿主中去的能力非授权性：病毒程序的执行不需要得到用户的同意潜伏性：病毒潜伏在系统中而不被人们所发觉破坏性：病毒在一定条件下可以自动触发，并对计算机实施破坏 （4）类别 根据系统：攻击 DOS 系统的病毒、攻击 Windows 系统的病毒、攻击Unix/Linux 系统的病毒、攻击 OS/2 系统的病毒、攻击 Macintosh 系统的病毒、攻击手机的病毒、其他操作系统上的病毒 根据连接方式：源码型病毒、嵌入型病毒、Shell 病毒、宏病毒、脚本型病毒、操作系统型病毒 根据破坏情况：良性病毒和恶性病毒 根据传播媒介：单机病毒和网络病毒 （5）组成： 传染模块：负责把计算机病毒从一个系统或文件传播到更多的系统或文件中去触发模块：检查预定触发条件是否满足破坏模块：负责实施病毒的破坏动作主控模块：控制病毒程序的运行 （6）网络环境下的病毒发展新趋势 E-mail 病毒即时通信：MSN、QQ、OICQ局域网共享传播木马程序 （7）计算机病毒的检测与清除 特征码检测校验和检测行为监测启发式扫描虚拟机病毒的清除 （8）计算机病毒的预防 一定要在计算机中安装反病毒软件不要轻易使用来历不明的或者没有经过确认的软件电子邮件的附件应该先检查病毒后再开启，并在发送邮件之前检查病毒定期使用反病毒软件扫描系统确保所使用的反病毒软件的扫描引擎和病毒代码库为最新的系统安装完成后立即制作系统应急启动盘定期进行备份利用安全扫描工具定时扫描系统和主机使用反病毒软件时，最好先查毒，找到了带毒文件后，再确定是否进行杀毒操作建立本单位的计算机病毒防治管理制度 6.身份认证与访问控制 （1）身份认证技术 ① 定义：对系统的用户进行有效性、真实性验证 ② 方式： 口令认证方式基于公钥签名的认证方式持卡认证方式基于人体生物特征的认证方式动态口令技术PPP 中的认证协议：还有PAP 和 CHAP，此外还有 EAPRADIUS 协议 （2）访问控制技术 ① 定义： 在身份认证的基础上，根据不同身份的用户对用户的访问请求加以限制主体：发出访问、存取请求的一方客体：被访问的对象和资源访问规则：一套定义主体与客体之间相互关系，确定不同主体对不同客体的访问能力与权限的规则 ② 访问控制策略 自主访问控制（DAC）：一个拥有一定权限范围的主体可以直接或者间接地把权限授予其他的主体强制访问控制（MAC）：系统统一采用某种访问权限的授予和撤销的策略，而且强制所有主体都必须服从这种访问权限的分配 基于角色的访问控制（RBAC）：克服以上两者的缺点的同时，提供一个良好的安全的系统环境 ③ 访问许可的授权对访问许可的授权有三种类型： 等级型：把对客体的存取控制权限的修改能力划分成不同的等级，拥有高级别修改能力的主体可以把这种权限分配给比其级别低的主体 拥有型：拥有者具有对所拥有的客体的全部的控制权，并且可以任意修改其拥有的客体的访问控制表，并可对其他主体授予或撤销对其客体的任何一种访问权限。但是拥有者无权将其对客体的访问控制权的分配权授予其他主体 自由型：一个客体的拥有者可以对任何主体授予对他所拥有的客体的访问权限，同时还可以把这种分配权授予其他主体而不受任何限制 ④ 内容： 用户标识与认证逻辑访问控制审计与跟踪公共访问控制 7.网络安全体系（1）OSI架构： 是一个面向对象的、多层次的结构，它认为安全的网络应用是由安全的服务实现的，而安全服务又是由安全机制来实现的 （2）OSI安全服务： 对象认证服务访问控制服务数据保密性服务数据完整性服务禁止否认服务 （3）OSI 安全机制 加密机制数字签名机制访问控制机制数据完整性机制鉴别交换机制流量填充机制路由验证机制公正机制 （4）OSI 安全服务与安全机制之间的关系 不是一一对应的关系 （5）VPN在网络安全中的应用 ① 定义： 利用不安全的公共网络如 Internet 等作为传输媒介，通过一系列的安全技术处理，实现类似专用网络的安全性能，保证重要信息的安全传输的一种网络技术 ② 优点： 网络通信安全方便的扩充性方便的管理节约成本显著 ③ VPN的原理： 安全技术： 安全隧道技术用户认证技术访问控制技术 VPN用户代理: 安全隧道终端功能用户认证功能访问控制功能 8.系统的安全性设计（1）物理安全问题与设计 物理设备本身是否安全可靠设备的位置与环境的安全限制物理访问地域因素 （2）防火墙及其在系统安全中的应用 过滤状态检测应用网关 优点： 可以隔离网络，限制安全问题的扩散简化网络安全管理的复杂度能够有效地记录 Internet 上的活动 （3）入侵检测系统 ① 定义： 通过对计算机网络或计算机系统中的若干关键点收集信息并对其进行分析，从中发现网络或系统中是否有违反安全策略的行为和被攻击的迹象 ② 功能： 通过检测和记录系统中的安全违规行为，惩罚信息系统攻击，防止入侵事件的发生检测其他安全措施未能阻止的攻击或安全违规行为检测黑客在攻击前的探测行为，预先给管理员发出警报；报告信息系统中存在的安全威胁提供有关攻击的信息，帮助管理员诊断系统中存在的安全弱点，利于其进行修补 ③ 周期： 数据采集阶段数据处理及过滤阶段入侵分析及检测阶段报告及响应阶段 ④ 类型： 主机型网络型 9.安全性规章（1）安全管理制度 机房安全管理制度系统运行管理制度，包括系统启动、关闭、系统状态监控、系统维护等人员管理制度，包括管理人员、设计人员、操作人员、人事变更等软件管理制度数据管理制度密码口令管理制度病毒防治管理制度用户登记和信息管理制度工作记录制度数据备份制度审计制度安全培训制度 （2）计算机犯罪与相关法规 ① 计算机犯罪 定义： 指针对和利用计算机系统，通过非法操作或者以其他手段，对计算机系统的完整性或正常运行造成危害的行为 犯罪对象：计算机系统或其中的数据（计算机设备、系统程序、文本资料、运算数据、图形表格） 特点： 呈现国际化趋势向全社会各单位和个人蔓延由个人犯罪向群体犯罪、组织犯罪发展；由单一目的犯罪向综合性犯罪发展涉及人员范围越来越广泛，并呈现低龄化趋势从危害程度看，后果越来越严重通过网络窃取机密信息将成为间谍活动的主要形式之一 我国的相关法律、法规: 直接以计算机信息系统为犯罪对象的犯罪以计算机为犯罪工具实施其他犯罪","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.yiyuclub.club/categories/学习笔记/"},{"name":"软考架构师","slug":"学习笔记/软考架构师","permalink":"http://www.yiyuclub.club/categories/学习笔记/软考架构师/"}],"tags":[{"name":"软考","slug":"软考","permalink":"http://www.yiyuclub.club/tags/软考/"},{"name":"架构师","slug":"架构师","permalink":"http://www.yiyuclub.club/tags/架构师/"}]},{"title":"（软考架构师笔记十五）基于中间件的开发","slug":"（软考架构师笔记十五）基于中间件的开发","date":"2019-06-06T00:09:53.000Z","updated":"2019-06-24T09:13:28.066Z","comments":true,"path":"2019/06/06/（软考架构师笔记十五）基于中间件的开发/","link":"","permalink":"http://www.yiyuclub.club/2019/06/06/（软考架构师笔记十五）基于中间件的开发/","excerpt":"（软考架构师笔记十五）基于中间件的开发","text":"（软考架构师笔记十五）基于中间件的开发 1.中间件（1）定义 中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源，中间件位于客户机服务器的操作系统之上，管理计算资源和网络通信。 （2）特点 满足大量应用的需要运行于多种硬件和 OS 平台支持分布计算，提供跨网络、硬件和 OS 平台的透明性的应用或服务的交互支持标准的协议支持标准的接口 （3）十大优越性 缩短应用的开发周期节约应用的开发成本减少系统初期的建设成本降低应用开发的失败率保护已有的投资简化应用集成减少维护费用提高应用的开发质量保证技术进步的连续性增强应用的生命力。 （4）类别 通信处理（消息）中间件：BEA的eLink、IBM的MQSeries、TongLINK事务处理（交易）中间件：BEA的Tuxedo.数据存取管理中间件：为在网络上虚拟缓冲存取、格式转换、解压等带来方便Web服务器中间件安全中间件跨平台和架构的中间件专用平台中间件网络中间件 （5）主流产品 IBM MQSeries：IBM的消息处理中间件，供一个具有工业标准、安全、可靠的消息传输系统 BEA Tuxedo：是BEA电子商务交易平台，属于交易中间件，允许客户机和服务器参与一个涉及多个数据库协调更新的交易，并能够确保数据的完整性 2.应用服务器（1）定义： 企业：能将一个企业的商务活动安全有效地实施到 Internet上，实现电子商务分布式：是一个开发、部署、运行和管理、维护的平台集群：让多个不同的、异构服务器协同工作、相互备份，以满足企业级应用所需要的可用性、高性能、可靠性和可伸缩性 （2）作用： 更合理地分工企业级应用开发，加快应用的开发速度，减少应用的开发量应用设计、开发、部署、运行、管理、维护的平台使得应用与底层平台无关，便于商业逻辑的实现与扩展为企业应用提供现成的、稳定而强健的、灵活的、成熟的基础架构 （3）主流产品 BEA WebLogic：Java Web 应用服务器 IBM WebSphere：强调其在应用开发（WebSphere Studio 和 VisualAge for Java）、数据库（DB2）和消息服务（MQseries）的集成性 SUN iPlanet：事务监控器、多负载平衡选项、对集群和故障转移全面的支持、集成的 XML 解析器和可扩展格式底稿语言转换（XLST）引擎，以及对国际化的全面支持 Oracle Internet ApplicationServer ：为Apache 开发了插件盒模块来处理 Java 应用程序、Perl 程序、PL/SQL 程序及 SSL 上的安全网页 Sybase Enterprise ApplicationServer：将 Sybase 的 JaguarCTS 和PowerDynamo 紧密集成并加以发展，是同时实现 Web 联机事务处理（WebOLTP）和动态信息发布的企业级应用服务器平台 3.J2EE（1）定义 针对 Web Service、业务对象、数据访问和消息报传送的一组规范建立标准，使 Web 应用的部署与服务器无关使服务器能控制构件的生命周期和其他资源，以便能够处理扩展、并发、事务处理管理和安全性问题 （2）构件 应用客户端构件EJB构件ServletsJSPApplet构件 （3）表示层用来展示用户交互界面 客户端为HTML：JSP/Servlet 组合将成为能实现业务目标的真正客户端客户端为Jav 程序或基于COM程序时：它可以直接访问业务逻辑 （4）应用服务层 Servlet：客户端请求servlet，servlet响应客户端，使用了java类和流，每个请求为新的线线程JSP：Servlet和html的结合，和处理javabean类EJB：封装业务处理，公国本地接口和远程接口访问EJB方法 EJB： EntityBean（实体 Bean）：数据库中的数据及作用于数据的方法Session Bean（会话 Bean）：代表与客户间的短暂对话Message：点到点（基于消息队列），主题发布与订阅（基于主题）Driven Bean（消息驱动 Bean）：处理从 JMS 消息队列接收到的异步消息JNDI（Java 命名和目录接口）：查找用户定义对象和环境实体事务处理：J2EE 事务处理 API（JTA）和 Java 事务处理服务（JTS） 4. .NET（1）定义：代表了一个集合、一个环境、一个可以作为平台支持下一代 Internet 的可编程结构 （2）目的：让用户在任何地方、任何时间，以及利用任何设备都能访问他们所需要的信息、文件和程序 （3）特点： 软件变服务：制造服务，而不是制造软件基于XML的共同语言：通过 XML 语言定义了简单对象访问协议、Web服务描述语言、Web服务发现协议融合多种设备和平台：谋求与各种Internet接入设备和平台的一体化新一代的人机界面：智能与互动 （4）.NET框架 ① 定义： 提供了全新的数据库访问技术 ADO.NET，以及网络应用开发技术 ASP.NET 和 Windows 编程技术 WinForms;提供了 VB、VC++、C#等多种语言支持;全面支持.NET 的开发工具 ② 通用语言运行（CLR）： 运行时则为多种语言提供了一种统一的运行环境,还提供了更多的功能和特性 ③ 基础类库 包括了从输入输出到数据访问等各方面，提供了一个统一的面向对象的、层次化的、可扩展的编程接口 ④ ADO.NET 提供了一组用来连接到数据库、运行命令、返回记录集的类库 ⑤ ASP.NET Web 表单：使开发者能够非常容易地创建 Web表单ASP.NET Web 服务：可命名的网络资源，可用来在Internet范围内方便表现和使用对象ASP.NET 应用框架 ⑥ WinForms：软件控件 ⑦ 开发语言：VB，C++，C#和 Jscript ⑧ 其他特征 安全系统配置系统 可大幅度减小DLL地狱伤害 5.企业应用集成（EAI）（1）定义： 通过将业务流程，应用软件、硬件和各种标准联合起来，对企业中完成不同业务功能的应用系统进行无缝集成，使它们像一个整体一样进行业务处理和信息共享，从而提高企业效率，为客户提供灵活的业务服务 （2）中间件的影响 间件产品对各种硬件平台、操作系统、网络数据库产品及客户端实现了兼容和开放中间件保持了平台的透明性，使开发者不必考虑操作系统的问题中间件实现了对交易的一致性和完整性的保护，提高了系统的可靠性间件产品可以缩短开发周期 50%～75%，从而大大地降低了开发成本，提高了工作效率 （3）应用集成： 通过处理多个应用系统之间的消息交换，实现系统间的集成,基于客户（请求程序）和服务器（响应程序）之间的请求响应交互机制 （4）业务过程集成 交互式流程：包含了跨两个系统之间的事务处理多步流程：根据事先定义的顺序在两个或者多个系统之间流转 （5）数据集成 首先解决数据和数据库的集成问题（将历史数据批量导入新系统中和现行系统中的批量、实时数据处理，也称数据同步）；采用批量的方式来处理；还需对对数据进行标识并编成目录，另外还要确定元数据模型 5.轻量级架构和重量级（1）Struts框架 JSPview 发起一个以.do 表示的请求；ActionForm 封装用户请求数据，同时提供验证数据的功能；ActionServlet 根据 struts-config.xml 文件来得到处理这个请求的 Action 对象，并将请求发送给这个 Action 对象；Action 对象调用 model 去处理这个请求，将结果返回给 ActionServlet；ActionServlet 决定将结果返回给对应的 view；view 得到结果，并将它显示给用户 （2）Spring框架 ① 定义： 包括声明性事务管理，通过 RMI 或 web services 远程访问业务逻辑，mail 支持工具，以及对于数据和数据库之间持久层的各种配置的支持核心本身是个容器,管理物件的生命周期、物件的组态、相依注入等，并可以控制物件在创建时是以原型（Pro-totype）或单例子（Singleton）的方式来创立采用控制反转（别名注入依赖），Spring 核心容器会自动根据构件将依赖注入指定的物件 ② 七模块 Core：主要构件是 BeanFactory，提供对 Factory 模式的经典实现来消除对程序性单例模式的需要，并真正地允许从程序逻辑中分离出依赖关系和配置 DAO：提供了 JDBC 的抽象层，它可消除冗长的 JDBC 编码和解析数据库厂商特有的错误代码，还提供了一种比编程性更好的声明性事务管理方法ORM：提供了对象关系映射工具Context（上下文）：Spring 的上下文服务配置Web：提供了基础的针对 Web 开发的集成特性MVC：控制层，连接事务与界面的通道AOP：面向切面技术 （3）Hibernate框架 ① 定义： 是一种对象和关系之间映射的框架，是 Java 应用和关系数据库之间的桥梁。它可以将数据库资源映射为一个或者多个 POJO ② 内容： 对象/关系映射机制的核心是一个 XML 文件(*.hbm.xml)：描述了数据库模式是怎么与一组 Java 类绑定在一起 （4）基于Struts、Spring和Hibernate的轻量级框架 ① 表示层：Struts负责 管理用户请求和响应提供一个控制器代理以调用业务逻辑和各层的处理处理从其他层抛给 StrutsAction 的异常为显示提供数据模型借助 Struts Validator 框架帮助完成 Web 层的验证工作 ② 持久层：Hibernate负责 通过一个面向对象的查询语言（HQL）或正则表达式的 API 来检索对象的相关信息(增删查改) ③ 业务层：spring负责 用延时注入思想组装代码，提高了系统扩展性和灵活性，实现插件式编程。利用 AOP 思想，集中处理业务逻辑，减少重复代码，构建了较理想的解决方案","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.yiyuclub.club/categories/学习笔记/"},{"name":"软考架构师","slug":"学习笔记/软考架构师","permalink":"http://www.yiyuclub.club/categories/学习笔记/软考架构师/"}],"tags":[{"name":"软考","slug":"软考","permalink":"http://www.yiyuclub.club/tags/软考/"},{"name":"架构师","slug":"架构师","permalink":"http://www.yiyuclub.club/tags/架构师/"}]},{"title":"redis知识汇总[初级]--安装","slug":"redis知识汇总[初级]--安装","date":"2019-06-05T09:23:02.000Z","updated":"2019-06-24T09:13:28.050Z","comments":true,"path":"2019/06/05/redis知识汇总[初级]--安装/","link":"","permalink":"http://www.yiyuclub.club/2019/06/05/redis知识汇总[初级]--安装/","excerpt":"redis知识汇总[初级]–安装","text":"redis知识汇总[初级]–安装 redis介绍 高性能key-value数据库提供list，set，zset，hash等数据结构的存储提供主从数据备份模式 官网：https://redis.io/中文网：http://www.redis.cn/Github：https://github.com/microsoftarchive/redis redis安装1.从官网下载压缩包（这里为windows）解压 2.打开cmd（分为服务端与客户端），分别启动 ① 服务端（进入根目录，输入redis-server redis.windows.conf）： ② 客户端（redis-cli.exe -h 127.0.0.1 -p 6379）-(默认端口6379)： ③ 如图即成功 redis基本设置1.服务：redis-server –service-install redis.windows.conf –loglevel verbose 2.卸载：redis-server –service-uninstall 3.启动：redis-server –service-start 4.停止：redis-server –service-stop 5.修改名称端口：① redis-server –service-install –service-name [updateName] –port [port]② redis-server –service-start –service-name [uodateName] redis高级配置1.日志级别： debugverbose(默认)noticewarning 待续","categories":[{"name":"框架","slug":"框架","permalink":"http://www.yiyuclub.club/categories/框架/"},{"name":"redis","slug":"框架/redis","permalink":"http://www.yiyuclub.club/categories/框架/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://www.yiyuclub.club/tags/redis/"},{"name":"框架","slug":"框架","permalink":"http://www.yiyuclub.club/tags/框架/"}]},{"title":"（软考架构师笔记十四）信息系统基础知识","slug":"（软考架构师笔记十四）信息系统基础知识","date":"2019-06-05T07:04:15.000Z","updated":"2019-06-24T09:13:28.066Z","comments":true,"path":"2019/06/05/（软考架构师笔记十四）信息系统基础知识/","link":"","permalink":"http://www.yiyuclub.club/2019/06/05/（软考架构师笔记十四）信息系统基础知识/","excerpt":"（软考架构师笔记十四）信息系统基础知识","text":"（软考架构师笔记十四）信息系统基础知识 1.概念（1）定义： 泛指收集、存储、处理和传播各种信息的具有完整功能的集合体。在这里，信息系统并没有强调收集、存储、处理和传播信息所用的工具 （2）三要素：系统的观点、数学的方法和计算机应用 2.信息系统组成（1）数据环境： 数据文件:没有使用数据库管理系统，根据大多数的应用需要，由系统分析师和程序员分散地设计各种数据文件应用数据库:使用了数据库，但共享程度低主题数据库：经过严格的数据分析，建立应用模型，虽然设计开发需要花费较长的时间，但其后的维护费用很低信息检索系统：数据库经过组织能保证信息检索和快速查询的需要，而不是大量的事务管理 （2）应用层次 战略级信息系统：有者和使用者都是企业的最高管理层战术级信息系统：使用者一般是企业的中层经理及其管理的部门操作级信息系统：使用者一般是服务型企业的业务部门事务级信息系统：使用者一般是企业的管理业务人员 （3）生命周期 ① 产生阶段：概念的产生过程、需求分析过程 ② 开发阶段信息：总体规划、系统分析、系统设计、系统实施和系统验收阶段 ③ 运行阶段：排错性维护、适应性维护、完善性维护和预防性维护 ④ 消亡阶段 （4）建设原则 ① 高层管理人员介入原则 ② 用户参与开发原则 ③ 自顶向下规划原则 ③ 工程化原则 ⑤ 其他原则 创新性原则，用来体现信息系统的先进性整体性原则，用来体现信息系统的完整性发展性原则，用来体现信息系统的超前性经济性原则，用来体现信息系统的实用性 （5）开发方法 ① 结构化方法 定义：由结构化系统分析和设计组成，将系统的生命周期划分为系统调查、系统分析、系统设计、系统实施、系统维护等阶段，按照事先设计好的程序和步骤，使用一定的开发工具，完成规定的文档，在结构化和模块化的基础上进行信息系统的开发工作 特点： 开发目标清晰化工作阶段程式化开发文档规范化设计方法结构化 ② 原型法 定义：根据用户需求，利用系统开发工具，快速地建立一个系统模型展示给用户，在此基础上与用户交流，最终实现用户需求的信息系统快速开发的方法 特点：开发周期短、见效快、与业务人员交流方便 ③ 面向对象方法面 定义：利用面向对象的信息建模概念，如实体、关系、属性等，同时运用封装、继承、多态等机制来构造模拟现实系统的方法 ④ 面向服务 2.信息系统工程（1）定义：由相互作用和相互依赖的若干部分，按一定规律结合成的、具有特定功能的有机整体.把自然科学和社会科学的某些思想、理论、方法、策略和手段等根据总体协调的需要，有机地联系起来，应用定量和定性分析相结合的方法和计算机等技术工具，对系统的构成要素、组织结构、信息交换和反馈控制等功能进行分析、设计、制造和服务，从而达到最优设计、最优控制和最优管理的目的. （2）特点： 集合性相关性目的性层次性环境适应性 （3）系统分类 按照系统功能划分：工业控制系统、信息管理系统、军事系统和经济系统等按照系统与外界的关系划分：封闭系统和开放系统按照系统的内部结构划分：开环系统和闭环系统等按照抽象程度将系统分为：概念系统（描述系统的主要特征和大致轮廓）、逻辑系统（脱离实现细节的合理系统）和物理系统（实际存在的系统） （4）内容 ① 体系： 信息网络系统是指以信息技术为主要手段建立的信息处理、传输、交换和分发的计算机网络系统信息资源系统是指以信息技术为主要技术手段建立的信息资源采集、存储、处理的资源系统信息应用系统是指以信息技术为主要手段建立的各类业务管理的应用系统 ② 技术:方法、工具和过程 ③ 管理： 处理好组织内各流程之间的关系，合理地在各流程之间分配资源 建立流程管理机构，这一机构可归入管理流程之中配备强有力的领导来负责内部的流程管理工作。制定各流程之间的动态关系规则。通过实施流程管理模式，传统组织中的组织图将不复存在，取代它的是流程管理图 （5）总体规划 ① 目的：明确系统整个生命周期内的发展方向、系统规模和开发计划 ② 建设存在问题： 系统建设与组织发展的目标和战略不匹配已建成的系统解决问题的有效性低，即系统建成后对管理并无显著改善不能适应环境变化和组织变革的需要组织结构陈旧，管理落后系统使用人员的素质较低系统开发环境落后，技术方案不合理系统开发及运行维护的标准、规范混乱资源短缺，投入太少，而对系统的期望又过高。 ③ 主要任务： 制定信息系统工程的发展战略。主要是使信息系统工程的战略与整个组织的战略和目标协调一致确定组织的主要信息需求，形成信息系统工程的总体结构方案，安排项目开发计划制定系统建设的资源分配计划，即制定为实现开发计划而需要的硬软件资源、数据通信设备、人员、技术、服务和资金等计划，提出整个系统的建设概算 ④ 主要步骤： 对当前系统进行初步的调查分析和确定系统目标分析子系统的组成及基本功能拟定系统的实施方案进行系统的可行性研究编写可行性报告 ⑤ 意义：是进行具体开发工作的必要准备和基本依据 ⑥ 功能： 两原则： 一是从组织的战略出发，而不是从系统的需求出发，这样就可以避免脱离组织宗旨和战略目标，走入为建设而建设的困境二是从业务的变革出发，而不是从技术的变革出发，这样有利于充分利用组织的现有资源来满足关键需求，从而避免信息系统工程无法有效地支持组织决策。 在建设信息系统工程过程中，应当全面分析组织所处的环境、战略目标、组织结构、标准作业过程甚至它的文化，并从中找到所要建设的信息系统与组织的关系及其应当起的作用 ⑦ 分析过程 确定组织的总体目标确定信息系统工程规划的总体目标 ⑧ 规划范围： 信息战略规划信息资源规划信息系统工程建设规划企业资源规划 ⑨ 任务： 明确组织远景和使命确立组织发展战略和目标明晰组织业务及管理变革策略识别组织关键成功因素、分析关键性能指标、抽取信息需求建立总体信息工程框架提出可行性报告和总体规划方案。 ⑩ 确定功能范围的步骤确定系统的功能范围的步骤： 绘制出系统的总数据流程图根据系统方案的规定和用户的要求，结合现行系统的环境，确定系统的边界范围，并在总信息流程图上圈出有关人员协商讨论确定系统范围，并做出分析说明 ⑩-1 投资概算： 计算机系统软、硬件设备投资系统开发费系统安装和维护费用人员培训费 （6）总体规划的方法 ① 业务系统规划法（BSP）： 定义：它辅助企业信息系统规划，来满足其近期和长期的信息化需求 内容： 信息系统的战略应当表达出企业的各个管理层次的需求信息系统应该向整个企业提供一致的信息信息系统应该适应组织机构和管理体制的改变信息系统的战略规划 目标（提供信息系统规划，用以支持企业短期的和长期的信息需要）： 为管理者提供一种形式化的、客观的方法，明确建立信息系统的优先顺序，而不考虑部门的狭隘利益，并避免主观性为具有较长生命周期系统的建设和投资提供保障。由于系统是基于业务过程的，因而不因机构变化而失效为了以最高效率支持企业目标，BSP 提供数据处理和资源管理增加负责人的信心，使其坚信高效的信息系统能够被实施通过提供信息系统对用户需求的快速响应，从而改善信息系统管理部门和用户之间的关系。应将数据作为一种企业资源加以确定，为使每个用户更有效地使用这些数据，要对这些数据进行统一规划、管理和控制。 实施步骤： 确立项目工作准备主要活动 ② 关键成功因素法（CSF）定义：能够帮助组织找到影响系统成功的关键因素，进行分析以确定组织的信息需求，从而为管理部门控制信息技术及其处理过程提供实施指南 特征： 内部 CSF：针对机构的内部活动外部 CSF：与机构的对外活动有关监控型 CSF：对现有业务流程等进行监控建设型 CSF：适应组织未来变化的有关活动 层次： 行业的 CSF组织的 CSF部门的 CSF管理者的 CSF 实施步骤:通过集成高层管理者的目标而确定成功因素，通过个人的成功因素的汇总，导出组织整体的决定性成功因素，然后据此建立能够提供与这些成功因素相关的信息系统 了解组织的战略目标确定关键成功因素。对所有成功因素进行评价，根据组织的现状和目标确定关键成功因素识别绩效指标和标准，以及测量绩效的数据 ③ 战略目标集合转化法（SST） 定义：把组织的战略集合转化为信息系统的战略集合，而后者由信息系统的系统目标、环境约束和战略规划组成 步骤： 识别和阐明组织的战略集合(描绘出组织各类人员结构-&gt;识别每类人员的目标-&gt;对于每类人员识别其使命及战略)将组织的战略集合转化为信息系统战略集合 3.政府信息化与电子政务（1）政府信息化定义： 应用现代信息技术、网络技术和通信技术，通过信息资源的开发和利用来集成管理和服务，从而提高政府的工作效率、决策质量、调控能力，并节约开支，改进政府的组织结构、业务流程和工作方式，全方位地向社会提供优质、规范、透明的管理和服务第一，政府信息化必须借助于信息技术和网络技术，离不开信息基础设施和软件产品第二，政府信息化是一个系统工程，它不仅是与行政有关部门的信息化，还包括立法、司法部门及其他一些公共组织的信息化第三，政府信息化并不是简单地将传统的政府管理事务原封不动地搬到互联网上，而是要对已有的组织结构和业务流程进行重组或再造 （2）政府与政府（Government To Government） 首脑机关与中央和地方政府组成部门中央政府与各级地方政府之间政府的各个部门之间政府与公务员其他政府工作人员 （3）政府对企业（Government To Business） 政府向企（事）业单位发布的各种方针、政策、法规、行政规定政府向企（事）业单位颁发的各种营业执照、许可证、合格证、质量认证 （4）政府对公民 政府面向公民所提供的服务 （5）企业对政府 企业应向政府缴纳的各种税款，各种统计信息和报表，参加政府各项工程的竞、投标，各种商品和服务，以及就政府如何创造良好的投资和经营环境 （6）公民对政府 个人应向政府缴纳的各种税款和费用（填报的各种信息和表格，以及缴纳各种罚款）开辟公民参政、议政的渠道 （7）政府对公务员 政府机构通过网络技术实现内部电子化管理的重要形式 （8）电子政务建设的过程模式 以用户为中心引进“客户关系管理”技术政府门户 （9）电子政务的技术模式 ① 网络管理模式 政府专网通用网络 其还分为专用网络（政府部门之间的网络）、内部网络（政府内部的办公网络）和外部网络（对于为公众提供的信息及其他可公开的信息） ② 信息资源管理模式 内容： 来自公文系统的文档型信息来自数据处理系统的结构化信息 模式： 元数据管理模式：该模式可以为不同部门、不同级别的机构提供统一的数据管理和交换模式，为跨部门、跨行业的信息资源整合提供技术基础(分数是存储数据)XML数据管理模式：在数据交换和共享的层面上，基于 XML 数据管理模式，建立统一的信息技术平台，实现不同系统的互联 （10）应用开发模式 政府与公务员（Government To Employee，G2E）政府对经济活动（Government ToBusiness，G2B）政府对公民服务（Government ToCitizen，G2C） （11）电子政务的安全体系 物理安全网络安全信息安全安全管理 （12）《国家电子政务标准化指南》 第一部分：总则。概括描述电子政务标准体系及标准化的机制第二部分：工程管理。概括描述电子政务工程管理须遵循或参考的技术要求、标准和管理规定第三部分：网络建设。概括描述网络建设须遵循或参考的技术要求、标准和管理规定第四部分：信息共享。概括描述信息共享须遵循或参考的技术要求、标准和管理规定第五部分：支撑技术。概括描述支撑技术须遵循或参考的技术要求、标准和管理规定第六部分：信息安全。概括描述保障信息安全须遵循或参考的技术要求、标准和管理规定 （14）六项电子政务标准 ① 基于 XML 电子公文格式规范第一部分：总则，第二部分：公文体② XML 在电子政务中的应用指南③ 电子政务业务流程设计方法通用规范④ 信息化工程监理规范⑤ 电子政务数据元第一部分：设计和管理规范⑥ 电子政务主题词表编制规则 4.企业信息化与电子商务（1）定义： 企业以业务流程的优化和重构为基础，在一定的深度和广度上利用计算机技术、网络技术和数据库技术，控制和集成化管理企业生产经营活动中的各种信息，实现企业内外部信息的共享和有效利用，以提高企业的经济效益和市场竞争力 （2）目的： 要建立一个整体上相当于人的神经系统的数字神经系统 （3）企业信息化层次分析： 企业战略的层面 ：在规划中必须对企业目前的业务策略和未来的发展方向作深入业务运作层面：针对企业所确定的业务战略，通过分析获得实现这些目标的关键业务驱动力和实现这些目标的关键流程管理运作层面：虽然这一层面从价值链的角度上来说，属于辅助流程，但它对企业日常管理的科学性、高效性是非常重要的 （4）企业信息化方法 业务流程重构方法核心业务应用方法信息系统建设方法主题数据库方法资源管理方法人力资本投资方法 5.企业资源规划（ERP）（1）定义： 是一种融合了企业最佳实践和先进信息技术的新型管理工具。它扩充了 MIS、MRPⅡ（Manufacturing Resources Planning，制造资源计划）的管理范围，将供应商和企业内部的采购、生产、销售及客户紧密联系起来，可对供应链上的所有环节进行有效管理，实现对企业的动态控制和各种资源的集成和优化，提升基础管理水平，追求企业资源的合理高效利用 （2）ERP结构 ① 管理思想： 将企业的业务流程看作一个紧密连接的供应链，将企业内部划分成几个相互协同作业的支持子系统，如财务、市场营销、生产制造、质量控制、服务维护、工程技术等 ② 软件产品： 随着技术和时代的进步，为企业提供更多更好的功能，帮助企业实现管理信息化和现代化，因而使得企业市场竞争力和综合实力得到提高 ③ 管理系统： ERP 是一个集成的信息系统，ERP 承诺建立跨越企业各个部门、各种生产要素和环境的单一应用原则下处理所有的事务，即意味着集成。这种集成应该包括人力资源、财务、销售、制造、任务分派和企业供应链等的各项管理业务 ④ 六大功能目标： 支持企业整体发展战略经营系统 实现全球大市场营销战略与集成化市场营销，也就是实现在预测、市场规模、广告策略、价格策略、服务、分销等各方面进行信息集成和管理集成 完善企业成本管理机制 研究开发管理系统，保证能够迅速地开发适应市场要求的新的产品，构筑企业的核心技术体系，保持企业的竞争优势 建立敏捷的后勤管理系统，强调通过动态联盟模式把优势互补的企业联合在一起，用最有效和最经济的方式参加竞争，迅速响应市场瞬息万变的需求 实施准时生产方式，把客户纳入产品开发过程，把销售代理商和供应商、协作单位纳入生产体系，按照客户不断变化的需求同步组织生产，时刻保持产品的高质量、多样性和灵活性 （3）ERP功能 支持决策的功能为处于不同行业的企业提供有针对性的 IT 解决方案从企业内部的供应链发展为全行业和跨行业的供应链 （4）主要功能模块 生产控制（计划、制造）物流管理（分销、采购、库存管理）财务管理（会计核算、财务管理） 6.客户关系管理（CRM）（1）定义： 改善企业与客户之间关系的新型管理机制。它通过提供更快速、更周到的优质服务来吸引或保持更多的客户，集成了信息系统和办公系统等的一整套应用系统，从而确保了客户满意度的提高，以及通过对业务流程的全面管理来降低企业成本，重构包括市场营销和客户服务等业务流程 （2）CRM内容： 客户服务市场营销共享的客户资料库分析能力 （3）解决方案和实施过程 畅通有效的客户交流渠道（触发中心）对所获信息进行有效分析（挖掘中心）CRM 必须能与 ERP 很好地集成 7.产品数据管理（PDM）（1）定义： 是工程数据管理、文档管理、产品信息管理、技术数据管理、技术信息管理、图像管理，以及其他产品定义信息管理的集成管理框架技术用来管理所有与产品相关信息（包括零件信息、配置、文档、计算机辅助设计文件、结构、权限信息等）和所有与产品相关过程（包括过程定义和管理）的技术;为企业设计和生产构筑一个并行产品开发环境（由供应、工程设计、制造、采购、销售与市场、客户构成）的关键技术帮助产品设计师、制造工程师及其他人员有效管理产品数据及产品开发过程的工具，目标是跟踪、组织、访问和管理产品设计、开发、修改和生产，甚至维修全过程中的所有数据和信息 （2）类别： 信息的使用者数据的创造者系统管理员 （3）发展三阶段： 配合 CAD（Computer Aided Design，计算机辅助设计）使用的早期简单的 PDM 系统产品数据管理产品协同商务（Collaborative Product Commerce，CPC）或 PDM 标准化 （4）主要功能模块和内容 数据基库产品配置管理工作流管理分类及检索功能项目管理 8.企业门户（1）定义： 为企业优化业务模式、扩展市场渠道、改善客户服务，以及提升企业形象和凝聚力的强有力手段 （2）主要功能： 能够将一个机构现有的互联网址和服务完全合并而且相互兼容。能够支持开放标准和应用编程接口，让平台得以轻易容纳新的应用程序。能够接入一个由支持企业门户网站架构的伙伴和专业服务公司所组成的网络。能够多渠道接入网站。能够以统一的服务作为企业门户网站各种服务的基础，让用户享有多种便利 （3）类别： 企业信息门户：为人们提供企业信息企业知识门户：企业员工日常工作所涉及相关主题内容的“总店”企业应用门户：对企业业务流程的集成 （4）基本要素： 战略性思维为用户所需要的不同类型门户网站建立一个门户网站架构寻找合适的技术供货商确定所要建立的门户网站类型首先小规模地试办项目，确保有一个可行的工作环境 9.企业应用集成（EAI）（1）定义： 将进程、软件、标准和硬件联合起来，在两个或更多的企业信息系统之间实现无缝集成，使它们就像一个整体一样 （2）内容： ① 企业内部应用集成： 界面集成平台集成数据集成过程集成 ② 企业间应用集成： 通过集成供应链内的所有应用和数据库实现信息共享 （3）主流集成模式： 面向信息的集成技术面向过程的集成技术面向服务的集成技术 10.供应链管理（1）定义： 从源头供应商到最终消费者的集成业务流程,利用计算机网络技术全面规划供应链中的商流、物流、信息流、资金流等并进行计划、组织、协调和控制 （2）供应链与物流结合 （3）运作模式 需求信息流:从需方向供方流动时，便引发物流供应信息流:同物料一起沿着供应链从供方向需方流动 （4）技术支持体系 由标识代码技术、自动识别与数据采集技术、电子数据交换技术、互联网技术等基础信息技术构成基于信息技术而开发的支持企业生产 11.电子商务（1）定义： 买卖双方利用现代开放的 Internet，按照一定的标准所进行的各类商业活动狭义：利用 Web 提供的通信手段在网上买卖产品或提供服务广义：包括狭义以内，企业内部的商务活动；以及企业间的商务活动 （2）三方面： 电子商情广告、电子选购和交易电子交易凭证的交换、电子支付与结算网上售后服务 （3）参与实体: 顾客（个人消费者或集团购买）商户（包括销售商、制造商、储运商）银行（包括发卡行、收单行）认证中心 （4）类别（按交易对象） 企业与消费者之间的电子商务（Business to Customer，B2C）企业与企业之间的电子商务（Business to Business，B2B）消费者与消费者之间的电子商务（Customer to Customer，C2C）O2O 即 Online To Offline（在线离线/线上到线下） 12.知识管理与商业智能（1）定义： 在组织中建构一个人文与技术兼备的知识系统，让组织中的信息与知识，通过获得、创造、分享、整合、记录、存取、更新等过程，实现不断创新。同时，这种创新知识又不断回馈到组织之内，从而使得组织的知识不间断地累积和升华，进而转化为企业的智慧资本 （2）知识管理的工具和手段 ① 知识管理工具的范畴： 数据管理工具信息管理工具知识管理工具 ② 知识管理工具的分类： 用于知识生成的工具用于知识编码的工具用于知识转移的工具 ③ 不足： 功能不完整集成度不高协同性不够可构性差 （3）商业智能 ① 定义：企业对商业数据的搜集、管理和分析的系统过程 ② 目的：使企业的各级决策者获得知识或洞察力，帮助他们做出对企业更有利的决策 ③ 商业智能系统四阶段： 数据预处理：数据的抽取、转换和装载建立数据仓库：处理海量数据的基础数据分析：联机分析处理和数据挖掘数据展现：保障系统分析结果的可视化 13.业务流程重组（BPR）（1）定义： 为了完成某一目标或任务而进行的一系列跨越时空的逻辑相关活动的有序集合，过考察业务流程的发生、发展和终结，确定、描述、分析、分解整个业务流程，重构与业务流程相匹配的企业运行机制和组织机构，实现对企业全流程的有效管理和控制，能够使企业真正着眼于流程的结果，消除传统管理中只注重某一环节而无人负责全流程的弊端 （2）4核心内容 根本性：强调要进行根本性的再思考，各方面都要关注流程彻底性：对 BPR 进行追根溯源戏剧性：不是追求稍有改善，而是充分强调结果的满意度流程：建立以流程工作小组为单元的管理模式 （3）作用： BPR 的实施使企业更贴近市场BPR 使生产成本成倍压缩BPR 使产品质量得到全面提升服务质量更趋完美 （4）遵循原则 流程中心原则企业业务流程团队管理原则在流程式管理模式下,企业的组织结构必须服从业务流程客户导向原则","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.yiyuclub.club/categories/学习笔记/"},{"name":"软考架构师","slug":"学习笔记/软考架构师","permalink":"http://www.yiyuclub.club/categories/学习笔记/软考架构师/"}],"tags":[{"name":"软考","slug":"软考","permalink":"http://www.yiyuclub.club/tags/软考/"},{"name":"架构师","slug":"架构师","permalink":"http://www.yiyuclub.club/tags/架构师/"}]},{"title":"（软考架构师笔记十三）开发管理","slug":"（软考架构师笔记十三）开发管理","date":"2019-06-04T02:08:38.000Z","updated":"2019-06-24T09:13:28.066Z","comments":true,"path":"2019/06/04/（软考架构师笔记十三）开发管理/","link":"","permalink":"http://www.yiyuclub.club/2019/06/04/（软考架构师笔记十三）开发管理/","excerpt":"（软考架构师笔记十三）开发管理","text":"（软考架构师笔记十三）开发管理 1.概念 在项目活动中运用专门的知识、技能、工具和方法，使项目能够实现或超过项目干系人的需要和期望项目管理分类：范围管理、时间管理、费用管理、质量管理、人力资源管理、沟通 管理、风险管理、采购管理和整体管理软件项目管理分类：软件范围管理、软件进度管理、软件成本管理、软件配置管理（属于整体管理）、软件质量管理、软件风险管理、开发人员管理（属于人力资源管理） 2.项目范围管理（1）定义：保证项目顺利完成所需的全部工作过程 （2）目的：控制项目的全部活动都在需求范围内，以确保项目资源的高效利用 （3）内容： 项目启动范围计划编制范围定义范围核实范围变更控制 一般与其他管理结合才能发挥更好作用 3.项目成本管理（1）定义：保证在批准预算内完成项目所需要的过程（成本不仅包括开发成本，也包括开发之前立项阶段及软件在运行中的费用） （2）方式： 资源计划编制：确定完成活动需要的资源数量成本估算：计算完成活动所需资源成本的近似值成本预算：把估算的总成本分配到单个活动或工作包上去，建立基准计划来度量项目实际绩效成本控制 ：对造成成本基准计划变化的因素施加影响，以保证这种变化得到一致认可；确定成本基准计划是否已经发生变化；当变化发生和正在发生时，对这种变化执行管理 （3）成本控制内容： 监测成本执行情况，以寻找出并掌握计划的偏差及原因确保所有变更都准确地记录在成本基准计划中防止把不正确、不适宜或未批准的变更纳入成本基准成本将批准的变更通知项目干系人 一般与其他管理结合,否则偏差值会很大 4.项目时间管理（1）定义：确保项目按时完成所需的各个过程 （2）内容： 活动定义：对 WBS 中规定的可交付成果或半成品的产生所必须进行的具体活动进行定义，并形成文档活动排序：确定各活动之间的依赖关系，并形成文档活动历时估算：根据项目范围和资源的相关信息为进度表设定历时输入的过程进度计划编制进度控制 （3）进度控制内容： 对造成进度变更的因素施加影响，以确保这些变更得到一致认可确定进度变更是否已经发生当变更发生时对实际变更进行管理。 5.项目配置管理（1）定义： 在软件系统中确定和定义构件（源代码、可执行程序、文档等），在整个生命周期中控制发布和变更，记录和报告构件的状态和变更请求，并定义完整的、正确的系统构件的过程 （2）内容： 配置标识版本控制状态统计审计与审查生产过程管理小组协调 （3）主要任务： 建立项目重构任何修订版的某一项或某一文件利用加锁技术防止覆盖当增加一个修订版时要求输入变更描述提供比较任意两个修订版的使用工具采用增量存储方式提供对修订版历史和锁定状态的报告功能提供归并功能允许在任何时候重构任何版本权限的设置晋升模型的建立提供各种报告 （4）常用的软件配置管理工具：Rational ClearCase，Merant PVCS，Microsoft VSS，CVS 6.项目文档管理（1）定义：某种数据媒体和其中所记录的数据。它具有永久性，并可以由人或机器阅读，通常仅用于描述人工可读的东西 （2）作用 管理依据任务之间联系的凭证质量保证培训与参考软件维护支持历史档案销售可能 （3）分类 开发文档：描述软件开发过程管理文档：产品文档规定关于软件产品的使用、维护、增强、转换和传输的信息产品文档：从管理的角度规定涉及软件生存的信息 （4）编制计划 提示编制文档应参考的标准提供编制文档所需要的条件，落实文档编写人员、所需经费及编制工具明确保证文档质量的方法制定进度表 （5）具备特征 针对性精准性清晰性完整性灵活性 7.软件需求管理（1）定义：控制和维持事先约定，保证项目开发过程的一致性，使用户能够得到他们最终想要得到的软件产品 （2）需求变更 ① 定义： 在软件开发过程中，用户确定软件需求之后，由于各种客观和主观条件的变化，用户增加了新的需求或改变了原有需求 ② 变更依据： 项目计划变更请求反映项目执行状况的绩效报告 ③ 措施： 项目启动阶段的变更预防项目实施阶段的需求变更 （3）需求跟踪 ① 定义： 指在软件需求管理的过程中定义需求变更流程，分析需求变更影响，控制变化的版本，维护需求变更记录,跟踪每项需求状态 ② 内容： 确定需求变更控制过程进行需求变更影响分析建立需求基准版本和需求控制版本文档维护需求变更的历史记录跟踪每项需求的状态 8.软件质量管理（1）定义： 保证项目能满足原先规定的各项要求所需要的过程，即“总体管理功能中决定质量方针、目标与责任的所有活动，并通过诸如质量规划、质量保证、质量控制、质量改进等手段在质量体系内加以实施 （2）内容： 质量计划：判断哪些质量标准与本项目相关，并决定应如何达到这些质量标准质量保证：定期评估项目总体绩效，建立项目能达到相关质量标准的信心质量控制：监测项目的总体结果，判断它们是否符合相关质量标准，并找出如何消除不合格绩效的方法 （3）质量计划： ① 目的：说明用以实施质量管理的组织结构、责任、程序、过程和资源” ② 常用标准：ANSI/IEEE STOL730—1984，983—1986 ③ 活动： 对项目的软件质量活动做出计划对软件产品质量的可测量的目标及其优先级进行定义确定软件产品质量目标的实现过程是可量化和可管理的为管理软件产品的质量提供适当的资源和资金对实施和支持软件质量管理的人员进行实施和支持过程中所要求的培训对软件开发项目组和其他与软件项目有关的人员进行软件质量管理方面的培训按照已文档化的规程制订和维护项目的软件质量计划项目的软件质量管理活动要以项目的软件质量计划为基础在整个软件生命周期，要确定、监控和更新软件产品的质量目标 （4）作用： 为项目符合相关质量标准要求树立信心而在质量系统内部实施的各项有计划的系统活动监视项目的具体结果，确定其是否符合相关的质量标准，并判断如何杜绝造成不合格结果的根源 9.软件风险管理（1）定义： 对项目风险进行识别、分析、并采取应对措施的系统过程。它包括尽量扩大有利于项目目标事项发生的概率与后果，而尽量减小不利于项目目标事项发生的概率与后果 （2）按是否有可确定性划分类： 已知风险可预知风险不可预知风险 （3）按风险管理分类： 内部技术风险内部非技术风险外部法律风险外部非法律风险 （4）内容： 风险管理规划，决定如何指导和规划项目的风险管理活动项目风险识别，找到哪些风险可能影响项目，并记录其特征定性风险分析，完成风险和环境的定性分析，并按其对项目目标的影响进行排序定量风险分析，度量风险的可能性和后果，估量其对项目目标的潜在影响风险应对计划，创建过程和技术来为项目目标增进机会和减小威胁风险监督与控制，在项目生命周期中监视现存的风险、识别新的风险、执行缓解风险计划及评估其效果 （5）风险识别：识别整个项目过程中可能存在的风险事件 （6）风险分析：确定每个风险对项目的影响大小，一般是对已经识别出来的项目风险进行量化估计 （7）风险应对方法：可规避性、可转移性、可缓解性、可接受性 （8）风险应对计划：应用于项目进行期间发生的已识别风险，事先制订应变计划可大大降低风险发生时采取行动的成本 （9）风险监控：跟踪已识别风险的发展变化情况-&gt;根据风险的变化情况及时调整风险应对计划 10.人力资源管理（1）定义：最有效地使用参与项目人员所需的各项过程，一般包括组织规划、人员招募和团队建设三个主要过程 （2）组织规划 ① 定义：用于确定、记录并分派项目角色、职责和请示汇报关系 ② 团队组织：垂直团队组织、水平团队组织、混和团队组织 （3）人员招募 ① 定义：获取分派到项目上、并在那里工作所需的人力资源（个人或集体） ② 需考虑的问题： 以往经验：这些个人或集体以前是否从事过类似或者相关的工作？工作表现如何？个人兴趣：这些个人或集体对本项目的工作感兴趣吗？能否得到：最理想的个人或集体人选能在规定期限内招募到手吗？胜任与熟练程度：需要何种能力及何种水平？ ③ 项目经理具备能力： 领导能力：懂得如何授权和分配职责、善于激励、树立榜样、抉择果断沟通能力：善于提问，并做到有效地聆听，能经常站在对方的角度思考问题人际交往能力应付压力的能力培养员工的能力时间管理技能 （3）团队建设 ① 定义：包括提高项目干系人作为个人做出贡献的能力，也包括提高项目团队作为集体发挥作用的能力 ② 成长规律四阶段： 形成阶段震荡阶段正规阶段表现阶段 ③ 团队应有特点： 能清晰地理解项目的目标每位成员的角色和职责有明确的期望以项目的目标为行为的导向项目成员之间高度信任、高度合作互助 11.软件的运行与评价（1）定义： 软件开发结束后交付用户使用，用户在实际使用中对软件是否符合开发时制定的一系列评价标准进行打分，看是否满足了用户的使用要求 （2）内容： 软件的稳定性和可靠性评价软件是否满足了用户的需求软件实施给用户带来的好处 12.软件过程改进（1）定义：用于帮助软件企业对其软件生产过程进行计划、过程诊断、改进方案的制订及实施等工作 （2）实施对象：软件企业的软件过程，即软件产品的生产过程，也包括配置管理、软件维护等辅助过程 （3）改进模型： 软件能力成熟度模型（CMM）能力成熟度模型集成(CMMI)ISO 9000信息技术基础设施库（ITIL）","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.yiyuclub.club/categories/学习笔记/"},{"name":"软考架构师","slug":"学习笔记/软考架构师","permalink":"http://www.yiyuclub.club/categories/学习笔记/软考架构师/"}],"tags":[{"name":"软考","slug":"软考","permalink":"http://www.yiyuclub.club/tags/软考/"},{"name":"架构师","slug":"架构师","permalink":"http://www.yiyuclub.club/tags/架构师/"}]},{"title":"（软考架构师笔记十二）嵌入式系统设计","slug":"（软考架构师笔记十二）嵌入式系统设计","date":"2019-06-03T01:37:25.000Z","updated":"2019-06-24T09:13:28.066Z","comments":true,"path":"2019/06/03/（软考架构师笔记十二）嵌入式系统设计/","link":"","permalink":"http://www.yiyuclub.club/2019/06/03/（软考架构师笔记十二）嵌入式系统设计/","excerpt":"（软考架构师笔记十二）嵌入式系统设计","text":"（软考架构师笔记十二）嵌入式系统设计 1.概念 一种以应用为中心，以计算机技术为基础，可以适应不同应用对功能、可靠性、成本、体积、功耗等方面的要求，集可配置，可裁减的软、硬件于一体的专用计算机系统 三要素： 嵌入性：计算机计算机嵌入到对象系统中，且满足对象系统的环境要求专用性：软、硬件的裁剪性，满足对象要求的最小软、硬件配置计算机系统：嵌入式系统必须是一个能满足对象系统控制要求的计算机系统 特点： 系统专用性强系统实时性强软、硬件依赖性强处理器专用多种技术紧密结合系统透明性系统资源受限 2.组成（1）定义 硬件：嵌入式处理器、存储器和外部设备软件：系统软件、应用支撑软件和应用软件 2.硬件架构（1）嵌入式基本硬件架构图 （2）嵌入式处理器 ① 核心：各种类型的嵌入式处理器 ② 类别： 嵌入式微处理器（EMPU）嵌入式微控制器（EMCU）嵌入式数字信号处理器（EDSP）嵌入式片上系统 （3）总线 ① 定义： 连接计算机系统内部各个部件的共享高速通路 ② 分类： 片内总线：嵌入式微处理器内的CPU 与片内其他部件连接的总线片外总线：总线控制器集成在微处理器内部或外部芯片上的用于连接外部设备的总线 ③ 代表： 先进微控制总线（AMBA总线）外围构件互围总线（PCI 总线）Avalon总线 （4）存储器 高速缓存：Cache 全部集成在嵌入式微处理器内部，分为数据Cache、指令 Cache 和混合 Cache主存：处理器能够直接访问的存储器，用来存放系统和用户的程序和数据外存：是不与运算器直接联系的后备存储器，用来存放不常用的或暂不使用的信息 （5）I/O 设备与接口 3.嵌入式软件架构 操作系统： 操作系统内核、应用程序接口、设备驱动程序接口等几部分组成应用支撑软件：由窗口系统、网络系统、数据库管理系统及 Java 虚拟机等几部分组成应用软件 4.嵌入式开发平台与调试环境（1）开发平台 ① 使用的是交叉式开发方法 ② 交叉平台开发环境 定义：软件在一个通用的平台上开发，而在另一个嵌入式目标平台上运行宿主机系统：用于开发的机器系统目标机系统：被开发的嵌入式系统二者相同：本地开发 ② 交叉编译环境：由宿主机提供 （2）嵌入式开发调试① 介绍：由于嵌入式系统条件限制，调试的方式不能和通用的方式一样在同一台机子调试，通常采用交叉方式 ② 方式分类： 直接调试法：将目标代码下载到目标机上，让其执行，通过观察指示灯来判断程序的运行状态 调试监控法（插桩法）：目标机和宿主机一般通过串行口、并行口或以太网相连接，采用这种方法还需要在宿主机的调试器内和目标机的操作系统上分别启动一个功能模块，然后通过这两个功能模块的相互通信来实现对应用程序的调试 在线仿真法：替代目标机上 CPU 的设备片上调试法：CPU 芯片内部的一种用于支持调试的功能模块 模拟器法：运行于宿主机上的一个纯软件工具，它通过模拟目标机的指令系统或目标机操作系统的系统调用来达到在宿主机上运行和调试嵌入式应用程序的目的 5.嵌入式网络系统（1）定义：用于连接各种嵌入式系统，使之可以互相传递信息、共享资源的网络系统 （2）现场总线网(工业自动化领域的计算机局域网) ① 定义： 是一种将数字传感器、变换器、工业仪表及控制执行机构等现场设备与工业过程控制单元、现场操作站等互相连接而成的网络 （3）家庭信息网 ① 定义： 是一种把家庭范围内的个人计算机、家用电器、水、电、气仪表、照明设备和网络设备、安全设备连接在一起的局域网 ② 功能：集中控制上述设备并将其接入Internet，以共享网络资源和服务 （4）无线数据通信网 ① 定义：是一种通过无线电波传送数据的网络系统 ② 分类： 短程无线网： 802.11、蓝牙、IrDA 及 HomeRF无线inernet：移动无线接入技术、固定无线接入技术 （2）嵌入式Internet ① 接入方式： 集成了 TCP/IP 协议栈及相关软件，这类设备可以作为 Internet 的一个节点，分配有 IP 地址，与 Internet 直接互联 通 Internet，即采用瘦设备方案，设备不直接接入 Internet，不需要复杂的TCP/IP 协议全集，而是通过接入设备接入 Internet （3）嵌入式 TCP/IP 协议栈 嵌入式协议栈的调用接口与普通的协议栈不同嵌入式协议栈的可裁剪性嵌入式协议栈的平台兼容性嵌入式协议栈的高效率 6.嵌入式数据库管理系统（1）使用环境特点 设备随时移动性网络频繁断接网络条件多样化通信能力不对称 （2）系统组成与关键技术 ① 嵌入式数据库管理系统 ② 同步服务器 ③ 数据服务器 ④ 连接网络 7.实时系统与嵌入式操作系统（1）实时系统：① 定义：对外部事件能够及时响应的系统 ② 实时系统与嵌入式操作系统关系： 逻辑（或功能）正确，是指系统对外部事件的处理能够产生正确的结果时间正确，是指系统对外部事件的处理必须在预定的周期内完成死线（Deadline）或时限、死限、截止时间，是指系统必须对外部事件进行处理的最迟时间界限实时系统，是指功能正确和时间正确同时满足的系统 ③ 分类： 强实时系统一般实时系统弱实时系统硬实时系统软实时系统 （2）嵌入式操作系统① 定义： 运行在嵌入式计算机系统上支持嵌入式应用程序的操作系统，是用于控制和管理嵌入式系统中的硬件和软件资源、提供系统服务的软件集合 ② 特点： 微型化代码质量高专业化实时性强可裁减、可配置 ③ 分类 根据获取方式：商业型和免费型实时性：实时操作系统和非实时操作系统 （3）实时嵌入式操作系统 ① 分类： 实时内核型的 RTEOS：驱动程序传统嵌在内核之中，应用程序和中间件实现在标准的应用程序接口之上通用型的 RTEOS：驱动程序并非深度嵌入到内核中，而是在内核之上实现，并且仅包含少数必要的驱动程序，应用程序和中间件可以直接在驱动程序之上实现，而不必在标准的 APIs 实现 ② 特性： 满足嵌入式应用的高可靠性；满足应用需要的可裁减能力；内存需求少；运行的可预测性；采用实时调度策略；系统的规模紧凑；支持从 ROM 或 RAM 上引导和运行；对不同的硬件平台均有更好的可移植性。 ③ 性能指标： 任务切换时间中断处理相关的时间指标系统响应时间 .嵌入式系统的开发设计（1）目的：定义系统的功能、决定系统的架构，并将功能映射到系统实现架构上 （2）设计特点： 软、硬件协同并行开发；微处理器的类型多种多样；实时嵌入式操作系统具有多样性；与通用系统开发相比，可利用系统资源很少；应用支持少；要求特殊的开发工具；软、硬件都要很健壮；调试很困难。 （3）设计指标 非重复性工程成本(NRE成本)单位成本大小性能功率灵活性上市时间可维护性安全性正确性 （4）设计挑战 需要多少硬件如何满足时限如何减少系统的功耗如何满足系统可升级性如何保证系统的可靠性测试复杂性可视性和可控制性有限开发环境受限 （5）开发模型与设计流程 ① 常用开发模型 瀑布模型螺旋模型逐步求精模型层次模型 （6）设计方法 嵌入式系统软件的开发过程可以分为项目计划、可行性分析、需求分析、概要设计、详细设计、程序建立、下载、调试、固化、测试及运行等几个阶段 （7）核心技术 ① 处理器技术 通用处理器单用途处理器专用处理器 ② IC 技术 全定制/VLSI（Very Large Scale Integrated Circuites，超大规模集成电路）半定制/ASIC（Application Specific Integrated Circuit，专用集成电路）可编程/ASIC ③ 设计/验证技术 芯片级设计技术：核心是编译/综合、库/IP（Intellectual Property，知识产权）、测试/验证软件设计技术：核心是软件语言 （8）设计环境 与嵌入式操作系统配套的开发环境与处理器芯片配套的开发环境与具体应用平台配套的开发环境其他类的开发环境 （9）设计模型 ① 状态机模型 用一组可能的状态来描述系统的行为，系统在任何时刻只能处于其中一个状态，也可以描述由输入确定的状态转移，最后可以描述在某个状态下或状态转移期间可能发生的操作 ② 数据流模型 并发多任务模型派生出的一种模型，该模型将系统的行为描述为一组结点和边，其中结点表示变换，边表示从一个结点到另一个结点的数据流向。每个结点使用来自其输入边的数据，执行变换并在其输出边上产生数据 ③ 并发进程模型 由一组进程构成，每个进程是一个顺序执行的过程，各进程间可以并发执行。并发进程模型提供创建、终止、暂停、恢复和连接进程的操作。进程在执行中可以相互通信，交换数据。进程间通信可以采用两种方式：共享变量和消息传递。信号量、临界区、管程和路径表达式等用来对并发进程的操作进行同步 ④ 面向对象模型 一个对象向另一个对象发送消息后，若不需要或不立即需要消息的处理结果，前者不必等待后者处理消息，消息发送者和消息接受者可以并发执行。对象不都是处于被动的提供服务状态，它们中的一些除了能通过接收消息向外提供服务外，还可以有自己的事务处理。一个对象往往可以同时处理多个消息 并发与对象结合的两条途径： 在面向对象模型中引进并发机制，充分利用面向对象技术刻画客观世界的良好模型能力和面向对象的各个重要特性，同时把其潜在的并发能力描述出来，使其适合于描述并发计算在传统并发模型中引进面向对象思想 面向对象的并发模型的两种类型： 隐式并发模型：推迟并发设计，将对象建模作为建模基础显式并发模型：首先考虑并发，应先把并发概念和对象概念分开 （10）需求分析 功能性需求：说明这个系统必须做什么，而非功能性需求说明系统的其他属性非功能性需求 （11）系统设计 ① 类别： 协同合成工具： POLIS、COSYMA和Chinook协同模拟工具：PTOLEMY、TSS ② 系统架构设计（先考虑软件架构再考虑硬件架构） 原始框图软件系统架构硬件系统架构 ③ 硬件子系统设计 开发环境组成： 目标硬件平台嵌入式操作系统编程语言开发工具 考虑因素： 选择处理器技术通用嵌入式处理器的选择硬件设计的注意事项 ④ 软件子系统设计（按软件设计的方式即可） 考虑因素： 操作系统的选择编程语言的选择软件开发过程软件开发文档 （12）系统集成与测试 软件测试硬件测试单元测试","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.yiyuclub.club/categories/学习笔记/"},{"name":"软考架构师","slug":"学习笔记/软考架构师","permalink":"http://www.yiyuclub.club/categories/学习笔记/软考架构师/"}],"tags":[{"name":"软考","slug":"软考","permalink":"http://www.yiyuclub.club/tags/软考/"},{"name":"架构师","slug":"架构师","permalink":"http://www.yiyuclub.club/tags/架构师/"}]},{"title":"（软考架构师笔记十一）测试评审方法","slug":"（软考架构师笔记十一）测试评审方法","date":"2019-05-31T01:52:11.000Z","updated":"2019-06-24T09:13:28.066Z","comments":true,"path":"2019/05/31/（软考架构师笔记十一）测试评审方法/","link":"","permalink":"http://www.yiyuclub.club/2019/05/31/（软考架构师笔记十一）测试评审方法/","excerpt":"（软考架构师笔记十一）测试评审方法","text":"（软考架构师笔记十一）测试评审方法 1.概念 软件测试与评审是软件质量保证的主要手段之一，也是在将软件交付给客户之前所必须完成的步骤 2.测试方法 缺陷：针对产品而言错误：针对开发过程而言 目的： 在软件投入生产性运行之前，尽可能多地发现软件产品（主要是指程序）中的错误（缺陷） 方案： 应竭力设计能暴露错误（缺陷）的测试用例 （1）软件测试阶段 ① 单元测试（模块测试） 目的：发现编程和详细设计中产生的错误场景：程序员编程阶段对象：单个模块 ② 集成测试（组装测试） 目的：发现模块间的接口和通信问题场景：程序员编程阶段（单元测试之后）对象：多个模块 方式： 非渐增式：先测试所有的模块，然后一下子把所有这些模块集成到一起，并把庞大的程序作为一个整体来测试渐增式：将未测试的模块单独加入集成模块中，依次递增 ③ 系统测试 目的：全局来考察软件系统的功能和性能要求场景：程序员编程最后阶段（单元测试和集成测试之后）对象：所有模块 方式： 确认测试：依据软件需求说明书检查软件的功能、性能及其他特征是否与用户的需求一致验收测试：确认其所有需求是否都已得到满足 （2）白盒测试和黑盒测试 ① 白盒测试（结构测试） 定义：代码透明，测试者完全知道程序的结构和处理算法场景：单元测试阶段技术：逻辑覆盖：考察用测试数据运行被测程序时对程序逻辑的覆盖程度 覆盖标准： 语句覆盖：选择足够多的测试用例，使得运行这些测试用例时，被测程序的每个语句至少执行一次判定覆盖（分支覆盖）：不仅每个语句至少执行一次，而且每个判定的每种可能的结果（分支）都至少执行一次条件覆盖：不仅每个语句至少执行一次，而且使判定表达式中的每个条件都取得各种可能的结果判定/条件覆盖：选取足够的测试用例，使得判定表达式中每个条件的所有可能结果至少出现一次，而且每个判定本身的所有可能结果也至少出现一次组合条件覆盖和路径覆盖：选取足够的测试用例，使得每个判定表达式中条件结果的所有可能组合至少出现一次路径覆盖：选取足够的测试用例，使得程序的每条可能执行到的路径都至少经过一次 ② 黑盒测试（功能测试） 定义：代码不透明，只检查软件功能是否能按照软件需求说明书的要求正常使用场景：集成测试和确认测试阶段技术：等价类划分、边值分析、错误推测和因果图 等价类划分： 把类似的数划分为等价类，如果一个类错误，其等价类也可能错误 边值分析： 软件在处理边界情况时最容易出错，设计一些测试用例，使软件恰好运行在边界附近，暴露出软件错误的可能性会更大一些 错误推测： 依靠测试人员的经验和直觉，从各种可能的测试方案中选出一些最可能引起程序出错的方案 因果图： 根据输入条件与输出结果之间的因果关系来设计测试用例 （3）缺陷的分类和级别① 分类： 输入/输出错误逻辑错误计算错误接口错误数据错误 ② 级别： 轻微（例如，界面文字有个别的错别字，但不影响理解）中等（例如，界面文字错误可能误导操作者）使人不悦（例如，数字串被断开）影响使用（例如，有些交易没有处理）严重（例如，丢失交易）非常严重（例如，不正确的交易处理）极为严重（例如，经常出现不正确的交易处理）无法容忍（例如，数据库遭到破坏）灾难性（例如，系统无法工作）传染性（例如，可导致其他系统无法工作）。 （4）调试(排错)① 标志：发现错误 ② 程序错误特质： 错误的外部征兆远离引起错误的内部原因，对于高度耦合的程序结构此类现象更为严重纠正一个错误造成了另一错误现象（暂时）的消失某些错误征兆只是假象因操作人员一时疏忽造成的某些错误征兆不易追踪错误是由于分时而不是程序引起的输入条件难以精确地再构造（例如，某些实时应用的输入次序不确定）错误征兆时有时无，此现象对嵌入式系统尤其普遍错误是由于把任务分布在若干台不同处理机上运行而造成的。 ③ 拍错策略： 原始类回溯类排除类 2.评审方法（1）定义： 是对软件元素或者项目状态的一种评估手段，以确定其是否与计划的结果保持一致，并使其得到改进狭义评审：指软件文档和源程序的评审广义评审：狭义评审的内容和与软件测试相结合的评审及管理评审 （2）软件评审： 软件需求评审概要设计评审详细设计评审软件验证和确认评审功能检查物理检查综合检查管理评审 2.验证和确认（1）验证： 合同验证过程验证需求验证设计验证编码验证集成验证文档验证 （2）确认 编写测试需求、测试用例和测试规程。确保这些测试需求、测试用例和测试规程可以反映软件产品的预期用途。执行测试。确认软件产品满足其预期用途。 3.测试自动化适合场景： 测试用例的生成（包括测试输入、标准输出、测试操作指令等）测试的执行控制（包括单机与网络多机分布运行、夜间及假日运行、测试用例调用控制、测试对象、范围、版本控制等）测试结果与标准输出的对比不吻合的测试结果的分析、记录、分类和通报总测试状况的统计，报表的产生 4.面向对象的测试定义：摒除原本的单元、集成、系统测试的传统模式，改为以下： （1）面向对象测试模型 （2）面向对象分析的测试 （3）面向对象设计的测试 （4）面向对象编程的测试 （5）面向对象的单元测试 （6）面向对象的集成测试 （7）面向对象的系统测试","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.yiyuclub.club/categories/学习笔记/"},{"name":"软考架构师","slug":"学习笔记/软考架构师","permalink":"http://www.yiyuclub.club/categories/学习笔记/软考架构师/"}],"tags":[{"name":"软考","slug":"软考","permalink":"http://www.yiyuclub.club/tags/软考/"},{"name":"架构师","slug":"架构师","permalink":"http://www.yiyuclub.club/tags/架构师/"}]},{"title":"（软考架构师笔记十）设计模式","slug":"（软考架构师笔记十）设计模式","date":"2019-05-31T01:05:24.000Z","updated":"2019-06-24T09:13:28.066Z","comments":true,"path":"2019/05/31/（软考架构师笔记十）设计模式/","link":"","permalink":"http://www.yiyuclub.club/2019/05/31/（软考架构师笔记十）设计模式/","excerpt":"（软考架构师笔记十）设计模式","text":"（软考架构师笔记十）设计模式 1.概念 对被用来在特定场景下解决一般设计问题的类和互相通信的对象的描述（某一问题通用的解决方案） 学习注意两点： 学习这些模式是一个方面，另一方面更要了解模式中的思想设计模式虽然可以使设计变得更精妙，但滥用设计模式会适得其反 2.设计模式组成 模式名称（Pattern name）问题（Problem）解决方案（Solution）效果（Consequence） 3.GoF设计模式(23种) 1.Factory Method 模式（创建型）2.Abstract Factory 模式（创建型）3.Builder 模式（创建型）4.Prototype 模式（创建型）5.Singleton 模式（创建型）6.Adapter 模式（结构型）7.Bridge 模式（结构型）8.Composite 模式（结构型）9.Decorator 模式（结构型）10.Facade 模式（结构型）11.Flyweight 模式（结构型）12.Proxy 模式（结构型）13.Interpreter 模式（行为型）14.Template Method 模式（行为型）15.Chain of Responsibility 模式（行为型）16.Command 模式（行为型）17.Iterator 模式（行为型）18.Mediator 模式（行为型）19.Memento 模式（行为型）20.Observer 模式（行为型）21.State 模式（行为型）22.Strategy 模式（行为型）23.Visitor 模式（行为型） 4.其他设计模式 1.Intercepting Filter 模式2.Session Facade 模式 5.设计模式分类 1.创建型：解决对象创建的问题2.结构型：解决对象的结构复杂问题3.行为型：解决对象状态改变而改变行为的问题","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.yiyuclub.club/categories/学习笔记/"},{"name":"软考架构师","slug":"学习笔记/软考架构师","permalink":"http://www.yiyuclub.club/categories/学习笔记/软考架构师/"}],"tags":[{"name":"软考","slug":"软考","permalink":"http://www.yiyuclub.club/tags/软考/"},{"name":"架构师","slug":"架构师","permalink":"http://www.yiyuclub.club/tags/架构师/"}]},{"title":"（软考架构师笔记九）软件架构设计","slug":"（软考架构师笔记九）软件架构设计","date":"2019-05-27T01:47:21.000Z","updated":"2019-06-24T09:13:28.050Z","comments":true,"path":"2019/05/27/（软考架构师笔记九）软件架构设计/","link":"","permalink":"http://www.yiyuclub.club/2019/05/27/（软考架构师笔记九）软件架构设计/","excerpt":"（软考架构师笔记九）软件架构设计","text":"（软考架构师笔记九）软件架构设计 1.概述 架构是对系统的抽象，它通过描述元素、元素的外部可见属性及元素之间的关系来反映这种抽象架构由多个结构组成任何软件都存在架构，但不一定有对该架构的具体表述文档元素及其行为的集合构成架构的内容架构具有“基础”性架构隐含有“决策”，即架构是由架构设计师根据关键的功能和非功能性需求（质量属性及项目相关的约束）进行设计与决策的结果 （1）软件至于商业背景的重要： 影响架构的因素架构对上述诸因素具有反作用 （2）软件架构的重要性 项目关系人之间交流的平台早期设计决策在较高层面上实现软件复用架构对开发的指导与规范意义不容忽略 （3）架构的模型 结构模型框架模型动态模型过程模型功能模型4+1视图模型 4+1视图模型： 逻辑视图：系统提供给最终用户的服务开发视图：软件模块的组织和管理进程视图：非功能性的需求(性能和可用性)物理视图：解决系统拓扑结、系统安装、通信场景：帮助设计者找到架构的构件和它们之间的作用关系 逻辑视图和开发视图描述系统的静态结构，而进程视图和物理视图描述系统的动态结构 2.架构需求与软件质量属性（1）定义： 软件属性包括功能属性和质量属性，架构师着重关注质量 （2）软件质量属性《GB/T16260-1996(idt ISO／IEC9126：1991)信息技术软件产品评价质量特性及其使用指南》中描述的软件质量特性包括： 功能性：适合性、准确性、互操作性、依从性、安全性可靠性：成熟性、容错性、易恢复性易用性：易理解性、易学性、易操作性效率：时间特性、资源特性可维护性：易分析性、易改变性、稳定性、易测试性可移植性：适应性、易安装性、遵循性、易替换性； ① 运行期质量属性 性能：性能是指软件系统及时提供相应服务的能力。包括速度、吞吐量和持续高速性三方面的要求安全性：指软件系统同时兼顾向合法用户提供服务，以及阻止非授权使用的能力。易用性：指软件系统易于被使用的程度。可伸缩性：指当用户数和数据量增加时，软件系统维持高服务质量的能力。例如，通过增加服务器来提高能力。互操作性：指本软件系统与其他系统交换数据和相互调用服务的难易程度。可靠性：软件系统在一定的时间内无故障运行的能力。持续可用性：指系统长时间无故障运行的能力。与可靠性相关联，常将其纳入可靠性中。鲁棒性：是指软件系统在一些非正常情况（如用户进行了非法操作、相关的软硬件系统发生了故障等）下仍能够正常运行的能力。也称健壮性或容错性。 ② 开发期质量属性 易理解性：指设计被开发人员理解的难易程度。可扩展性：软件因适应新需求或需求变化而增加新功能的能力。也称为灵活性。可重用性：指重用软件系统或某一部分的难易程度。可测试性：对软件测试以证明其满足需求规范的难易程度。可维护性：当需要修改缺陷、增加功能、提高质量属性时，定位修改点并实施修改的难易程度；可移植性：将软件系统从一个运行环境转移到另一个不同的运行环境的难易程度。 （3）6个质量属性 可用性可修改性性能安全性可测试性易用性 3.软件架构风格（1）目的： 重复的软件架构模式，即能否达到架构级别的软件重用 （2）定义： 描述某一特定应用领域中系统组织方式的惯用模式（idiomatic paradigm） （3）架构风格分类 数据流风格：批处理序列；管道/过滤器调用/返回风格：主程序/子程序；面向对象风格；层次结构独立构件风格：进程通信；事件系统虚拟机风格：解释器；基于规则的系统仓库风格：数据库系统；超文本系统；黑板系统 （4）数据流风格① 定义： 过程像流水线一般，数据经过序列间的数据处理组件进行处理，然后将处理结果向后传送，最后进行输出 ② 批处理序列 过程分许多步，每一步都是独立的整体且顺序执行（以整体的方式传递）–（经典数据处理、程序开发、windows的bat程序） ③ 管道和过滤器 输入，对输入流进行处理（变换及增量），输出(在输入的过程中就有可能有输出)，过滤器之间透明 （5）调用/ 返回风格① 定义： 在系统中采用了调用与返回机制 ② 主程序/子程序 单线程控制，构件置为主程序和子程序，通过交互的方式进行处理 ③ 面向对象风格 构件设为对象，通过函数或方法的调用进行交互 特征： 对象处理自己的完整性对象对其他对象无透明性 ③ 层次结构风格 层析结构，分层处理，层与层之间交互实现数据交互 优点：支持抽象递增、功能增强、可重用缺点：分层困难，层难以抽象化 （6）独立构件风格① 定义： 构件设为独立个体，之间不通信 ② 进程通信：通过连接件交互 ③ 事件系统风格：触发广播或事件 （7）虚拟机风格① 定义： 构件虚拟环境，解析自定义语言 ② 解释器：存储区、工作状态数据结构、工作进度数据结构 ③ 规则：规则集、规则解释器、规则/数据选择器及工作内存 （8）仓库风格① 定义：中央数据结构（状态）、独立构件（存储）、 ② 数据库 ③ 超文本 ④ 黑板 4.层析系统架构风格（1）二/三层 C/S架构 ① 二层：服务器和客户机（服务器压力大、数据安全性不高） ② 三层： 表示层：用户界面功能层：处理业务逻辑数据层：数据管理 （2）B/S架构 ① 定义：浏览器、WEB服务器、数据库服务器（已浏览器形式，应用程序储存于服务器，输入地址即可） （3）MVC架构风格 ① 定义：模型(model)、视图(view)、控制器(controller) ② 分工： 模型：应用和业务的封装视图：用户界面控制器：数据交互 （4）MVP架构风格 ① 定义： Model：提供数据View：负责显示Controller/Presenter：负责逻辑的处理 与mvc区别： model与view不直接交互，而是在Presenter中进行 （5）面向服务的架构（SOA） ① 定义：是一种在计算环境中设计、开发、部署和管理离散逻辑单元（服务）模型的方法，功能设为独立的服务，服务之间通过交互完成整个逻辑（松耦合） ② 设计原则 明确定义的接口自包含和模块化粗粒度(数量不宜过多)松耦合互操作性 ③ 服务构件（SCA）与传统构件定义：简化SOA的开发，提出构建粗粒度进制 （6）SOA关键技术 ① UDDI(统一描述、发现和集成)： 提供了一种服务发布、查找和定位的方法，是服务的信息注册规范，以便被需要该服务的用户发现和使用它（也统一了编程接口） 技术规范： 数据模型：XMLAPI：基于SOAP注册服务 ② WSDL（Web服务描述语言） 定义： 是对服务进行描述的语言，它有一套基于 XML 的语法定义。WSDL 描述的重点是服务，它包含服务实现定义和服务接口定义,提高系统的扩展性，描述了给定服务提供者如何实现特定的服务接口 ③ SOAP（简单对象访问协议） 定义：定义了服务请求者和服务提供者之间的消息传输规范用，XML来格式化消息，用HTTP来承载消息。可以在网络中进行数据交换和远程过程调用，从发送端到接收端的单向传输 SOAP四部分： 封装：封装整体框架，指明包含的内容编码规则：用于交换系统所定义的数据类型的实例RPC表示：定义远程过程调用和应答的协议绑定：定定义了一个使用底层传输协议来完成在节点之间交换 SOAP 封装的约定 ④ REST（表述性状态转移）定义：是一种只使用 HTTP 和 XML 进行基于 Web 通信的技术，可以降低开发的复杂性，提高系统的可伸缩性 概念和准则： 网络上的所有事物都被抽象为资源每个资源对应一个唯一的资源标识通过通用的连接件接口对资源进行操作对资源的各种操作不会改变资源标识所有的操作都是无状态的 （7）SOA主流实现方式① Web Service 角色： 服务提供者：服务提供者是服务的所有者，该角色负责定义并实现服务（WSDL）服务请求者：服务请求者是服务的使用者，查找、绑定并调用服务，或与服务进行交互的应用程序服务注册中心：连接服务提供者和服务请求者的纽带，提供者在此发布，请求者在此寻找 操作： 发布：发布服务描述查找：检索服务描述或在服务注册中心查询所要求的服务类型绑定：动态绑定（提供者在通过注册中心与请求者交互），静态绑定（提供者已与请求者通过文件或其他方式绑定） 层次： 底层传输层：负责消息的传输机制（HTTP）服务通信协议层：描述并定义服务之间进行消息传递所需的技术标准（soap,rest）服务描述层：描述服务的接口与消息交换方式（WSDL）服务层:将遗留系统进行包装，并通过发布的 WSDL 接口描述被定位和调用业务流程层:支持服务发现，服务调用和点到点的服务调用，并将业务流程从服务的底层调用抽象出来服务注册层:使服务提供者能够通过 WSDL 发布服务定义，并支持服务请求者查找所需的服务信息(UDDI) ② 服务注册表 服务注册服务位置服务绑定 ③ 企业服务总线定义：是由中间件技术实现并支持 SOA 的一组基础架构,其功能： 支持异构环境中的服务、消息和基于事件的交互，并且具有适当的服务级别和可管理性无侵入式ESB与服务逻辑分离提供服务代理和协议转换提供可配置的消息转换翻译机制和基于消息内容的消息路由服务，传输消息到不同的目的地提供安全和拥有者机制 （8）微服务 ① 定义：是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值 ② 优势： 技术异构性：每个服务独立，都可以使用不同的技术弹性：每个服务可使用自己的解决方案扩展：扩展性强简化部署：每个服务独立部署与结织结构相匹配可组织性：对外提供接口可代替性优化：可方便重写服务或删除服务 ③ 劣势： 复杂成本高部署麻烦组织结构要求高依赖测试依赖管理 5.架构设计（1）演变交付生命周期 （2）属性驱动设计法（ADD） ① 定义：将分解过程建立在软件必须满足的质量属性之上 ② 输入：功能需求（一般表示为用例）、限制条件和质量需求（一组特定于系统的质量场景） ③ 步骤： 选择要分解的模块根据如下步骤对模块进行求精：从具体的质量场景和功能需求集合中选择架构驱动因素-&gt;选择满足架构驱动因素的架构模式-&gt;实例化模块并根据用例分配功能-&gt;定义子模块的接口-&gt;验证用例和质量场景，并对其进行求精对需要进一步分解的每个模块重复上述步骤 （3）按架构组织开发团队 （4）开发骨架系统 （5）利用商用构件进行开发 6.软件架构文档化（1）两方面： 过程：促使架构设计师进一步思考结果：作为架构开发的成果，供项目关系人使用 （2）文档使用者：架构的项目关系人 （3）文档编写规则 从读者的角度编写文档避免出现不必要的重复避免歧义使用标准结构记录基本原理使文档保持更新，但更新频率不要过高针对目标的适宜性对文档进行评审 （4）视图编档 定义：为架构设计师提供了进行软件架构编档的基本原则 7部分： 视图概述：对系统主要元素和元素之间的关系进行概述（图形、文档、表格）元素目录：对元素及其属性、关系及其属性、元素接口、元素行为进行详细描述上下文图：用图形描述系统与环境的关系可变性指南：架构的变化点架构背景：提供理论依据术语表：对每个术语进行说明其他信息：不属于架构的信息 （5）跨视图文档应具有内容： 有哪些内容，如何组织架构描述基本原理 （6）UML （7）软件架构重构 ① 什么情况使用：系统已存在但不知文档与其架构 ② 活动组成： 信息提取数据库构造视图融合重构 7.软件架构评估（1）评估方法 基于调查问卷或检查表的方式基于场景的方式:通过分析软件架构对场景的支持判断基于度量的方式 （2）权衡分析法（ATAM）① 好处：能够揭示架构如何满足特定的质量需求（例如，性能和可修改性），而且还提供了分析这些质量需求之间交互作用的方法 ② 目的：理解架构设计满足系统质量需求的结果 ③ 产生结果： 架构表述简洁业务目标清晰用场景集合捕获质量需求架构决策到质量需求的映射确定的敏感点和权衡点集合有风险决策和无风险决策风险主题的集合产生一些附属结果还产生一些无形结果 ④ 步骤： ATAM方法介绍商业动机介绍架构介绍架构方法分类生成质量属性效用树分析架构方法集体讨论并确定场景的优先级分析架构方法结果介绍 （3）成本效益分析法 步骤： 整理场景对场景进行求精确定场景的优先级分配效用形成相关的策略—场景—响应级别的对应关系使用内插法确定“期望的”质量属性响应级别的效用计算各架构策略的总收益选择架构策略 8.构件及其复用（1）目的：提高企业开发效率 （2）商用构件标准规范 ① CORBA 三层次： 对象请求代理公共对象服务公共设施 3项内容： 抽象构件模型构件容器结构构件的配置和打包规范 ② J2EE ③ DNA 2000 9.产品线的演化 10.软件架构图（1）软件视图分类 模块视图类型：为系统的主要模块实现单元编档构件和连接件视图类型：为系统的构件和连接件执行单元编档配视图类型：为软件的开发和执行环境之间的关系编档。 （2）模块视图类型及其风格 ① 视图类型 ② 模块分解风格 ③ 模块使用风格 ④ 模块分层风格 ⑤ 泛化风格 （3）C&amp;C视图类型及其风格（略） （4）分配视图类型及其风格（略）","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.yiyuclub.club/categories/学习笔记/"},{"name":"软考架构师","slug":"学习笔记/软考架构师","permalink":"http://www.yiyuclub.club/categories/学习笔记/软考架构师/"}],"tags":[{"name":"软考","slug":"软考","permalink":"http://www.yiyuclub.club/tags/软考/"},{"name":"架构师","slug":"架构师","permalink":"http://www.yiyuclub.club/tags/架构师/"}]},{"title":"（软考架构师笔记八）系统的分析和设计","slug":"（软考架构师笔记八）系统的分析和设计","date":"2019-05-23T01:21:38.000Z","updated":"2019-06-24T09:13:28.066Z","comments":true,"path":"2019/05/23/（软考架构师笔记八）系统的分析和设计/","link":"","permalink":"http://www.yiyuclub.club/2019/05/23/（软考架构师笔记八）系统的分析和设计/","excerpt":"（软考架构师笔记八）系统的分析和设计","text":"（软考架构师笔记八）系统的分析和设计 1.概念 系统目的：解决问题定义问题：理解真实世界中的问题和用户的需要，并提出满足这些需要的解决方案的过程 2.问题分析（1）目标 在开发之前对要解决的问题有一个更透彻的理解 （2）实现步骤 在问题定义上达成共识:按UP标准格式写出理解问题的本质：可使用因果鱼骨图和帕累托图确定项目干系人和用户：了解用户和其他相关的项目干系人定义系统的边界：解决方案系统和现实世界之间的边界（上下文范围图、用例模型）确定系统实现的约束：各种因素的存在，会对解决方案的选择造成一定的限制 3.问题定义（1）目标① 定义： 它是构建系统的原因，是最高层次的用户需求，是业务上的需要，而功能、性能需求则必须是以某种形式对该目标做出贡献。 ② 注意方面： 优势度量合理性可行性可达成性 （2）功能需求 ① 定义： 指明系统必须做的事情(为了完成他们某部分的工作而必须做的事情) ② 二义性主要体现： 同名异义的词代词 解决方法：一种有效的方法是大声地朗读出来，大家一起边听边进行讨论，这样可以不断地优化 （3）非功能需求 ① 定义： 系统必须具备的属性，不改变产品的功能，它是为工作赋予特征的 ② 特征： 观感需求易用性需求性能需求可操作性需求可维护性和可移植性需求安全性需求文化和政策需求法律需求 4.需求分析与软件设计（1）需求分析的任务与过程（做什么） ① 定义： 需求分析主要是确定待开发软件的功能、性能、数据、界面等要求 ② 步骤： 获取当前系统的物理模型抽象出当前系统的逻辑模型建立目标系统的逻辑模型 ③ 4方面： 问题识别：发现需求、描述需求分析和综合：问题分析、整合方案编制需求分析的文档：对已经确定的需求进行文档化描述，规格需求说明书需求分析与评审：对功能的正确性、完整性和清晰性，以及其他需求给予评价 （2）需求分类 功能需求：系统必须完成的动作非功能需求：产品必须具备的属性或品质设计约束：对方案的约束说明 业务需求：反映组织机构或客户对系统、产品高层次的目标要求用户需求：描述用户使用产品必须要完成什么任务，怎么完成的需求系统需求：系统的角度来说明软件的需求 （3）需求工程① 定义： 创建和维护系统需求文档所必需的一切活动的过程 ② 需求开发：需求捕获、需求分析、编写规格说明书和需求验证 4 个阶段 ③ 需求管理：求基线、处理需求变更、需求跟踪等方面的工作 （4）需求分析方法 结构化分析方法： 软系统方法： 面向对象分析方法（OOA） 面向问题域的分析（PDOA） （5）如何进行系统设计 组件的独立性。审视自己设计的系统，是否做到了高内聚、低耦合？例外的识别和处理。谁能保证系统使用者都精确按照使用说明书使用？防错和容错。当网络中断、数据库崩溃这样的灾难性事件发生时，系统也跟着崩溃吗？ （6）软件设计的任务与活动 ① 软件设计步骤 概要设计（高层设计）：将软件需求转化为数据结构和软件的系统结构详细设计（底层设计）：对结构表示进行细化，得到详细的数据结构与算法 ② 主要的设计方法比较 流的设计方法还包括 Jackson 方法和 Parnas 方法。但近年来，对象技术凭借其对数据的高效封装及良好的消息机制，实现了高内聚、低耦合的系统设计，成了现代软件设计的主流方法学 （7）结构化分析与设计 ① 定义：利用数据流图来帮助人们理解问题，对问题进行分析，其面向过程 ② 结构化分析工具 数据流图（DFD）数据字典（DD）结构化语言判定表判定树 ③ 结构化分析的工作步骤： 研究“物质环境”建立系统逻辑模型划清人机界限 ④ 数据流图： DFD 是一种图形化的系统模型，它在一张图中展示信息系统的主要需求，即输入、输出、处理（过程）、数据存储 过程：也称为加工，一步步地执行指令，完成输入到输出的转换。外部实体：也称为源/宿，系统之外的数据源或目的。数据存储：也称为文件，存放数据的地方，一般是以文件、数据库等形式出现。数据流：从一处到另一处的数据流向，如从输入或输出到一个过程的数据流。实时连接：当过程执行时，外部实体与过程之间的来回通信。 数据流图的层次 先描述最高层次的数据流图，再分解成低层次、详细的数据流图，以此份接下去，直至详细清晰 Context图（系统上下文范围关系图） 描述最高层次的数据流图，整个待开发的系统表示为一个过程，将所有的外部实体和进出系统的数据流都画在一张图中 逐级分解 经过2步骤后可在进行分解 如何画数据流图 画系统的输入和输出画数据流图的内部为每一个数据流命名为加工命名不考虑初始化和终点，暂不考虑出错路径等细节，不画控制流和控制信息 ⑤ 细化数据流图组件 结构化分析方法还引入了数据字典、结构化语言及决 策树、决策表等方法,能对数据流图中描述不够清晰的地方进行有效的补充 数据字典：一种很实用、有效的表达数据格式的手段，它是对所有与系统相关的 数据元素的一个有组织的列表和精确严格的定义，使得用户和系统分析员对于输入、输出、 存储成分和中间计算机有共同的理解 （8）结构化设计 结构化设计包括架构设计、接口设计、数据设计和过程设计等任务。它是一种面向数据流的设计方法，是以结构化分析阶段所产生的成果为基础，进一步自顶而下、逐步求精和模块化的过程 ① 概要设计与详细设计的主要任务 概要设计主要任务：设计软件的结构、确定系统是由哪些模块组成，以及每个模块之间的关系 概要设计过程：复查基本系统模型、复查并精化数据流图、确定数据流图的信息流类型（包括交换流和事务流）、根据流类型分别实施变换分析或事务分析、根据软件设计原则对得到的软件结构图进一步优化 – 详细设计阶段主要任务：确定应该如何具体地实现所要求的系统，得出对目标系统的精确描述 ② 结构图 基本组成: 模块调用（模块之间的调用关系）数据（模块间传递及处理数据信息） 对数据流图的划分: 变换流：信息首先沿着输入通路进入系统，并将其转换为内部表示，然后通过变换中心（加工）的处理，再沿着输出转换为外部形式离开系统事务流：信息首先沿着输入通路进入系统，事务中心根据输入信息的类型在若干个动作序列（活动流）中选择一个执行 程序流程图和盒图 程序流程图和盒图作用：用来描述程序的细节逻辑的程序流程图特点：简单、直观、易学程序流程图缺点：容易成为非结构化的流程图（盒图可解决）盒图特点：功能域明确、无法任意转移控制、容易确定全局数据和局部数据的作用域、容易表示嵌套关系、可以表示模块的层次结构盒图缺点：修改相对比较困难 PAD 和 PDL： PAD 是问题分析图的缩写，它符合自顶向下、逐步求精的原则，也符合结构化程序设计的思想，它最大的特点在于能够很方便地转换为程序语言的源程序代码。 PDL 则是语言描述工具的缩写，它和高级程序语言很相似，也包括数据说明部分和过程部分，还可以带注解等成分，但它是不可执行的。PDL 是一种形式化语言，其控制结构的描述是确定的，但内部的描述语法是不确定的。PDL 通常也被称为伪码。 （9）模块设计定义： 将一个待开发的软件分解成为若干个小的简单部分——模块，每个模块可以独立地开发、测试,程序的结构清晰、易于测试与修改 操作方式： 将模块的接口和功能定义为其外部特性，将模块的局部数据和实现该模块的程序代码称为内部特性 原则： 信息隐蔽：每个程序的成分隐蔽或封装在一个单一的设计模块中，并且尽可能少地暴露其内部的处理模块独立：每个模块完成一个相对独立的特定子功能，并且与其他模块之间的联系最简单 内聚类型： 耦合类型 5.面向对象的分析与设计（1）对象和类： 对象：对象是系统中用来描述客观事物的一个实体类：对具有相同属性和服务的一个或一组对象的抽象（实体类、控制类、边界类） （2）继承与泛化 继承：说明特殊类（子类）与一般类（父类）的关系泛化：说明一般类与特殊类的关系 （3）多态与重载 多台：一般类中定义的属性或服务被特殊类继承后，可以具有不同的数据类型或表现出不同的行为重载与重写：多态的表现。 （4）模板类 一个类属类是关于一组类的一个特性抽象 （5）消息和消息通信 消息：向对象发出的服务请求消息通信：面向对象方法学中的一个重要原则 （6）面向对象分析（OOA） ① 定义：开发一系列模型，这些模型描述计算机软件，当它工作时以满足一组客户定义的需求 ② OOA/OOD方法： 包括主题、对象类、结构、属性和服务 5 个层次,需经过标识对象类、标识结构与关联（包括继承、聚合、组合、实例化等）、划分主题、定义属性、定义服务 5 个步骤来完成整个分析工作,它由人机交互部件、问题域部件、任务管理部件、数据管理部件 4 个部分组成 ③ Booch方法： 开发过程是一个迭代的、渐进式的系统开发过程，它可以分为宏过程和微过程两类.宏过程用于控制微过程，是覆盖几个月或几周所进行的活动，它包括负责建立核心需求的概念化，为所期望的行为建立模型的分析，建立架构的设计，形成实现的进化，以及管理软件交付使用的维护等 5 个主要活动微过程:基本上代表了开发人员的日常活动 ③ OMT方法： 对象建模方法，主要用于分析、系统设计和对象设计 ④ OOSE方法 在 OMT 的基础上，对功能模型进行了补充,提出了用例的概念 （7）统一建模语言（）UML定义: 系统的可视化建模语言,OMT、OOSE 和 Booch 方法中的建模语言和方法有机地融合在一起，是国际统一的软件建模标准。一种可视化语言,一种可用于详细描述的语言，一种构造语言，一种文档化语言。 结构： 构造块：构造块也就是基本的 UML 建模元素（事物）、关系和图公共机制：指达到特定目标的公共 UML 方法，主要包括规格说明、修饰、公共分类和扩展机制架构：逻辑、进程、实现、部署、用例视图 用例图： ① 参与者：与系统接口的任何事物或人② 用例：对系统行为的动态描述③ 包含与扩展 类图和对象图 6.用户界面设计（1）设计原则： 置用户于控制之下减少用户的记忆负担保持界面的一致用户熟悉意外最小化可恢复用户指南用户差异性 （2）设计过程 用户、任务和环境分析：着重于分析将和系统交互的用户的特点界面设计:为每个目标或意图制定特定的动作序列，按在界面上执行的方式对动作序列进行规约实现：根据界面设计进行实现界面确认：进行一些定性和定量的数据收集，以进行界面的评估，以调整界面的设计 （3）工作流设计 工作流：工作流是一类能够完全或者部分自动执行的经营过程，根据一系列过程规则、文档、信息或任务在不同的执行者之间传递、执行 流程定义：定义过程运行中的活动和所涉及的各种信息流程实例（工作）：一个流程定义的运行实例工作流管理系统：这个程序存储流程的定义，按照所使用的流程定义来触发流程状态的改变，推动流程的运转 流程定义工具：这个软件和工作流管理系统的关系就如同数据库设计工具和数据库管理系统的关系一样。参与者：参加工作的主体活动：是流程定义中的一个元素活动所有者：参与者之一工作所有者：是有权整体控制流程实例执行过程的参与工作项：流程实例中活动的参与者将要执行的工作 （4）工作流管理系统 定义：是一种“在工作流形式化表示的驱动下，通过软件的执行而完成工作流定义、管理及执行的系统”目的：对业务过程中各活动发生的先后次序及与活动相关的相应人力或信息资源的调用进行管理，而实现业务过程的自动化 6个基本模块参考模型 流程定义工具工作流执行服务其他工作流执行服务客户应用程序被调用应用程序管理和监控工具 7.简单分布式计算机应用系统的设计 基于实例的协作基于服务的协作 8.系统运行环境的集成与设计（1）集中式系统 单计算机结构集群机构多计算机结构 （2）分布式系统（3）C/S 结构（4）多层结构（5）Internet、Intranet 和 Extranet 7.系统过渡计划（1）遇到问题 开销大风险大遇到问题的措施不利因素人员培训. （2）过渡方案： 直接过渡：当新系统运行时，立即关闭原来的系统并行过渡：，让新系统和旧系统在一段时间里同时运行，通过这样的旧系统作为新系统的备份，可以大大降低系统过渡的风险 阶段过渡:系统复杂无法一次过度，设计一系列步骤和过程来完成整个系统的过渡","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.yiyuclub.club/categories/学习笔记/"},{"name":"软考架构师","slug":"学习笔记/软考架构师","permalink":"http://www.yiyuclub.club/categories/学习笔记/软考架构师/"}],"tags":[{"name":"软考","slug":"软考","permalink":"http://www.yiyuclub.club/tags/软考/"},{"name":"架构师","slug":"架构师","permalink":"http://www.yiyuclub.club/tags/架构师/"}]},{"title":"（软考架构师笔记七）系统规划","slug":"（软考架构师笔记七）系统规划","date":"2019-05-23T00:10:19.000Z","updated":"2019-09-30T07:39:44.702Z","comments":true,"path":"2019/05/23/（软考架构师笔记七）系统规划/","link":"","permalink":"http://www.yiyuclub.club/2019/05/23/（软考架构师笔记七）系统规划/","excerpt":"（软考架构师笔记七）系统规划","text":"（软考架构师笔记七）系统规划 1.概念 用于描述从项目提出、选择到确立的过程，包括系统项目的提出与可行性分析，系统方案的制订、评价和改进，新旧系统的分析和比较，以及现有软件、硬件和数据资源的有效利用等问题 2.项目提出与选择（1）定义： 根据这些动机，提出和确定信息系统的工作范围，确定项目立项，提出系统选择方案，给出选择结果 （2）立项动机： 进行基础研究并获取技术进行应用研发并获得产品提供技术服务信息技术产品的使用者 （3）项目选择方向① 选择有核心价值的产品/项目或开发方向 生产制造业：面向订单的生产（ERP,MIS）金融行业：数据业务系统与风险评控系统教育行业：与教育有关的系统，如电子图书馆 ② 评估项目风险、收益和代价 在判断出一个潜在的软件项目后，还应评估项目实施的风险、收益和维护付出的代价 ③ 评估项目的多种实施方式 项目决定实施后，由项目的负责人和企业中高层经理进行决策，决策结果决定了项目的实施优先级及具体的实施方式 ④ 平衡地选择适合的方案问题： 新技术风险大无快速开发平台的产品时间开销大不考虑业务扩展的情况下修改需求会导致之前实施的受阻价格低的产品往往不尽人意 （4）项目选择结果① 最终结果以产品/项目建议书形式体现，场景： 在投标项目中，产品/项目建议书通常是乙方提交给甲方竞标方案的一部分企业单位在确立了要开发某类型产品后，对该产品进行多角度的评估，最终项目立项人向上级提交供决策的建议报告的主要内容就是“产品/项目建议书” ② 项目建议书包含： 用户单位、项目或产品的立项背景、需求来源和目标性的介绍；用户的内外部环境、组织机构、现有的 IT 设施情况等；用户的业务模型和业务规划；预期要建设的技术系统在用户业务中的位置和作用；信息化后的用户业务模型、软件应用方式、相关的部署环境、运行规则、管理规范等；为实现信息化业务模型，技术系统的产品需求定义（功能、性能、约束）和部署方式等；产品或项目的技术框架；项目的要点、技术难点、主要实施障碍等；项目或产品的可行性研究结果；项目可选择的实施方式、组织方式、沟通和协调机制等；项目的资源范围和预算（人、财、物、时间等）；项目的成本/收益分析； 项目风险及影响评估；项目进度计划；项目质量计划；项目过渡期资金的获得方式、财务计划；产品或项目的商务模式、盈利模式论述；同类产品或公司的市场调查结果，以及竞争性比较；企业成功案例、资质等；商务条款或供应商/客户合同； 3.可行性研究与效益分析（1）研究内容： 经济可行性：收益分析技术可行性：技术、资源、目标法律可行性执行可行性（操作可行性）：评估预期的软件系统在真实环境中能够被应用的程度和实施过程中障碍方案的选择 （2）效益分析① 目的： 对项目开发目标的成本及可度量的项目现金收入和无形收益进行一次专门化的评估 ② 项目成本： 基础建设支出一次性支出：如咨询费、管理费 ③ 项目收益： 一次性收益：支出的减少，价值的提升非一次性收益：按时间段获取的收益或按时间端减少的支出不可定量的收益：无法直接用人民币表示的收益（如公司形象提升） ④ 效益分析指标： 收益/投资比：软件项目实施后整个系统生命期的收益/投资比值投资回收周期：收益的累计数开始超过支出的累计数的时间敏感性分析：系统生命期长度、系统的工作负荷量、工作负荷的类型、处理速度、设备和软件的配置等 （3）可行性分析报告其报告必具备的内容： 项目背景：包括问题描述、实现环境和限制条件管理概要和建议：包括重要的研究结果、说明、建议和影响候选方案：包括候选系统的配置和最终方案的选择标准系统描述：包括系统工作范围的简要说明和被分配系统元素的可行性经济可行性（成本/效益分析）：包括经费概算和预期的经济效益技术可行性（技术风险评价）：包括技术实力、已有工作基础和设备条件法律可行性：包括系统开发可能导致的侵权，违法和责任等用户使用可行性：包括用户单位的行政管理，工作制度和使用人员的素质其他与项目有关的问题：例如，其他方案介绍和未来可能的变化 4.方案的制订和改进（1）系统方案制定的主要内容 ① 确定软件架构： 分析模型的结构一些对应于系统目标的最基本、最重要的实现要素特性和要点的解释 ② 关键性要素和实现手段关键性的实现： 关键的用例、最主要的控制类、功能和服务的首要组织方式（例如网站首页）；对象的组织模式；常用和最关键的实现算法模型。关键性的实现手段通常包括：选定基础计算平台，如操作系统、数据库、Web 服务器、中间件平台等；选定开发工具和开发环境，如计算机语言、构件库、工具软件等 ③ 归结目标到最适合的计算体系 表示层：用户的界面部分,前端界面事务逻辑层：业务层，接受和返回数据给用户数据服务层：数据持久层 5.新旧系统的分析和比较（1）遗留系统（老系统）特点： 能正常工作，但不满足要求系统性能落后技术过时大型系统已融入企业业务中，维护困难无文档，未使用现在工程方法开发，难理解 （2）遗留系统评价方法：① 目的：为了获得对遗留系统更好的理解 ② 评价方法组成 启动评价：遗留系统是否还是重要的；企业的目标是什么；需求是什么；系统寿命多久；系统技术如何；企业是否同意改变；企业是否能承受改变。 商业价值评价：概要级评价（咨询、评级问卷、进行评价）和详细级别评价 ③ 外部环境： 硬件支撑软件企业基础设施 ④ 评价级别 系统级。把整个系统看作是不可分的原子，评价时不考虑系统的任何部分部件级。关注系统的每个子系统，考虑每个子系统的特征，包括复杂性、数据、文档、外部依赖性、合法性、维护记录、大小、安全性等 ⑤ 分析评价结果评价活动将产生硬件、支撑软件、企业基础设施和应用软件的特征值矩阵，这些特征值体现了遗留系统当前的技术因素，其加权平均值代表了系统的技术水平。 OR=(P1ORH+P2ORS+P3OAF+ P4ORA)/4 ORH 是硬件的评价值，ORS 是支撑软件的评价值，ORF 是企业基础设施的评价值，ORA 是应用软件的评价值，Pi (1 i 4) 分别是它们的权系数，即第 i 个评价值对遗留系统的影响因子 评价结果： （3）遗留系统的演化策略（根据上图判断）① 淘汰策略：第三象区② 继承策略：第四象区③ 改造策略：第一象区④ 集成策略：第二象区","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.yiyuclub.club/categories/学习笔记/"},{"name":"软考架构师","slug":"学习笔记/软考架构师","permalink":"http://www.yiyuclub.club/categories/学习笔记/软考架构师/"}],"tags":[{"name":"软考","slug":"软考","permalink":"http://www.yiyuclub.club/tags/软考/"},{"name":"架构师","slug":"架构师","permalink":"http://www.yiyuclub.club/tags/架构师/"}]},{"title":"（软考架构师笔记六）开发方法","slug":"（软考架构师笔记六）开发方法","date":"2019-05-22T01:56:08.000Z","updated":"2019-09-30T03:17:50.639Z","comments":true,"path":"2019/05/22/（软考架构师笔记六）开发方法/","link":"","permalink":"http://www.yiyuclub.club/2019/05/22/（软考架构师笔记六）开发方法/","excerpt":"（软考架构师笔记六）开发方法","text":"（软考架构师笔记六）开发方法 1.软件生命周期（1）定义：软件自开始构思与研发到不再使用而消亡的过程 （2）生命周期阶段：1.可行性研究与计划 通过可行性研究，来确定开发此软件的必要性，并根据可行性研究的结果初步确定软件的目标、范围、风险、开发成本等内容《可行性研究报告》和《软件开发计划》 2.需求分析 对软件的需求进行细致的分析，来确定软件要做成什么 3.概要设计 确定系统架构、各子系统间的关系、接口规约、数据库模型、编码规范等内容概要设计的结果将作为程序员的工作指南 4.详细设计（非必须） 详细设计在概要设计的基础上，进行细化非必须阶段，有时只会对部分关键模块进行详细设计 5.实现 编码和单元测试 6.集成测试(组装测试) 7.确认测试 验证软件是否同需求一致， 8.使用和维护 须不断地对软件进行维护，修正软件中的缺陷，修改软件中已经不能适应最新情况的功能或者增加新的功能贯穿整个软件的使用过程 2.软件开发模型（1）瀑布模型定义： 软件开发是一个阶段化的精确的过程,要经过需求分析、总体设计、详细设计、编码、调试、集成测试和系统测试阶段才能够被准确地实现,在软件开发中当在后续阶段发现缺陷的时候，可以把这个缺陷反馈到上一阶段进行修正,如图： 特点 阶段明确，阶段间有明确分界线有固定的文档或源程序流入下一阶段(是面向文档的软件开发模型)适用于需求明确、稳定时，可以采用瀑布模型按部就班地开发软件 缺陷：当软件需求不明确或变动剧烈时，成后期修改代价太大，难以控制开发的风险 （2）瀑布V模型 定义：同标准瀑布模型，在每一阶段加入了测试功能，即每阶段结果指向测试 缺点： 需求分析阶有偏差，对后续影响大每阶段依赖上阶段，如后续需求变化，需重新开始瀑布模型只有在所有阶段完成后客户才能看到结果，时间久文档驱动型的瀑布模型文档冗余，大多对客户无用 （3）演化模型 演化模型可以看做若干次瀑布模型的迭代，当完成一个瀑布模型后，重新进入下一个迭代周期，软件在这样的迭代过程中得以演化、完善根据不同的迭代特点，演化模型可以演变为螺旋模型、增量模型和原型法开发 （4）螺旋模型定义： 结合了瀑布模型和演化模型，每一周期都包括需求定义、风险分析、工程实现和评审 4 个阶段，需进行风险分析，其把项目分为众多小项目，每个小项目都有风险评估 特点 适合庞大复杂、风险高的系统 缺点： 需要丰富的风险评估经验迭代次数会增加成本和时间 （5）增量模型定义： 演化模型的另一表现形式，适用于技术架构成熟、风险较低的场景，可以有效的缩短周期，保证用户对系统的可见性 策略： 增量发布：分析系统，划分版本，后版本为前版本的扩充（每个版完整可用，版本之间增量均匀）。原型法：目的是获得精确的用户需求，或验证架构的可用性，每次迭代都是完整周期，始于技术不明确的场景 （6）构件组装模型定义： 分析功能，划分结构，完整单个构件 优点： 易扩展可重用构件独立而灵活 缺点： 需经验丰富对其他方面的需求需让步需研发人员技术强第三方构件开发人员难以控制 2.统一过程（UP）（1）定义 由Rational研发的软件迭代过程，提供完整开发过程解决方案，降低开发风险 （2）UP的二维模型 时间主线是横轴，开发经过初始、细化、构建和交付这4阶段描述不同阶段的主要工作在纵轴 横轴阶段： 初始阶段：业务建模和需求（2次细化）细化阶段：分析设计构建阶段：实施和测试（3阶段构建）交付（转移）阶段：重构、修改、测试和部署 每个阶段可能执行其他阶段的工作，与瀑布模型不同，不严格 纵轴阶段（9个核心工作流）： 业务建模、需求、分析设计、实施、测试、部署、配置与变更管理、项目管理、环境 （3）UP的生命周期 目标里程碑：明确软件系统的目标和范围架构里程碑：确定稳定的系统架构能力里程碑：系统足够稳定和成熟并完成 Alpha 测试发布里程碑：完成系统测试、完成系统发布和用户培训 （4）UP特点 给出了生命周期与迭代指南不同迭代方式的up可以演变模型风险控制更简单UP为重载过程可对UP裁剪，适应各种团队与软件 （5）UP如何使用 建立系统架构模型同需求人员和项目管理人员密切协作细化软件架构保持架构概念完整性 3.敏捷方法 快而持续的交付任务变化能力强时间周期短业务与开发人员密切联系开发环境好沟通方便进度可持续开发良好的技术与设计工作量少架构优秀高效的自我总结 3.1.极限编程（XP）（1）特点 反馈信息周期短迭代的计划编制依赖自动程序捕获缺陷依赖口头交流倡导演化设计依赖紧密协作开发人员短期盈利，项目长期盈利平衡 （2）四大价值观 沟通简单反馈勇气隐藏属性：尊重 （3）十二个最佳实践 计划游戏小型发布隐喻简单设计测试先行重构结对编程集体代码所有制持续集成每周工作40h现场客户编码标准 3.2.特征驱动开发(FDD)（1）定义： 是一个迭代的开发模型。FDD 的每一步都强调质量，不断地交付可运行的软件，并以很小的开发提供精确的项目进度报告和状态信息. （2）角色定义人： 项目经理首席架构师开发经理主程序员程序员领域专家 核心过程 开发整体对象模型构造特征列表计划特征开发特征设计特征构建 实践： 领域对象建模、根据特征进行开发、类的个体所有、组成特征小组、审查、定期构造、配置管理、结果的可见性 3.3.Scrum（1）定义： 用于开发和维持复杂产品的框架，是一个增量的、迭代的开发过程，整个开发周期划分许多个短的迭代周期（Sprint，2-4周），而在一个周期中选择最高优先级的先开发，Sprint会议经过讨论、分析和估算得到相应的任务列表，我们称它为 Sprint backlog。 （2）五个活动 产品待办事项列表梳理Sprint计划会议每日Sprint会议Sprint评审会议Sprint回顾会议 （3）Scrum的5大价值观 承诺：愿意对目标做出承诺。专注：把你的心思和能力都用到你承诺的工作上去。开放：Scrum把项目中的一切开放给每个人看。尊重：每个人都有他独特的背景和经验。勇气：有勇气做出承诺，履行承诺，接受别人的尊重。 3.4.水晶方法（1）定义： 由 Alistair Cockburn 和 Jim Highsmith 建立的敏捷方法系列，其目的是发展一种提倡“机动性的”方法，包含具有共性的核心元素，每个都含有独特的角色、过程模式、工作产品和实践。使用频度较高的是 Crystal Clear——透明水晶方法（适合小团队&lt;6） （2）透明水晶方法七大体系特征 经常交付反思改进渗透式交流个人安全焦点与专家用户建立方便的联系配有自动测试、配置管理和经常集成功能的技术环境 3.5.其他敏捷方法 开放式源码：开放式源码指的是开放源码界所用的一种运作方式(查错排障（debug）的高度并行性) ASD 方法：核心是三个非线性的、重叠的开发阶段：猜测、合作与学习 4.软件重用（1）定义： 利用已经存在的软件元素建立新的软件系统，这其中的软件元素既可以是软件产品、源程序，也可以是文档、设计思想甚至是领域知识。软件重用可以直接提高软件的开发效率、降低软件的开发成本、缩短软件的开发周期、提高软件质量 （2）常见的软件重用形式 源代码重用架构重用应用框架的重用业务建模重用文档及过程的重用软构建重用软件服务重用 （3）构件技术定义： 构件又称为组件，是一个自包容、可复用的程序集 两特征 自包容：构件的本身是一个功能完整的独立体，构件内部与外部的功能界限清晰明确，可以独立配置与使用可重用：构件的特点，也是构件出现的目的 5.基于架构的软件设计(ABSD)（1）其为架构驱动方法，三基础： 功能的分解选择架构风格来实现质量和业务需求软件模板的使用 软件模板:是一个特殊类型的软件元素，包括描述所有这种类型的元素在共享服务和底层构造的基础上如何进行交互.其还包含该类型的所有元素功能。 （2）方法与生命周期 ABSD 方法的输入组成： 抽象功能需求，包括变化的需求和通用的需求用例（实际功能需求）抽象的质量和业务需求质量因素（实际质量和业务需求）架构选项约束 ABSD 方法的输入组成： 抽象功能需求用例抽象的质量和业务需求架构选项质量场景约束 （3）基于架构的软件开发模型（ABSDM） 过程：① 架构需求：用户对目标软件系统在功能、行为、性能、设计约束等方面的期望 需求获取表示构件：生成类图-&gt;对类进行分组-&gt;把类打包成构件需求评审 ② 架构设计：激发和调整设计决策，不同的视图被用来表达与质量目标有关的信息（迭代过程） 提出软件架构模型把已标识的构件映射到软件架构中分析构件之间的相互作用产生软件架构设计评审 ③ 架构文档化：主要输出结果是架构需求规格说明和测试架构需求的质量设计说明书这两个文档 ④ 架构复审 目的是标识潜在的风险，以及早发现架构设计中的缺陷和错误，包括架构能否满足需求、质量需求是否在设计中得到体现、层次是否清晰、构件的划分是否合理、文档表达是否明确、构件的设计是否满足功能与性能的要求 ⑤ 架构实现： 用实体来显示出一个软件架构，即要符合架构所描述的结构性设计决策，分割成规定的构件，按规定方式互相交互。 ⑥ 架构演化：按需求变动修改 对需求变动归类在原架构修改之前，制定修改计划开发人员决定是否增删改构件更新构件后，相互关系需更新完成构件合成技术评审演化的架构修改添加到原架构上 6.形式化方法（1）定义： 形式化方法：采用严格的数学方法，使用形式化规约语言来精确定义软件系统 非形式化方法：通过自然语言、图形或表格描述软件系统的行为和特性，然后基于这些描述进行设计和开发，而形式化开发则是基于数学的方式描述、开发和验证系统 （2）形式化方法 形式化描述（形式化规约）：用形式化语言进行描绘，建立软件需求和特性，即解决软件“做什么”的问题，形式化描述主要可以分为两类，一类是通过建立计算模型来描述系统的行为特性，另一类则通过定义系统必须满足的一些属性来描述系统 基于形式化描述的形式化验证：验证已有的程序是否满足形式化描述的定义","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.yiyuclub.club/categories/学习笔记/"},{"name":"软考架构师","slug":"学习笔记/软考架构师","permalink":"http://www.yiyuclub.club/categories/学习笔记/软考架构师/"}],"tags":[{"name":"软考","slug":"软考","permalink":"http://www.yiyuclub.club/tags/软考/"},{"name":"架构师","slug":"架构师","permalink":"http://www.yiyuclub.club/tags/架构师/"}]},{"title":"（软考架构师笔记五）系统性能评价","slug":"（软考架构师笔记五）系统性能评价","date":"2019-05-22T00:52:49.000Z","updated":"2019-09-30T02:32:16.859Z","comments":true,"path":"2019/05/22/（软考架构师笔记五）系统性能评价/","link":"","permalink":"http://www.yiyuclub.club/2019/05/22/（软考架构师笔记五）系统性能评价/","excerpt":"（软考架构师笔记五）系统性能评价","text":"（软考架构师笔记五）系统性能评价 1.概念系统性能是一个系统提供给用户的众多性能指标的混合体，它既包括硬件性能，也包括软件性能 性能指标：描述当前流行系统主要涉及的性能指标性能计算：描述当前使用到的主要性能指标的计算方法性能设计：描述如何对现有系统进行性能上的调整优化，并介绍几个已经成熟的设计规则和解决方案性能评估：描述如何对当前取得的性能指标进行评价和改进。 2.性能指标（1）定义： 硬件：计算机、各种通信交换设备、以及其他网络硬件软件：操作系统、各种通信协议、各种参与到通信中的应用程序 （2）计算机指标 1.时钟频率（主频）：其越高cpu工作越快 2.高速缓存：高速缓冲存储器均由静态 RAM（Random Access Memory，随机存取存储器）组成 3.运算速度：计算机工作能力和生产效率的主要表征，取决于给定时间内 CPU 所能处理的数据量和 CPU 的主频MIPS 用于描述计算机的定点运算能力；MFLOPS 则用来表示计算机的浮点运算能力 4.运算精度：能直接处理的二进制数据的位数，位数越多，精度就越高 5.内存的存储容量：用来存储数据和程序，直接与 CPU 进行信息交换 6.存储器的存取周期完成一次读（取）或写（存）操作所需的时间称为存储器的存取时间或者访问时间连续两次读（或写）所需的最短时间称为存储周期存储周期越短，表示从内存存取信息的时间越短，系统的性能也就越好 7.数据处理速率 8.响应时间：某一事件从发生到结束的这段时间 RASIS 特性：可靠性、可用性、可维护性、完整性、安全性 平均故障响应时间：出现故障到该故障得到确认修复前的这段时间 兼容性：是指一个系统的硬件或软件与另一个系统或多种操作系统的硬件或软件的兼容能力，是指系统间某些方面具有的并存性，即两个系统之间存在一定程度的通用性 其他：吞吐率、利用率；定性指标如保密性、可扩充性；功能特性指标如文字处理能力、联机事务处理能力、I/O 总线特性、网络特性 （3）网络的性能指标 设备级性能指标：吞吐量、延迟、丢包率和转发速度 网络级性能指标：可达性、网络系统的吞吐量、传输速率、信道利用率、信道容量、带宽利用率、丢包率、平均传输延迟、平均延迟抖动、延迟/吞吐量的关系、延迟抖动/吞吐量的关系、丢包率/吞吐量的关系 应用级性能指标：网络对语言应用的支持程度、网络对视频应用的支持程度、延迟/服务质量的关系、丢包率/服务质量的关系、延迟抖动/服务质量的关系 用户级：可靠性、可用性 吞吐量：设备能够接受的最大速率 （4）操作系统吸能指标 系统的可靠性系统的吞吐量系统响应时间系统资源利用率可移植性 （5）数据库性能指标 数据库和数据库管理系统的性能指标包括数据库的大小、单个数据库文件的大小、数据库中表的数量、单个表的大小、表中允许的记录（行）数量、单个记录（行）的大小、表上所允许的索引数量、数据库所允许的索引数量、最大并发事务处理能力、负载均衡能力、最大连接数 （6）Web服务器性能指标 最大并发连接数、响应延迟、吞吐量（每秒处理的请求数）、成功请求数、失败请求数、每秒点击次数、每秒成功点击次数、每秒失败点击次数、尝试连接数、用户连接数等 3.性能计算（1）主要方法： 定义法:定义直接获取其理想数据公式法:根据基本定义所衍生出的复合性能指标的计算程序检测法:通过实际的测试来得到其实际值仪器检测法:与程序相同 （2）MIPS计算（单字长定点指令平均执行速度）公式：Fz 为处理机的工作主频，CPI为每条指令所需的平均时钟周期数，IPC 为每个时钟周期平均执行的指令条数 （3）峰值计算定义：指计算机每秒钟能完成的浮点计算最大次数。包括理论浮点峰值和实测浮点峰值 公式：理论浮点峰值 = CPU 主频′CPU 每个时钟周期执行浮点运算的次数′系统中 CPU 数 （4）等效指令速度 静态指令使用频度指的是在程序中直接统计的计算机速度动态指令使用频度指的是在程序执行过程中统计的指令速度。 4.性能设计（1）阿姆达尔解决方案定义： 系统中对某部件采用某种更快的执行方式，所获得的系统性能的改变程度，取决于这种方式被使用的频率，或所占总执行时间的比例 加速比=不使用加强部件完成整个任务的时间/使用增强部件 加速比决定因素 能被改进并增强的部分在总执行时间中所占的比例,称之为增强比例，它永远小于等于 1通过增强的执行方式所取得的改进执行时间等于未改进部分的执行时间加上改进部分的执行时间 （2）负载均衡定义： 由多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，都可以单独对外提供服务而无须其他服务器的辅助,通过某种负载分担技术，将外部发送来的请求均匀地分配到对称结构中的某一台服务器上，而接收到请求的服务器独立地回应客户的请求 类型： 基于特定服务器软件的负载均衡基于DNS的负载均衡反向代理负载均衡基于 NAT（网络地址转换）的负载均衡技术扩展的负载均衡技术 服务器负载均衡： 目的：提高服务器的整体处理能力，并提高可靠性、可用性和可维护性，最终目的是加快服务器的响应速度，从而提高用户的体验度结构上分类：本地负载均衡（对本地的服务器群做负载均衡）和全域负载均衡（对分别放置在不同的地理位置、有不同的网络及服务器群之间做负载均衡） 全域负载均衡特点： 解决网络拥塞问题，服务就近提供，实现地理位置无关性对用户提供更好的访问质量提高服务器响应速度提高服务器及其他资源的利用效率避免了数据中心单点失效。 5.性能评估（1）定义 性能评估是对一个系统进行各项检测，并形成一份直观的文档，因此性能评估是通过各项测试来完成的 （2）目的：为性能的优化提供参考 （3）基准测试程序定义： 应用程序中用得最多、最频繁的那部分核心程序作为评价计算机性能的标准程序 类别： 整数测试程序浮点测试程序Whetstone 基准测试程序SPEC基准测试程序TPC基准程序Linpack测试：Linpack100、Linpack1000 和 HPL （4）Web服务器的性能评估主要性能指标： 最大并发连接数响应延迟吞吐量（每秒处理的请求数） 常用设计方法： 有基准性能测试：采用各种基准程序对其进行测试压力测试：采用一些测试工具来测试 Web 服务器的一些性能指标可靠性测试 IxWeb： 美国 IXIA 公司的一个有关 Web 测试的解决方案，它是一个高性能业务负 载生成与分析应用系统，可在 TCP 和应用层模拟现实世界的业务负载方案，能够对设备 进行强度测试、检验转发策略和验证 4～7 层的性能 （5）系统监视 目标：为了评估系统性能 需收集性能数据： 常规性能数据比较基准的性能数据服务水平报告数据 系统监视方式： 通过系统本身提供的命令通过系统记录文件查阅系统在特定时间内的运行状态集成状态","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.yiyuclub.club/categories/学习笔记/"},{"name":"软考架构师","slug":"学习笔记/软考架构师","permalink":"http://www.yiyuclub.club/categories/学习笔记/软考架构师/"}],"tags":[{"name":"软考","slug":"软考","permalink":"http://www.yiyuclub.club/tags/软考/"},{"name":"架构师","slug":"架构师","permalink":"http://www.yiyuclub.club/tags/架构师/"}]},{"title":"（软考架构师笔记四）计算机网络","slug":"（软考架构师笔记四）计算机网络","date":"2019-05-21T00:11:20.000Z","updated":"2019-09-29T08:17:48.484Z","comments":true,"path":"2019/05/21/（软考架构师笔记四）计算机网络/","link":"","permalink":"http://www.yiyuclub.club/2019/05/21/（软考架构师笔记四）计算机网络/","excerpt":"（软考架构师笔记四）计算机网络","text":"（软考架构师笔记四）计算机网络 1.概念 由通信线路互相连接的许多独立自主工作的计算机构成的资源共享集合体 2.网络架构与协议 网络架构：计算机网络的各层及其协议的集合网络协议：规定信息的格式及如何发送和接收信息的一套规则 3.网络互联模型（1） 网络架构的国际标准：开放系统互联参考模型（OSI/RM）（2）OSI/RM七层模型 物理层：透明地完成相邻节点之间原始比特流的传输 数据链路层：传送以帧为单位的数据，把不可靠的物理层变为无差错的数据通道 网络层：通信子网的最高层，解决数据传输单元分组在通信子网中的路由选择、拥塞控制和多个网络互联的问题 传输层：网络通信的最高层，是资源子网和通信子网的桥梁，为两台计算机的通信提供可靠的端到端的数据传输服务 会话层：具体实施服务请求者与服务提供者之间的通信、组织和同步它们的会话 活动，并管理它们的数据交换过程 表示层：用户信息的表示问题（端用户（应用进程）之间传送的数据包含语义和语法两个方面。语义是数据的内容及其含义，它由应用层负责处理；语法是与数据表示形式有关的方面） 应用层：计算机网络与最终用户之间的界面 高低三层 网络通信的低三层：物理层、数据链路层、网络层面向信息处理的高三层：会话层、表示层、应用层 （3）TCP/IP 结构模型 （传输控制协议/网际协议） 网络接口层：对应于数据链路层和物理层（不包含具体的物理层和数据链路层，只定义了网络接口层作为物理层的接口规范），负责管理为物理网络准备数据所需的全部服务程序和功能 网络互联层：对应于网络层，主要解决路由选择、阻塞控制和网络互联等问题 传输层：对应于传输层，负责在信源和信宿之间提供端到端的数据传输服务 应用层：对应于会话层与表示层，为用户方便地提供对各种网络资源的访问服务 4.常见的网络协议（1）应用层协议 1.文件传输协议（FTP）-（TCP）：用于传输文件，有bin与ASCII两种方式，两条连接：控制信息（21），传输文件信息（20）2.简单文件传输协议（TFTP）-(UDP)：用于开销不大的文件传输3.超文本传输协议（HTTP）-(TCP)：从 WWW 服务器传输超文本到本地浏览器的传送协议4.简单又见传输协议（SMTP）-(TCP)：用于传输系统之间的邮件信息，并提供与电子邮件有关的通知5.动态主机配置协议（DHCP）-（UDP）:管理IP网络设置数据6.远程登录协议（Telnet）-（tcp）：将所有用户输入送到远程计算机进行处理的简单的终端程序7.域名系统（DNS）:进行域名解析的服务器,将名称解析为与之相关的其他信息8.简单网络管理协议（SNMP）：解决 Internet上的路由器管理的问题，指一系列网络管理规范的集合 （2）传输层协议UDP： 是面向无连接, 将数据及源的封装成数据包中,不需要建立建立连接每个数据报的大小在限制64k内因无连接,是不可靠协议不需要建立连接,速度快 TCP： 建立连接，形成传输数据的通道.在连接中进行大数据量传输，以字节流方式通过三次握手完成连接,是可靠协议必须建立连接m效率会稍低 （3）网络层协议 1.IP：无连接的和不可靠的，2.地址解析协议（ARP）：用于动态地完成 IP 地址向物理地址（MAC，网卡地址）的转换3.网际控制报文协议（ICMP）：用于发送差错报文的协议4.网际组管理协议（IGMP）：计算机用作向相邻多目路由器报告多目组成员的协议，允许 Internet 中的计算机参加多播 5.IPv6（1）出现缘由： 为了解决IPv4地址空间耗尽、路由表急剧膨胀、缺乏对 QoS 的支持、本身并不提供任何安全机制、移动性差等问题，推出了互联网协议第 6 版 （2）表示方式 一个 32 位的 IPv4 地址以 8 个位为一段分成 4 段，每段之间用点“.”分开。而 IPv6地址的 128 位是以 16 位为一段，共分为 8 段，每段的 16 位转换为一个 4 位的 16 进制数字，每段之间用冒号“：”分开。例如：2001：0da8：d001：0001：0000：0000：0000：0001 （3）压缩地址表示 在 IPv6 中，常见到使用包含一长串 0 的地址，为了方便书写，对于每一段中的前导 0可以进行省略。如前面的首选格式地址经过一次压缩例如：2001：da8：d001：1：0：0：0：1对于连续 2 段以上都为 0 的字段，可以使用“：：”（两个冒号）来表示，这样再次压缩例如：2001：da8：d001：1：：1 （4）内嵌 IPv4 地址的 IPv6 地址 （5）IPv6地址类型 单播IPv6地址：单播地址唯一标识一个 IPv6 节点的接口（IPv6 协议允许多个接口使用相同的 IPv6 地址，只要它们对于主机上的 IPv6 协议表现为一个接口） 多播IPv6地址：多播地址标识一组 IPv6 节点的接口 泛播IPv6地址：泛播地址指派给多个节点的接口 （6）IPv6优势 具有更大地址空间使用更小路由表增加组播和对流的支持加入自动配置支持安全性更高 （7）IPv4／IPv6 过渡技术 双协议栈技术:两种协议共存隧道技术：在IPv4部署隧道，实现对IPv6的支持（6to4 隧道；6over4 隧道；ISATAP隧道）NAT-PT技术：使用网关设备连接IPv6和 IPv4网络 6.局域网与广域网（1）定义： 局域网（LAN）：将分散在有限地理范围内的多台计算机通过传输媒体连接起来的通信网络，通过功能完善的网络软件，实现计算机之间的相互通信和资源共享；广域网（WAN）：在传输距离较长的前提下所发展的相关技术的集合，用于将大区域范围内的各种计算机设备和通信设备互联在一起，组成一个资源共享的通信网络 （2）局域网特点： 范围小数率高数据误码率低不架设骨干网协议相对简单、结构灵活，建网成本低、周期短，便于管理和扩充 结构： 星形结构：办公室总线结构环形结构网状结构 （3）无限局域网（WLAN）定义： 运用射频（Radio Frequency，RF）技术取代原来局域网系统中必不可少的传输介质（例如，同轴电缆、双绞线等）来完成数据的传送任务 拓扑结构： 基础设施网络：使用无线通信，存在接入点，通过接入点将一组节点逻辑上联系在一起，形成一个局域网Adhoc网络：使用无限通信，无接入点，通关无线网卡点对点连接 IEEE 802.11 标准 定义了媒体访问控制层（MAC 层）和物理层,采用主动避免碰撞而非被动侦测的方式来解决冲突问题 3G 通信技术: 3G 是第三代移动通信及其技术的简称，其主流标准包括：WCDMA、CDMA 2000 和TD-SCDMA 4G 通信技术 4G 是第四代移动通信及其技术的简称，是集 3G 与 WLAN 于一体并能够传输高质量视频图像且图像传输质量与高清晰度电视不相上下的技术产品4G 标准主要有两大方向，即 LTE（Long Term Evolution）与 WiMAX，而 LTE 又可进一步分为 TD-LTE 与 FDD-LTE （4）广域网 主要提供面向通信的服务，支持用户使用计算机进行远距离的信息交换 （5）网络接入技术PSTN 接入（公用交换电话网络）： 利用电话线拨号接入 Internet ISDN 接入（综合业务数字网）： 在电话网络的基础上构造的纯数字方式的综合业务数字网,俗称一线通 ADSL 接入（非对称数字用户线路）： 通过普通的电话线连接，无须对入户线缆进行改造，就可以为现有的大量电话用户提供 ADSL 宽带入 FTTx+LAN 接入: 利用光导纤维（简称为光纤）传输光波信号的一种通信方法 同轴+光纤接入： 将光缆敷设到小区，然后通过光电转换节点，利用有线电视（Community Antenna Television，CATV）的总线式同轴电缆连接到用户，提供综合电信业务的技术 7.网络互连与常用设备（1）定义： 为了将两个以上具有独立自治能力、同构或异构的计算机网络连接起来，实现数据流通，扩大资源共享的范围，或者容纳更多的用户 （2）网络互连设备 中继器：实现物理层协议转换，在电缆间转换二进制信号（物理层），集线器为多端口中继器网桥：实现物理层和和数据链路层协议转换（数据链路层）路由器：实现网络层和以下各层协议转换（网络层）网关：提供从最底层到传输层或以上各层的协议转换（最高4层）二层交换机：即多端口网桥（数据链路层）三层交换机：带路由功能的二层交换机（网络层）多层交换机：（最高4层） （3）交换技术定义： 当用户较多而传输的距离较远时，通常不采用两点固定连接的专用线路，而是采用交换技术，使通信传输线路为各个用户公用，以提高传输设备的利用率，降低系统费用 特点： 电路交换：在数据传送之前必须先设置一条通路。在线路释放之前，该通路将由一对用户独占报文交换：报文从源点传送到目的地采用存储转发的方式，不满足实时性分组交换：报文被分成分组传送，并规定了最大的分组长度，与报文交换类似 （4）路由技术功能：进行路由选择，根据目的地址信息，选择合适的路由 路由选择协议的应用范围划分： 内部网关协议(IGP):指在一个自治系统（Autonomous System，AS）内运行的路由选择协议外部网关协议(EGP):指在两个 AS自治系统 之间使用的路由选择协议,主要功能是控制路由策略核心网关协议(GGP):自治系统 全联接在主网干，主网干的网关称为核心网关，核心网关之间交换路由信息时使用的是 GGP 从路由协议使用的算法划分： 距离向量协议链路状态协议平衡型协议 8.网络工程（1）网络规划 网络需求分析：深入调查用户网络建设的背景、必要性、上网的人数和信息量可行性分析：从技术可行性、经济可行性、法律可行性和用户使用可行性等方面进行论证对现有网络的分析与描述：对现有网络进行分析，并系统化地描述出来。对现有网络系统进行调研 （2）网络设计网络逻辑结构设计 需要描述满足用户需求的网络行为及性能，详细说明数据是如何在网络上传输的 得到的逻辑网络设计文档 ① 逻辑网络设计图；② IP 地址方案；③ 安全方案；④ 具体的软件、硬件、广域网连接设备和基本的服务；⑤ 雇佣和培训新网络员工的具体说明；⑥ 初步对软件、硬件、服务、网络雇佣员工和培训的费用估计。 网络物理结构设计 通过对设备的具体物理分布、运行环境等的确定，确保网络的物理连接符合逻辑连接的要求确定具体的软硬件、连接设备、布线和服务 网络物理设计文档 ① 物理网络图和布线方案；② 设备和部件的详细列表清单；③ 软件、硬件和安装费用的估计；④ 安装日程表，用以详细说明实际和服务中断的时间及期限；⑤ 安装后的测试计划；⑥ 用户培训计划。 分层设计 通用规则来设计网络，简化设计、优化带宽的分配和规划 接入层 概念：直接面向用户连接或访问网络的部分目的：允许终端用户连接到网络特点：低成本，高端口密度 汇聚层 概念：汇聚层是核心层和接入层的分界面目的：完成网络访问策略控制、数据包处理、过滤、寻址，以及其他数据处理的任务 核心层 概念：网络主干部分目的：通过高速转发通信，提供优化、可靠的骨干传输结构 （3）网络实施概念 是在网络设计的基础上进行设备的购买、安装、调试和系统切换工作 步骤 工程实施计划网络设备到货验收设备安装系统测试系统试运行用户培训系统转换 （4）网络存储技术 直接附加存储（Direct Attached Storage，DAS）：直连外存 网络附加存储储（Network Attached Storage，NAS）：不再通过 I/O 总线附属于某个特定的服务器，而是通过网络接口与网络直接相连，由用户通过网络访问 存储区域网络络（Storage Area Network，SAN）：是通过专用交换机将磁盘阵列与服务器连接起来的高速专用子网 （5）综合布线概念 综合布线是一种模块化的、灵活性极高的建筑物内或建筑群之间的信息传输通道通过它可使话音设备、数据设备、交换设备及各种控制设备与信息管理系统连接起来，同时也使这些设备与外部通信网络相连 部件 传输介质、相关连接硬件（如配线架、连接器、插座、插头、适配器）及电气保护设备 综合布线系统7部分 工作区：一个独立的需要设置终端设备的区域宜划分为一个工作区 配线子系统：由工作区的信息插座模块、信息插座模块至电信间配线设备的配线电缆和光缆、电信间的配线设备及设备缆线和跳线等组成 干线子系统：由设备间至电信间的干线电缆和光缆，安装在设备间的建筑物配线设备及设备缆线和跳线组成 建筑群子系统：由连接多个建筑物之间的主干电缆和光缆、建筑群配线设备及设备缆线和跳线组成 设备间：每幢建筑物的适当地点进行网络管理和信息交换的场地 进线间：建筑物外部通信和信息管线的入口部位，并可作为入口设施和建筑群配线设备的安装场地 管理：管理应对工作区、电信间、设备间、进线间的配线设备、缆线、信息插座模块等设施，按一定的模式进行标识和记录","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.yiyuclub.club/categories/学习笔记/"},{"name":"软考架构师","slug":"学习笔记/软考架构师","permalink":"http://www.yiyuclub.club/categories/学习笔记/软考架构师/"}],"tags":[{"name":"软考","slug":"软考","permalink":"http://www.yiyuclub.club/tags/软考/"},{"name":"架构师","slug":"架构师","permalink":"http://www.yiyuclub.club/tags/架构师/"}]},{"title":"（软考架构师笔记三）数据库系统","slug":"（软考架构师笔记三）数据库系统","date":"2019-05-20T00:08:54.000Z","updated":"2019-09-29T06:40:24.164Z","comments":true,"path":"2019/05/20/（软考架构师笔记三）数据库系统/","link":"","permalink":"http://www.yiyuclub.club/2019/05/20/（软考架构师笔记三）数据库系统/","excerpt":"（软考架构师笔记三）数据库系统","text":"（软考架构师笔记三）数据库系统 1.数据库类别概念： 存放数据库的仓库 分类 关系型数据库（sql）：mysql、oracle等类型：关系型 DBMS、文档型 DBMS、键值型 DBMS、对象型 DBMS 非关系型数据库（nosql）：memcached、redis等 2.数据库模式（1）模式三级划分示例图： （2）三级抽象 用户级数据库：也称用户视图，作用于外模式，被用户所操作，一个数据库能有多个不同的用户视图 概念级数据库：也称DBA视图，作用于概念模式，一个数据库只能有一个DBA视图 物理级数据库：也称内部视图，作用于内模式，其不是真正的物理存储而是金结余物理存储的级别（描述数据的实际存储组织） （3）三级模式： 外模式：用户使用条件语句操作数据库（可多个）概念模式：描述数据库的逻辑关系（唯一）内模式：物理结构和存储方式的描述（唯一） （4）三者关系 模式是数据库的中心与关键内模式依赖于模式，独立于外模式和存储设备外模式面向应用，独立于内模式和存储设备应用程序依赖外模式，独立于模式与内模式 （5）两级独立性 三个抽象级间通过两级映射（外模式—模式映射，模式—内模式映射）进行相互转换 物理独立性：应用程序和存储在磁盘上的数据库的数据是独立性，一方改变不会影响另一方（概念模式与内模式的映射）逻辑独立性：应用程序和数据库的逻辑结构是独立性，一方改变不会影响另一方（概念模式与内】外模式的映射） （6）冲突 属性冲突命名冲突结构冲突 3.数据模型（1）分类1.概念数据模型 按照用户的观点来对数据和信息建模，主要用于数据库设计（E-R模型） 2.基本数据模型 按照计算机系统的观点来对数据和信息建模，主要用于 DBMS 的实现 基本组成 数据结构：对系统静态特性的描述数据操作对系统动态特性的：描述完整性：约束一组完整性规则的集合 数据模型 有层次模型：型用树形结构表示实体类型及实体间的联系网状模型：用有向图表示实体类型及实体间的联系关系模型面向对象模型 （2）基本数据模型 组成：基本数据模型通常由数据结构、数据操作和完整性约束三部分组成常用模型：层次模型（1：n）、网状模型(m：n)、关系模型和面向对象模型 4.关系代数（基本运算类型）（1）并：如R与S的并集（2）差：R与S的差集（3）交：R与S的交集（4）笛卡尔积： （5）投影（6）选择（7）连接（8）除 5.关系模型方式（1）概念： 把一个低一级的关系模型分解为高一级关系模型的过程关系模型满足的确定约束条件称为范式，范式由低到高分为 1NF（第一范式）、2NF（第二范式）、3NF（第三范式）、BCNF（BC 范式）、4NF（第四范式）等 （2）范式准则 无损连接性：信息不失真（不增减信息），U1∩U2→U1-U2 €F+ 或U1∩U2→U2 -U1€F+函数依赖保持性：不破坏属性间存在的依赖关系 （3）规范化理论 用数据依赖的概念分析和表示各数据项之间的关系消除 E-R 图中的冗余联系 （4）函数依赖一个表：学号，姓名，年龄，身份证，班级号 定义：一个值确定，依赖它的值也确定码（候选码）：数据库中唯一一行的属性集，相当于主键集合（学号和身份证）主码：也称主键，人为从候选码（主键集合）中选择的唯一区分其他行属性集（学号）外码：也称外键，该表出现的外表的主键（班级号）主属性：候选码（主键集合）的属性（学号和身份证）非主属性：不包含在主键中的属性（姓名，年龄，班级号） 第一范式：不可再分，任何关系必须满足第一范式（如住址可分为省与市，其不满足）第二范式：满足第一范式，所有非主属性完全依赖主属性（常见不符合的例子为部分依赖）第三范式：满足第二范式，非主属性不传递依赖主属性（解决方法先出传递依赖，如投影分表）BC范式：非主属性完全依赖于候选码；候选码中不存在依赖关系；非主属性不依赖于候选码中的其中一个属性（消除主属性对主码的部分依赖和传递依赖） （5）反规范化定义：为了提高某些查询或应用的性能而破坏规范规则 增加冗余列增加派生列重新组表分割表 （6）完整性约束 实体完整性：主键的任意属性不能为空参照完整性：两表关联，其主外键对应用户自定义完整性：用户定义的条件约束 6.数据库设计（1）面临的困难与问题 同时具备数据库知识与应用业务知识的人很少项目初期往往不能确定应用业务的数据库系统的目标缺乏完善的设计工具和设计方法需求的不确定性应用业务系统千差万别 (2)设计方法 直观设计法：单步逻辑设计法规范设计法计算机辅助设计法自动化设计法 缺点：缺乏工程规范的支持和科学根据，设计质量也不稳定，因此越来越不适应信息管理系统发展的需要 新奥尔良方法（4阶段）：1.需求分析： 概念：收集和分析用户对系统的信息需求和处理需求，得到设计系统所必需的需求信息，建立系统说明文档 其任务 确认需求、确定设计目标-&gt;分析和收集数据-&gt;整理文档（数据流图和数据字典） 2.概念结构设计 概念：在需求分析中产生的需求说明书的基础上按照一定的方法抽象成满足应用需求的用户的信息结构， 目的 提供能够识别和理解系统要求的框架为数据库提供一个说明性结构，作为设计数据库逻辑结构，即逻辑模型的基础 工具 E-R图 设计策略 全局策略：是建立一个覆盖整个单位所有功能域的全局数据库应用策略：对每一个应用都建立一个单独的数据库 3.逻辑结构设计 概念：把概念结构设计阶段设计好的基本 E-R 图转换为与具体机器上的 DBMS 产品所支持的数据模型相符合的逻辑结构 步骤 1.将概念结构向一般关系模型转化2.将第一步得到的结构向特定的 DBMS 支持下的数据模型转换3.依据应用的需求和具体的 DBMS 的特征进行调整与完善 4.物理结构设计 概念：利用已确定的逻辑结构及 DBMS 提供的方法、技术，以较优的存储结构、数据存取路径、合理的数据存储位置及存储分配，设计出一个高效的、可实现的物理数据库结构 基于其的设计： 3NF的设计方法（重点）LRA方法面向对象的数据库设计方法基于视图概念的数据库设计方法 （3）3NF的设计方法定义：基本思想是在需求分析的基础上，识别并确认数据库模式中的全部属性和属性间的依赖，将它们组织成一个单一的关系模型，然后再分析模式中不符合 3NF 的约束条件，用投影和连接的办法将其分解，使其达到 3NF 条件 设计步骤（5阶段）： 设计企业模式设计数据库逻辑模式设计数据库物理模式（存储模式）评价物理模式数据库实现 7.事务管理（1）事务特性 原子性（Atomicity）：数据库的逻辑工作单位。一致性（Consistency）：使数据库从一个一致性状态变到另一个一致性状态。隔离性（Isolation）：不能被其他事务干扰。持续性（永久性）（Durability）：一旦提交，改变就是永久性的。 事务开始：BEGIN TRANSACTION事务提交：COMMIT事务回滚：ROLLBACK (2)并发控制定义：在多用户共享系统中，许多事务可能同时对同一数据进行操作，称为“并发操作” 并发出线的问题： 丢失更新数据过期被读取（重复读,读过期数据）脏数据（数据已提交但读取了旧的数据） 解决方案：封锁技术 排它锁（X封锁）：只允许事务 T 读取和修改数据 A，其他事务要等事务 T 解除 X 封锁以后，才能对数据 A 实现任何类型的封锁共享锁（S封锁）：S锁可读数据但不可修改（也不可加入X锁），除非解除 封锁协议： 1.一级封锁协议：加X锁，防止数据丢失更新2.二级封锁协议：加S锁，防止数据丢失更新和脏数据3.三级封锁协议：在1基础性上加入S锁，三者皆可防止4.两段锁协议：所有事务必须分两个阶段对数据项加锁和解锁。其可能发生死锁请注意。 8.故障与恢复（1）故障类别 事务故障（操作引起）系统故障 （系统运行）介质故障（存于外盘数据丢失）计算机病毒（病毒程序） （2）故障的恢复 事务故障的恢复：事务为进行到终点时撤销系统故障：根据日志找到已完成和未完成的事务，对事务进行逆操作，重新执行事务介质故障：找到备份恢复，找到日志反向进行操作，正向阅读日志，重做已完成事务，回到事务之前计算机病毒：检查点恢复br&gt; 9.备份与恢复（1）遵守的原则 保证数据丢失的情况尽量少或完全不丢失备份和恢复时间尽量短，保证系统最大的可用性 （2）物理备份 冷备份：将数据库正常关闭，在停止状态下利用操作系统的 copy、cp、tar、 cpio等命令将数据库的文件全部备份下来，当数据库发生故障时，将数据文件复制回来，进行恢复热备份：①备份软件备份；②不关闭数据库，将数据置为备份状态然后备份，再讲备份状态置为正常。 完全备份：将数据库的内容全部备份，作为增量、累积的基础增量备份：只备份上次完全、增量或累积备份以来修改的数据累计备份：备份自上次完全或累积备份以来修改过的数据 周期：一个完全备份和多个增量、累积备份组成恢复：首先从完全备份恢复数据库，然后按照时间顺序从早到晚依次导入多个增量和累积备份文件 （3）逻辑备份：利用各数据库系统自带的工具软件备份和恢复数据库的内容 10.分布式数据库系统（1）定义 分布式数据库是由一组数据组成的，这组数据分布在计算机网络的不同计算机上，网络中的每个结点具有独立处理的能力，成为场地自治，它可以执行局部应用，同时，每个结点也能通过网络通信子系统执行全局应用负责分布式数据库的建立、查询、更新、复制、管理和维护的软件称为分布式数据库管理系统。 （2）分布式数据库系统特点 数据的分布性统一性透明性坚固性好可扩充性好可改善性能自治性好 (3)分布式数据库系统分类 按 DDBMS 软件同构度来分:当所有服务器软件（或每个 LDBMS）和所有客户软件均用相同的软件时称为同构型分布式数据库；反之，则称为异构型分布式数据库 按局部自治度来分:当对 DDBMS 的存取必须通过客户软件，则系统称为无局部自治；当局部事务允许对服务器软件进行直接存取，则系统称为有一定的局部自治 按分布透明度来分:若用户可以对集成模式操作不需要涉及任何片段、重复、分布等信息时，则这类 DDBMS 称为有高度分布透明（或高度模式集成）；若用户必须知道所有关于片段、分配、重复等信息时，则这类 DDBMS没有分布透明，没有模式集成度 (4)分布式数据库的目标 局部结点自治性不依赖中心结点能连续操作具有位置独立性（或称位置透明性）分片独立性（或称分片透明性）数据复制独立性支持分布式查询处理支持分布事务管理具有硬件独立性具有操作系统独立性具有网络独立性具有 DBMS 独立性 (5)分布式数据库的架构（1）示例图（下半部分是集中式数据库的模式结构，上半部分是分布式数据库系统增加的模式级别）： 1.全局外模式。它们是全局应用的用户视图。2.全局概念模式。定义分布式数据库中数据的整体逻辑结构向其他层次的模式映像。3.分片模式。每一个全局关系可以划分为若干不相交的部分，每一部分称为一个片段，即“数据分片”。4.分布模式。由数据分片得到的片断仍然是 DDB 的全局数据，是全局关系的逻辑部分5.局部概念模式。一个全局关系经逻辑划分成一个或多个逻辑片断，每个逻辑片断被分配在一个或多个场地上，称为该逻辑片断在某场地上的物理映像或物理片断。6.局部内模式。 （2）其特点： 数据分片和数据分配概念的分离，形成了“数据分布独立型”概念。数据冗余的显示控制。局部 DBMS 的独立性。这个特征也称为“局部映射透明性”。 11.数据仓库（1）概念 数据仓库（Data Warehouse）是一个面向主题的、集成的、相对稳定的、且随时间变化的数据集合，用于支持管理决策. 分类 主题性数据仓库：按主题业务划分面向数据处理的数据仓库:在对原有分散的数据库数据抽取、清理的基础上经过系统加工、汇总和整理稳定性数据仓库： 实时更新，数据根据需要及时发生变化（常用于企业决策）随时间变化的数据仓库：用于历史时间点相关 （2）数据仓库的结构（常用OLAP，联机分析处理） 数据源数据准备区数据仓库数据库数据集市/知识挖掘库各种管理工具和应用工具 （3）数据仓库的参考架构 数据仓库基本功能层：功能是从数据源抽取数据，对所抽取的数据进行筛选、清理，将处理过的数据导入或者说加载到数据仓库中，根据用户的需求设立数据集市，完成数据仓库的复杂查询、决策分析和知识的挖掘等 数据仓库管理层：对这些基本功能进行管理与支持的结构框架 数据仓库的环境支持层：由数据仓库数据传输层和数据仓库基础层组成 （4）数据仓库的实现方法自顶向下法适用情况： 实现单位比较熟悉技术，并具有根据商业需求采用自顶向下方法开发应用程序的丰富经验。决策层（总经理、决策者、投资者）完全清楚数据仓库的预测目标。决策层（总经理、决策者、投资者）完全清楚数据仓库用作哪些机构的决策支持工具。决策层（总经理、决策者、投资者）完全清楚数据仓库已经是商业过程中的一个子过程。 自底向上法适用情况： 企业还没有确实掌握数据仓库技术，希望进行技术评估来决定运行该技术的方式、地点和时间。企业希望了解实现和运行数据仓库所需要的各种费用情况。企业在对数据仓库进行投资选择。自底向上方法对于希望从数据仓库投资中快速得到回报的用户是非常有效的。该方法可以使企业充分利用各种技术，无须冒很大风险。 联合方法适用情况： 实现企业拥有经验丰富的设计师，有能力建立、证明、应用和维护数据结构、技术结构及企业模型，可以很容易地从具体（运作系统中的元数据）转移到抽象。企业拥有固定的项目小组，完全清楚数据仓库技术应用的场所。他们可以清楚地看到当前的商务需求。 11.数据挖掘（1）定义：按企业既定业务目标，对大量的企业数据进行探索和分析，揭示隐藏的、未知的或验证已知的规律性，并进一步将其模型化的先进有效的方法 （2）数据挖掘的功能 自动预测趋势和行为数据挖掘自动在大型数据库中寻找预测性信息，以往需要进行大量手工分析的问题如今可以迅速直接由数据本身得出结论关联分析数据关联是数据库中存在的一类重要的可被发现的知识聚类数据库中的记录可被划分为一系列有意义的子集，即聚类概念描述概念描述就是对某类对象的内涵进行描述，并概括这类对象的有关特征偏差检测数据库中的数据常有一些异常记录，从数据库中检测这些偏差很有意义 (3)数据挖掘常用技术 关联分析、聚类分析、分类分析、异常分析、特异群组分析和演变分析 （4）数据挖掘的流程 问题定义在开始数据挖掘之前，最先的也是最重要的要求就是熟悉背景知识，弄清用户的需求建立数据挖掘库分析数据调整数据模型化评价和解释 （5）数据挖掘人员类别 业务分析人员数据分析人员数据管理人员 12.NoSQL（1）定义：全称Not Only SQL，NoSQL数据存储不需要固定的表结构，通常也不存在连接操作。 （2）NOSQL特点 易扩展大数据量，高性能灵活的数据模型高可用 13.大数据（1）定义 无法在一定时间范围内用常规软件工具进行捕捉、管理和处理的数据集合，是需要新处理模式才能具有更强的决策力、洞察发现力和流程优化能力的海量、高增长率和多样化的信息资产 （2）特点 Volume：数据体量巨大Variety：数据类型繁多Value：价值密度低Velocity：处理速度快 （3）大数据处理关键技术 大数据处理关键技术一般包括：大数据采集、大数据预处理、大数据存储及管理、大数据分析及挖掘、大&gt;数据展现和应用（大数据检索、大数据可视化、大数据应用、大数据安全等）。 （4）大数据应用4．大数据应用 大数据可以在各行各业得以应用，如金融服务、医疗保健、零售业、制造业、政府机构等。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.yiyuclub.club/categories/学习笔记/"},{"name":"软考架构师","slug":"学习笔记/软考架构师","permalink":"http://www.yiyuclub.club/categories/学习笔记/软考架构师/"}],"tags":[{"name":"软考","slug":"软考","permalink":"http://www.yiyuclub.club/tags/软考/"},{"name":"架构师","slug":"架构师","permalink":"http://www.yiyuclub.club/tags/架构师/"}]},{"title":"（软考架构师笔记二（5））作业管理","slug":"（软考架构师笔记二（5））作业管理","date":"2019-05-17T07:30:36.000Z","updated":"2019-09-26T08:13:15.015Z","comments":true,"path":"2019/05/17/（软考架构师笔记二（5））作业管理/","link":"","permalink":"http://www.yiyuclub.club/2019/05/17/（软考架构师笔记二（5））作业管理/","excerpt":"（软考架构师笔记二（5））作业管理","text":"（软考架构师笔记二（5））作业管理 1.概念 从用户的角度看，作业是系统为完成一个用户的计算任务（或一次事务处理）所做的工作总和 从系统的角度看，作业则是一个比程序更广的概念。它由程序、数据和作业说明书组成。系统通过作业说明书控制文件形式的程序和数据，使之执行和操作。而且，在批处理系统中，作业是占据内存的基本单位 用户作业方式 联机方式：由用户自己按照作业步顺序操作（直接方式） 脱机方式：由用户率先编写的作业步依次执行的说明，一次性交给操作系统，由系统按照说明依次处理（间接方式） 2.作业状态及转换（1）状态 1.提交：作业由输入设备进入外存储器（也称输入井）的过程 2.后备：当作业的全部信息进入外存后，系统就为该作业建立一个作业控制块（Job Control Block，JCB）。系统通过 JCB 感知作业的存在。JCB 主要内容包括作业名、作业状态、资源要求、作业控制方式、作业类型及作业优先权等 3.执行：个后备作业被作业调度程序选中而分配了必要的资源并进入了内存，作业调度程序同时为其建立了相应的进程后，该作业就由后备状态变成了执行状态 4.完成：当作业正常运行结束，它所占用的资源尚未全部被系统回收时的状态为完成状态。 3.用户接口（用户界面）定义 操作系统的接口：用户与操作系统交互的途径和通道 操作环境：指这种交互环境的控制方式 详情 操作系统的接口：操作系统的接口又可分成命令接口和程序接口。命令接口包含键盘命令和作业控制命令；程序接口又称为编程接口或系统调用，程序经编程接口请求系统服务，即通过系统调用程序与操作系统通信。系统调用是操作系统提供给编程人员的唯一接口。系统调用对用户屏蔽了操作系统的具体动作而只提供有关功能。系统调用大致分为设备管理、文件管理、进程控制、进程通信和存储管理等 操作环境：操作环境支持命令接口和程序接口，提供友好的、易用的操作平台。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.yiyuclub.club/categories/学习笔记/"},{"name":"软考架构师","slug":"学习笔记/软考架构师","permalink":"http://www.yiyuclub.club/categories/学习笔记/软考架构师/"}],"tags":[{"name":"软考","slug":"软考","permalink":"http://www.yiyuclub.club/tags/软考/"},{"name":"架构师","slug":"架构师","permalink":"http://www.yiyuclub.club/tags/架构师/"}]},{"title":"（软考架构师笔记二（4））文件管理","slug":"（软考架构师笔记二（4））文件管理","date":"2019-05-17T01:44:46.000Z","updated":"2019-09-26T08:06:46.982Z","comments":true,"path":"2019/05/17/（软考架构师笔记二（4））文件管理/","link":"","permalink":"http://www.yiyuclub.club/2019/05/17/（软考架构师笔记二（4））文件管理/","excerpt":"（软考架构师笔记二（4））文件管理","text":"（软考架构师笔记二（4））文件管理 1.概念 硬件管理：CPU 的管理、存储器的管理、设备管理等目的：主要解决硬件资源的有效和合理利用问题 软件管理：系统程序、各种应用程序、各种用户程序，也包括大量的文档材料、库函数等（以文件形式存储） 文件管理的功能 建立、修改、删除文件按文件名访问文件决定文件信息的存放位置、存放形式及存取权限管理文件间的联系及提供对文件的共享、保护和保密等 文件共享 一个文件可以让多个用户共同使用，它可以减少用户的重复性劳动，节省文件的存储空间，减少输入/输出文件的次数 2.文件的保护与保密文件保护 为防止由于错误操作而对文件造成的破坏 文件保密 防止未经授权的用户对文件进行访问 两级控制：第1级别访问者识别，谁可以访问；第二级别，存取权限识别，谁有权限对文件处理 3.文件的逻辑结构逻辑结构 指文件的组织形式，从用户角度所看到的文件组织形式 类别： 无结构的字符流文件有结构的记录文件 记录 定义：记录文件由记录组成，即文件内的信息划分成多个记录，以记录为单位组织和使用信息 类别： 顺序文件：按键值的约定次序组织的 索引顺序文件：基于键的约定次序组织的，而且维护键的索引和溢出区域 索引文件：基于记录的一个键数据项组织 直接（哈希）文件：记录以它们在直接访问存储设备上的物理地址直接（随机地）访问 4.文件的物理结构 指文件在存储设备上的存放方法,文件的存储设备通常划分为大小相同的物理块，物理块是分配和传输信息的基本单位 文件的物理结构涉及文件存储设备的组块策略和文件分配策略，决定文件信息在存储设备上的存储位置。常用的文件分配策略有： 1.顺序分配：开始新建连续物理块，把信息按顺序存入，其存取速度快，但新建时需指定长度，不利于修改 2.链接分配：每个物理块有一个指针指向下一个物理块形成链接队列，修改快，读取较慢 3.索引分配：文件不连续存储，建立索引表，逻辑号与物理号一一对应，存取快，修改快，但易产生分配问题和增加存取空间的开销（访问了两次磁盘：索引表和索引表提供的物理块号访问文件信息，可把索引表放入内存加快速度） 5.文件存储设备管理（1）定义 文件存储设备管理，就是操作系统要有效地进行存储空间的管理，文件存储设备分成许多大小相同的物理块，因此实质上是对空闲块的组织和管理 （2）空闲块管理方法 1.索引法：磁盘上每一个空闲块区都对应于索引表中一个条目 2.链接法：链接法使用链表把空闲块组织在一起，当申请者需要空闲块时，分配程 序从链首开始摘取所需的空闲块 3.位示图法：在外存建立位示图记录数据 6.树型目录结构（1）定义 在树型目录结构中，树的根结点为根目录，数据文件作为树叶，其他所有目录均作为树的结点，根目录隐含于一个硬盘的一个分区中，根目录在最顶层。它包含的子目录是一级子目录。每一个一级子目录又可以包含若干二级子目录，…，这样的组织结构就叫作目录树。 当前盘和当前目录是系统默认的操作对象。如果用户没有指明操作对象，系统就将用户命令指向当前盘和当前目录。 路径是指从根目录或者当前目录开始到访问对象（目录或者文件），在目录树中路经的所有目录的序列 绝对路径：从树根开始的路径 相对路径：由目录结构中的当前位置开始 父目录：当前路径的上一层目录","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.yiyuclub.club/categories/学习笔记/"},{"name":"软考架构师","slug":"学习笔记/软考架构师","permalink":"http://www.yiyuclub.club/categories/学习笔记/软考架构师/"}],"tags":[{"name":"软考","slug":"软考","permalink":"http://www.yiyuclub.club/tags/软考/"},{"name":"架构师","slug":"架构师","permalink":"http://www.yiyuclub.club/tags/架构师/"}]},{"title":"（软考架构师笔记二（3））设备管理","slug":"（软考架构师笔记二（3））设备管理","date":"2019-05-17T01:25:34.000Z","updated":"2019-09-26T07:54:19.807Z","comments":true,"path":"2019/05/17/（软考架构师笔记二（3））设备管理/","link":"","permalink":"http://www.yiyuclub.club/2019/05/17/（软考架构师笔记二（3））设备管理/","excerpt":"（软考架构师笔记二（3））设备管理","text":"（软考架构师笔记二（3））设备管理 1.概念 定义：除了处理器和内存之外，其他的大部分硬设备（输入/输出设备，辅存设备及终端设备） 主要任务：控制设备和内存或 CPU 之间的数据传送 2.数据传输控制方式（1）选择和衡量控制方式的原则： 数据传送速度足够高，能满足用户的需要但又不丢失数据 系统开销小，所需的处理控制程序少 能充分发挥硬件资源的能力，使得 I/O 设备尽量处于使用状态中，而 CPU 等待时间少 (2)外围设备和内存之间常用的数据传送控制方式: 程序控制：处理器启动数据传输，然后等设备完成 中断方式 直接存储访问方式（DMA）：外部设备和内存之间开辟直接的数据交换通路(采用窃取（或挪用）处理器的工作周期和控制总线而实现辅助存储器和内存之间的数据交换) 通道方式:通过执行自身的输入/输出专用程序（称通道程序）进行内存和外设之间的数据传输(字节多路通道、选择通道和成组多路通道) 3.虚设备与 SPOOLING 技术 假脱机（假脱机输入/输出操作，SPOOLING）：外部设备同时联机操作，采用一组程序或进程模拟一台输入/输出处理器 作用：将低速的独占设备改造成一种可共享的设备 要求 必须有高速、大容量并且可随机存取的外存支持","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.yiyuclub.club/categories/学习笔记/"},{"name":"软考架构师","slug":"学习笔记/软考架构师","permalink":"http://www.yiyuclub.club/categories/学习笔记/软考架构师/"}],"tags":[{"name":"软考","slug":"软考","permalink":"http://www.yiyuclub.club/tags/软考/"},{"name":"架构师","slug":"架构师","permalink":"http://www.yiyuclub.club/tags/架构师/"}]},{"title":"（软考架构师笔记二（2））存储管理","slug":"（软考架构师笔记二（2））存储管理","date":"2019-05-17T00:14:22.000Z","updated":"2019-09-26T07:44:32.445Z","comments":true,"path":"2019/05/17/（软考架构师笔记二（2））存储管理/","link":"","permalink":"http://www.yiyuclub.club/2019/05/17/（软考架构师笔记二（2））存储管理/","excerpt":"（软考架构师笔记二（2））存储管理","text":"（软考架构师笔记二（2））存储管理 1.定义 存储管理主要是指对内存储器的管理，负责对内存的分配和回收、内存的保护和内存的扩充。目的是尽量提高内存的使用效率 2.类别 内存：系统实际提供的存储单元（常指字节）组成的一个连续地址空间(处理器可直接存取) 外存：软盘、硬盘、光盘和磁带等一些外部存储部件，常用来存放暂不执行的程序和数据(处理器不能直接访问外存) 注：外存需要通过启动 I/O（Input/Output，输入/输出）设备才能进行内存、外存交换 3.内存大小 由硬件决定，受硬件条件限制 速度 处理机直接访问，速度较快 虚拟存储器 不考虑实际内存的大小和数据存取的实际地址，只考虑相互有关的数据之间的相对位置，其容量由计算机地址的位数决定 分类 系统空间，存放于操作系统相关的数据与程序用户空间，用户的数据与程序 4.段页式存储管理（1）页式存储管理 分页：把程序的逻辑空间和内存的物理空间按照同样的大小划分成若干页面，并以页面为单位进行分配 虚地址形式：（页号，偏移量）-&gt;（p，d） 动态地址转换：其页表的首地址已在系统的动态地址转换机构中的基本地址寄存器中，指令访问虚存地址（p，d）时，首先根据页号 p 查页表，由状态可知，这个页是否已经调入内存。若已调入内存，则得到该页的内存位置 p’，然后，与页内相对位移 d 组合，得到物理地址 r。如果该页尚未调入内存，则产生缺页中断，装入对应的页 页面调度 当内存中无空闲块时，为了装入一个页面而必须按某种算法从已在内存的页中选择一页，将它暂时调出内存，让出内存空间以存放所需装入的页面 抖动现象 刚被调出的页面又立即要用，因而又要把它装入，而装入不久又被选中调出，调出不久又被装入，如此反复，使调度非常频繁 避免抖动策略 最优（OPT）算法：选择不再使用或最远的将来才被使用的页 随机（RAND）算法：随机地选择被淘汰的页，开销小，但是可能选中立即就要访问的页 先进先出算法：选择在内存驻留时间最长的页似乎合理 最近最少使用（Least Recently Used，LRU）算法：选择离当前时间最近的一段时间内使用得最少的页 （3）段式存储管理 分段：把用户作业按逻辑意义上有完整意义的段来划分，并以段为单位作为内外存交换的空间尺度 虚地址形式：（段号，偏移量）-&gt;（s，d） 动态地址转换：执行的指令访问虚存（s，d）（取指令或取操作数）时，首先根据段号 s 查段表，若段已经调入内存，则得到该段的内存起始地址，然后与段内相对地址（段内偏移量 d）相加，得到实地址。如果该段尚未调入内存，则产生缺段中断，以装入所需要的段。段式存储与页式存储的地址转换方式类似 在内存连续空间不足的情况下，可以把段分到不连续的空闲空间存放 （4）段页式存储管理 定义：把每一段再分成若干页面，每一段不必占用连续的存储空间；甚至当内存块不够时，可只将一段中的部分页面装入内存 模式：有段与页组成，程序模块分段，段内再分页 虚地址形式：（段号，页号，偏移量）-&gt;（s，p，d） 动态地址转换：作业执行时按段号查段表，找到相应的页表，再根据页表查到对应的页号，由标志位判定该页是否已在内存，若是，则进行地址转换得到物理地址；否则进行页面调度","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.yiyuclub.club/categories/学习笔记/"},{"name":"软考架构师","slug":"学习笔记/软考架构师","permalink":"http://www.yiyuclub.club/categories/学习笔记/软考架构师/"}],"tags":[{"name":"软考","slug":"软考","permalink":"http://www.yiyuclub.club/tags/软考/"},{"name":"架构师","slug":"架构师","permalink":"http://www.yiyuclub.club/tags/架构师/"}]},{"title":"（软考架构师笔记二（1））进程管理","slug":"（软考架构师笔记二（1））进程管理","date":"2019-05-16T03:54:40.000Z","updated":"2019-10-18T07:08:50.244Z","comments":true,"path":"2019/05/16/（软考架构师笔记二（1））进程管理/","link":"","permalink":"http://www.yiyuclub.club/2019/05/16/（软考架构师笔记二（1））进程管理/","excerpt":"（软考架构师笔记二（1））进程管理","text":"（软考架构师笔记二（1））进程管理 1.概念 处理机管理也被称为进程管理,处理机管理的功能就是组织和协调用户对处理机的争夺使用，把处理机分配给进程，对进程进行管理和控制，最大限度也发挥处理机的作用。其为并发执行。 2.顺序程序程序中若干操作必须按照某种先后次序来执行，并且每次操作前和操作后的数据、状态之间都有一定的关系 资源共享，多程序共享资源：提高资源的利用率多处理机并发运行—单处理机交替运行 程序大多是时间上有次序，但也有同时进行的独立运行和分配资源的基本单位：进程 3.进程状态的转化1.三状态 就绪状态：进入就绪队列，等待获取资源执行状态：得到资源，开始执行阻塞状态：由于某些原因暂停执行，进入阻塞队列，其也称为等待或睡眠状态 2.由于自身或外部的原因，状态发生变化 3.挂机状态（1）产生的原因 对换的需求：进程等待期盼被执行，但不具备执行的条件无法进入就绪状态 终端用户的请求：进程被暂停进行研究或修改 父进程请求：父进程对子进程挂机，对其协调或修改操作 负荷调节：保证工作正常进行，把非主要的进程挂机 系统的需要：系统挂起程序检查资源或记录数据 （2）挂机状态三属性 就绪被挂起称为挂起就绪，阻塞被挂起称为挂起阻塞，其进程都不能被调度而被执行 静止阻塞状态转换为挂起就绪状态后才可被调度而执行 进程可由任意对象挂起，目的是组织进程执行，但只能显示激活进程 （3）进程互斥与进程同步 临界资源：一次仅允许一个进程使用的资源 临界区：一个进程访问临界资源的那段程序代码(进程互斥不允许两个以上共享临界资源的并发进程同时进入临界区) 进程同步：把异步环境下的一组并发进程因直接制约而互相发送消息而进行互相合作、互相等待，使得各进程按一定的速度执行的过程（协同关系） 进程互斥：临界资源在某一时刻只被一个进程访问（竞争关系） 中断：计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行 4.临界区协调准则 空闲让进：临界区无进程，新进程可进入忙则等待：临界区有进程，新进程需等待旧进城离开有限等待：有若干进程要求进入临界区时，应在有限时间内使一进程进入临界区让权等待：等待进去临界区的进程必须释放其占有的资源 3.信号量（sem）（1）概念：实现进程的同步与互斥（2）表示： ①sem&gt;0时：表示可使用的资源数量 ②sem&lt;0时：表示等待资源的进程数 （3）P操作和V操作 P操作：sem-1，如sem&lt;0,P进程暂停（资源不足）V操作：sem+1，如sem&lt;=0，cpu资源增加（唤醒等待的进程） 5.前趋图 概念：一个由结点和有向边构成的有向无循环图，有先后制约关系 节点：表示一个语句、一个程序段或是一个进程 有向边：表示两个结点之间存在的前趋关系 注：三步（取指、分析、执行） ①直接制约（横向）：同步的进程之间的制约关系，如A1,B1,C1 ②间接制约（竖向）：互斥的进程之间的制约关系，如A1,A2,A3 6.进程调度与死锁（1）进程调度 定义：处理机调度(上下文转换)，让正在执行的进程改变状态并转入就绪队列的队尾，再由调度原语将就绪队列的队首进程取出，投入执行 引起调度的原因： 进程执行完毕运行状态转成阻塞状态执行P操作。资源不足；执行V操作唤醒等待的进程分时系统，进程用完时间片优先级改变 进程调度算法 先来先服务：按队列顺序优先数调度：按优先级顺序轮转发：按时间轮转分配时间（每个j进程按规定时间，超过则等待下一次调度） （2）死锁 定义 进程间相互抢占对方资源，无法释放也无法获取资源，陷入无限等待(即相互调用的进程形成环状) 保证资源数量则不会死锁：K*(n-1)+1（k值有进程数量，n值每个需要几个资源） 产生的主要问题 共享的系统资源不足必要条件：互斥条件、保持和等待条件、不剥夺条件、环路等待条件 解决策略(4个必要条件) 预防策略：静态分配法（打破了资源动态分配条件）和有序分配法：（循环等待条件）死锁避免策略：执行死锁避免算法（耗费大量的 CPU 和时间） 发生后检测与恢复 注：系统出现死锁的概率很小，故从系统所花的代价上看，采用死锁发生后的检测与恢复策略要比采用死锁发生前的预防与避免策略代价小一些","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.yiyuclub.club/categories/学习笔记/"},{"name":"软考架构师","slug":"学习笔记/软考架构师","permalink":"http://www.yiyuclub.club/categories/学习笔记/软考架构师/"}],"tags":[{"name":"软考","slug":"软考","permalink":"http://www.yiyuclub.club/tags/软考/"},{"name":"架构师","slug":"架构师","permalink":"http://www.yiyuclub.club/tags/架构师/"}]},{"title":"（软考架构师笔记二）操作系统","slug":"（软考架构师笔记二）操作系统","date":"2019-05-15T01:03:46.000Z","updated":"2019-09-26T02:23:31.068Z","comments":true,"path":"2019/05/15/（软考架构师笔记二）操作系统/","link":"","permalink":"http://www.yiyuclub.club/2019/05/15/（软考架构师笔记二）操作系统/","excerpt":"（软考架构师笔记二）操作系统","text":"（软考架构师笔记二）操作系统 1.原理一观点两线索 一观点：以资源管理的观点来定义操作系统两线索：操作系统如何管理计算机各类资源和控制程序的执行 2.定义 计算机系统中的核心系统软件，负责管理和控制计算机系统中的硬件和软件资源合理地组织计算机工作流程和有效地利用资源，在计算机与用户之间起接口的作用. （1）引入操作系统的目的： ① 用户角度： 可以透明的使用计算机软硬件调用操作系统服务 ② 资源管理角度： 操作系统管理和分配计算机软硬件资源合理组织计算机工作流程为多用户共享资源，合理分配 ③ 进程角度： 由系统核心和多个进程并发组成系统核心控制和协调进程 ④ 分层角度： 采用分层结构实现各层次按一定次序组织协调工作 （2）提供的接口： 为用户：命令、菜单、窗口 为应用：API 3.硬件/软件关系图 4.操作系统分类 批处理操作系统、分时操作系统实时操作系统、网络操作系统分布式操作系统嵌入式操作系统微内核操作系统等 （1）批处理操作系统(作业处理系统)： 成批的装入计算机，由计算机输入井处理好，按一定算法选择一个或多个作业，调入内存运行，把结果放入输出井，输出给用户 （2）分时操作系统： 把CPU的时间划分为很短的时间片，轮流分配给各终端作业使用（如果某个作业再改时间片未完成，需等待下一轮时间再次进行）多路性、及时性、独立性、交互性、及时性 （3）实施擦做系统： 当外界数据或事件产生时，系统能快速的接收和处理，其结果又能快速的生产和响应高可靠性，实时响应性 （4）网络操作系统： 居右网络功能的操作系统，主要处理资讯共享和通信问题共享性 （5）分布式操作系统： 多台计算机组成，共同合作完成同一个任务（每台计算机都能与其他计算机交换信息，资源共享）把一个大任务划分为多个小任务给不同的计算机处理自治性、透明性，协调性 （6）嵌入式操作系统： 把操作系统放入嵌入式智能芯片中，最整个智能芯片和它所操作、控制的资源进行协调、处理、指挥、控制其系统能及时响应外部事件，在规定时间完成外部事件响应处理，并控制所有实时任务协调一致运行微型化、可定制、有效性、实时性，可靠性、易移植性 （7）微内核操作系统： 将操作系统最基本的部分放入内核中，而绝大部分功能放入外部服务器中实现可扩展性，移植性 5.原理 进行处理机与进程管理、存储管理、设备管理、文件管理和作业管理的工作 5.1进程管理5.2存储管理5.3设备管理5.4文件管理5.5作业管理 6.操作系统的结构设计模式（1）模块化结构 （2）层次化结构 （3）客户/服务器结构 （4）对象模式 （5）对称多处理模式","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.yiyuclub.club/categories/学习笔记/"},{"name":"软考架构师","slug":"学习笔记/软考架构师","permalink":"http://www.yiyuclub.club/categories/学习笔记/软考架构师/"}],"tags":[{"name":"软考","slug":"软考","permalink":"http://www.yiyuclub.club/tags/软考/"},{"name":"架构师","slug":"架构师","permalink":"http://www.yiyuclub.club/tags/架构师/"}]},{"title":"（软考架构师笔记一）计算机组成与体系","slug":"（软考架构师笔记一）计算机组成与体系","date":"2019-05-14T01:03:26.000Z","updated":"2019-10-18T01:52:11.382Z","comments":true,"path":"2019/05/14/（软考架构师笔记一）计算机组成与体系/","link":"","permalink":"http://www.yiyuclub.club/2019/05/14/（软考架构师笔记一）计算机组成与体系/","excerpt":"（软考架构师笔记一）计算机组成与体系","text":"（软考架构师笔记一）计算机组成与体系 1.计算机组成 运算器（算术逻辑单元，ALU）：是在控制器的控制下完成各种算术运算和逻辑运算； 注：其有：算术逻辑单元 ALU，累加寄存器 AC，通用寄存器，数据缓冲寄存器 DR，状态条件寄存器 PSW 控制器：分析和执行指令的部件，也是统一指挥并控制计算机各部件协调工作的中心部件，所依据的是机器指令； 注：其有：程序计数器（pc）,指令寄存器（ir），指令译码器（id），时序部件； 主存储器（主存，内存）：存储现 场操作的信息与中间结果，包括机器指令和数据； 辅存储器（辅存，外存）：存储需要长期保存的各种信息； 输入设备：是把人们编好的程序和原始数据送到计算机中去，并 且将它们转换成计算机内部所能识别和接受的信息方式； 注：其有：键盘、 鼠标、扫描仪； 输出设备：将计算机的处理结果以人或其他设备所能接受的 形式送出计算机； 注：是打印机、显示器； 注：存储器概念由冯诺依曼于1946年提出，由运算器为中心转向存储器为中心 2.存储程序发展 电子管和晶体管时代、集成电路时代（中小规模、大规模、超大规模、甚大规模、极大规模） 存储程序定义 其采用二进制来表示指令与数据；将编好的程序和原始数据事先存入存储器中，然后再启动计算机工作 3.flynn分类1.概念根据指令流与数据流的多倍性特征分类 指令流：机器执行的指令序列数据流：指令流执行时调用的数据序列。（输入与中间结果，不包含输出结果） 2.类别 单指令流单数据流 （SISD）：单控制，单处理，单主存（单处理系统） 单指令流多数据流 （SIMD）：单控制，多处理，多主存（异步执行-&gt;并行、阵列、超级向量处理机） 多指令流单数据流 （MISD）：多控制、单处理、多主存（不常见-&gt;流水线计算机） 多指令流多数据流 （MIMD）：多控制、多处理、多主存（多核处理器） 4.指令系统1.类别 复杂指令集系统（CISI）：增强指令的功能，设置一些功能复杂的指令，把一些原来由软件实现的、常用的功能改用硬件的指令系统来实现 精简指令集系统（RISI） ：是尽量简化指令功能，只保留那些功能简单，能在一个节拍内执行完成指令，较复杂的功能用一段子程序来实现 2.CISI指令集系统特点 指令数量多使用频率相差悬殊支持多种寻址方式指令长度不固定由微程序控制为主可对主单元数据直接处理 3.RISI指令集系统特点单周期完成，简化指令，加快速度 指令数量少寻址方式少长度固定以硬布线逻辑控制为主（即组合逻辑构建控制器）流水线技术，单周期指令执行优化编译器（由于简化了指令、寻址方式等，编译更为简单）cpu通用寄存器多RISI使用cache来改善性能：指令cache和数据cache，互不干扰 5.总线1.概念为多个部件分时共享的公共信息传输线路 共享：多个部件相互交换的信息可以通过这组公共线路传输分时：用一时段只允许一条线路向总线发送消息，超则信号冲突，但接收消息可允许多个 2.按位置分类内部总线和外部总线 内部总线：寄存器之间和算术逻辑部件ALU与控制部件之间传输数据所用的总线 外部总线：CPU与内存RAM、ROM和输入/输出设备接口之间进行通信的通路 在实际中，CPU通过总线实现程序取指令、内存/外设的数据交换，故此总线速度是制约计算机性能的最大因素 3.按功能划分 地址总线：传送地址信息数据总线：传送数据信息控制总线：传送各种控制信号 6.存储器系统1.概念 存放程序和数据的组件,规模较大的存储器往往分成若干级，称为存储器系统 2.分类高速缓冲存储器(cache)、主存、辅存（计算机采用多级存储体系） cache：cpu与主存之间，速度更快、容量更小(来存放当前最急需处理的程序和数据，以便快速地向 CPU 提供指令和数据) 主存：cpu直接访问，速度快、容量小(来存放当前正在执行的程序和数据) 辅存：不可直接访问，速度慢、容量大,价格低（存放暂时不参与运行的程序和数据，CPU 不可以直接访问辅存） 注：cpu（寄存器）最快 3.局部性原理程序在执行时呈现出局部性规律 时间局部性：当指令执行后，短时间内将可能再次执行空间局部性：存储单元被访问后，周围的也将可能被访问 4.存取方式 顺序存取：以记录的形式进行组织。对数据的访问必须按特定的线性顺序进行（磁带存储器） 直接存取：使用一个共享的读写装置对所有的数据进行访问，每个数据块都拥有唯一的地址标识，读写装置可以直接移动到目的数据块所在位置进行访问，时间可改变（磁盘存储器） 随机存取：每一个可寻址单元都具有自己唯一的地址和读写装置，系统可以在相同的时间内对任意一个存储单元的数据进行访问，而与先前的访问序列无关（主存存储器） 间接存取：每个单元都有自己的读写装置，某一单元进行读写是取决于其内容而不是其地址，读写时间也是一个常数，可以对所有的存储单元的特定位进行比较，选择符合条件的单元进行访问（cache） 5.主存储器概念 存放计算机运行期间所需要的程序和数据，CPU可直接随机地进行读/写(由于CPU需要频繁的访问主存，故主存性能是影响整个计算机的关键因素) 类别随机存取存储器（RAM）和只读存储器(ROM) RAM（可读可写，断电后无法保存）：有DRAM（动态）和SRAM（静态）；DRAM:随时间消失，需刷新电路，速度较慢，较便宜；SRAM:不断电能一直保持，无需刷新电路，速度较快,容量较小，较贵 ROM：可读不可写，断电内容不会消失（一般用于存放系统程序 BIOS） 存储器编址的方式存储器编址单位 存储器中每个单元的位数是相同且固定的 编址方式 字编址（可大可小，按题目所给）字节编址（1字节=8位） 6.辅助存储器1.磁带：顺序存储设备，存取时间长，容量大，价格低 2.硬盘：一个硬盘有多个磁盘片，每个磁盘片有两个记录面，每个记录面一个磁头号（记录面号，从0开始，所有记录面的磁头号一起随主轴旋转），每个记录面有n个磁道（最外为0号磁道），每个磁道上有若干个段（扇区，从1开始） 3.磁盘访问时间=寻道时间（寻找磁道）+旋转延迟时间（寻找扇区） 7.缓存存储器（cache） 是提高 CPU 数据输入输出的速率 介绍采用相联存储器（ContentAddressable Memory，CAM） 是一种基于数据内容进行访问的存储设备。当对其写入数据时，CAM 能够自动选择一个未用的空单元进行存储；当要读出数据时，不是给出其存储单元的地址，而是直接给出该数据或者该数据的一部分内容，CAM 对所有存储单元中的数据同时进行比较，并标记符合条件的所有数据以供读取。 cache基本原理 根据程序的局部性特征改善性能，把近期或未来要使用的或与正在使用的临近单元上的数据，放入cache中，cpu访问cache找到数据则直接读取，未找到则从主存中读取数据，并把要读取的数据放入cache中，加快读取速度。 “Cache+主存储器”的系统的平均周期 = Cache命中Cache访问周期时间 + Cache未命中（主存）主存周期时间 注：增加 Cache块大小 和 提高相联度 可以增加命中率 映射机制（Cache 的地址映射） 当 CPU 发出访存请求后，存储器地址先被送到 Cache 控制器以确定所需数据是否已在 Cache 中，若命中则直接对 Cache 进行访问 主存和 Cache 将均分成容量相同的块（页） 映射方式(1)直接映像 以随机存取存储器作为 Cache 存储器,映像时主存地址被分成三个部分，从高到低依次为：区号、页号以及页内地址（冲突大） (2)全相联映像：略 (3)组相连映像：略 8.流水线流水线定义 把一个任务分解为若干顺序执行的子任务，不同的子任务由不同的执行机构负责执行，而这些机构可以同时并行工作。在任一时刻，任一任务只占用其中一个执行机构，这样就可以实现多个任务的重叠执行，以提高工作效率 流水线周期 需要处理的工作分为 N 个阶段，最耗时的那一段所消耗的时间为流水线周期 例如：使用流水线技术执行 100 条指令，每条指令取指 2ms，分析 4ms，执行 1ms，则流水线周期为 4ms 流水线执行时间 流水线执行时间 = n * 流水线周期 (n为任务数量) 流水线执行时间 = 第 1 条指令的执行时间+（n-1）*流水线周期 (n为任务数量) N条指令流水线执行时间 ＝ 流水线启动时间 + N×流水线时间最长部件的时间 + 流水线排空时间 流水线吞吐率 在单位时间内流水线所完成的任务数量或输出的结果数量 流水线吞吐率 = 指令条数/流水线执行时间 流水线加速比 完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比 不使用流水线所用的时间:使用流水线所用的时间","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.yiyuclub.club/categories/学习笔记/"},{"name":"软考架构师","slug":"学习笔记/软考架构师","permalink":"http://www.yiyuclub.club/categories/学习笔记/软考架构师/"}],"tags":[{"name":"软考","slug":"软考","permalink":"http://www.yiyuclub.club/tags/软考/"},{"name":"架构师","slug":"架构师","permalink":"http://www.yiyuclub.club/tags/架构师/"}]},{"title":"置顶说明","slug":"置顶说明","date":"2019-05-07T01:06:21.000Z","updated":"2019-06-24T09:13:28.050Z","comments":true,"path":"2019/05/07/置顶说明/","link":"","permalink":"http://www.yiyuclub.club/2019/05/07/置顶说明/","excerpt":"基本格式","text":"基本格式 代码块 aaaaaaaaa bbbbbbbbb cccccccccc 一级标题二级标题我也许裂变这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://www.yiyuclub.club/categories/前端技术/"},{"name":"测试文章","slug":"前端技术/测试文章","permalink":"http://www.yiyuclub.club/categories/前端技术/测试文章/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.yiyuclub.club/tags/hexo/"}]},{"title":"学习从安装开始之maven","slug":"学习从安装开始之maven","date":"2018-01-04T12:28:00.000Z","updated":"2019-07-01T00:16:25.357Z","comments":true,"path":"2018/01/04/学习从安装开始之maven/","link":"","permalink":"http://www.yiyuclub.club/2018/01/04/学习从安装开始之maven/","excerpt":"学习从安装开始之maven","text":"学习从安装开始之maven maven下载1.本机系统：win10 64位2.本机jdk版本：jdk1.83.maven下载地址：http://maven.apache.org/download.cgi maven安装1.解压maven压缩包，我这maven路径为E:\\maven\\apache-maven-3.5.2。2.配置环境变量，打开我的电脑-属性-高级系统设置-环境变量–系统变量，新建 M2_HOME（E:\\maven\\apache-maven-3.5.2），编辑path（%M2_HOME%\\bin），注意前后分号。3.win+r输入cmd，进到命令行输入mvn -v，出现如图即安装成功。 maven仓库配置1.新建仓库，在合适位置创建文件夹（E:\\maven\\maven_repo\\repository）。2.打开maven根目录下的conf，打开settings.xml，找到如图localRepository并复制一行如图设置仓库地址。3.由于国外的下载速度慢，在settings.xml中添加一个镜像地址mirro。复制如下粘贴进入mirros即可（阿里云的）。 &lt;mirror&gt; &lt;!--This sends everything else to /public --&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt; 4.复制一份settings.xml进入E:\\maven\\maven_repo（E:\\maven\\maven_repo\\repository的上一级）5.win+r输入cmd，进到命令行输入mvn help:system，会下载文件到你设置的仓库中，第一次会比较久。6.仓库配置结束。 4.eclipse添加maven1.打开eclipse–&gt;Window–&gt;Preferences，找到maven。2.如图添加maven安装路径。3.点击Maven下面的User Settings选项，如图配置（global settings：本机器的配置，使用这台机器的所有用户都是用这个配置，user settings：当前用户的配置）4.Apply即可。","categories":[{"name":"java","slug":"java","permalink":"http://www.yiyuclub.club/categories/java/"},{"name":"maven","slug":"java/maven","permalink":"http://www.yiyuclub.club/categories/java/maven/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.yiyuclub.club/tags/java/"},{"name":"maven","slug":"maven","permalink":"http://www.yiyuclub.club/tags/maven/"}]},{"title":"学习从安装开始之mysql（解压版）","slug":"学习从安装开始之mysql","date":"2018-01-03T08:10:42.000Z","updated":"2019-07-15T03:21:46.016Z","comments":true,"path":"2018/01/03/学习从安装开始之mysql/","link":"","permalink":"http://www.yiyuclub.club/2018/01/03/学习从安装开始之mysql/","excerpt":"学习从安装开始之mysql（解压版）","text":"学习从安装开始之mysql（解压版） 1.mysql下载 打开https://dev.mysql.com/downloads/mysql/ 选择对应本机电脑的版本（我这64位，现在最新mysql为5.7.20），Dowbload。 点击No thanks, just start my download，完成下载。 2.mysql的安装（5.7.20（解压版））1.解压mysql压缩包，如图设置环境变量（我这mysql bin路径为E:\\mysql\\mysql-5.7.20-winx64\\bin）。2.由于mysql5.7.20版本没有ini文件和data目录，所以在mysql根目录新建文本更改为my.ini。复制以下内容并更改basedir和datadir路径。data后面会说明。 [client] port=3306 default-character-set=utf8 [mysqld] # 设置为自己MYSQL的安装目录 basedir=E:\\mysql\\mysql-5.7.20-winx64 # 设置为MYSQL的数据目录 datadir=E:\\mysql\\mysql-5.7.20-winx64\\data port=3306 character_set_server=utf8 sql_mode=NO_ENGINE_SUBSTITUTION,NO_AUTO_CREATE_USER #开启查询缓存 explicit_defaults_for_timestamp=true skip-grant-tables 3.使用管理员权限打开cmd，在cmd中进入mysql bin目录。4.输入 mysqld –initialize-insecure –user=mysql 回车，看到mysql目录下出现了data目录。5.再输入mysqld -install回车，成功后如图。6.最后输入net start mysql启动mysql即可。7.观察mysql是否开启，可以win+r后输入services.msc，找到MySQL服务即可看到。8.命令： 启动: net start MySQL停止: net stop MySQL卸载: sc delete MySQL 3.安装mysql遇到的问题 找不到dll（win10） 解决方案:1.打开https://www.microsoft.com/zh-cn/download/details.aspx?id=48145，下载vc_redist.x64.exe和vc_redist.x86.exe安装 2.以上不行的话，下载对应dll放于对应文件夹中（或者使用安全软件修复） 3.以上不行的话，下载DirectXRepair35修复即可（更新c++库） mysql不是内部或外部命令 解决方案：环境变量中path路径错误，更改即可。4.mysql的简单设置（密码）1.在cmd输入mysql即可进入mysql数据库。2.show databases展示数据库，use mysql使用名为mysql数据库。3.show tables观看表，然后找到user表，select user,host,authentication_string from user; 后可看到数据。（5.7password改为authentication_string）。4.根据mysql知识更改user表的数据即可。如： update user set authentication_string=’root’ where user=’root’ and host=’localhost’; 再输入FLUSH PRIVILEGES;可更改密码。5.quit；退出后输入mysql –uroot –proot即可密码登陆。6.如果遗忘密码，可net stop MySQL停止MySQL服务，在net start MySQL –skip-grant-tables无密码登陆即可解决。","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/categories/MYSQL/"},{"name":"MYSQL安装","slug":"MYSQL/MYSQL安装","permalink":"http://www.yiyuclub.club/categories/MYSQL/MYSQL安装/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.yiyuclub.club/tags/数据库/"},{"name":"MYSQL","slug":"MYSQL","permalink":"http://www.yiyuclub.club/tags/MYSQL/"}]},{"title":"学习从安装开始之tomcat","slug":"学习从安装开始之tomcat","date":"2017-12-05T13:05:39.000Z","updated":"2019-07-01T00:15:44.609Z","comments":true,"path":"2017/12/05/学习从安装开始之tomcat/","link":"","permalink":"http://www.yiyuclub.club/2017/12/05/学习从安装开始之tomcat/","excerpt":"学习从安装开始之tomcat","text":"学习从安装开始之tomcat 1.tomcat是什么Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。（出自百度百科 https://baike.baidu.com/item/tomcat/255751?fr=aladdin） 2.tomcat的安装1.打开链接： https://tomcat.apache.org/download-90.cgi2.如图，在1处选择版本，在2处选择windows解压版，下载。3.放到合适位置解压，得到如图：4.打开bin目录，双击startup.bat，会弹出如图的命令窗口，（如果闪现则是jdk没配置好）5.打开浏览器输入：http://localhost:8080 ，出现如图猫咪则安装成功6.关闭命令窗口或者双击bin目录下的shutdown.bat即可关闭tomcat7.如果出现端口被占用，打开%tomcat%/conf/server.xml文件，找到如图修改port即可 3.tomcat目录结构 1.bin： tomcat的命令（含有启动和关闭命令）2.bonf： tomcat的配置信息，有server.xml核心配置文件3.lib： tomcat所需jar包和扩展包4.logs： 运日志文件5.temp： 临时目录6.wepapps： 共享资源目录 （不可单个文件）7.work： 运行目录，运行时临时产生的临时文件 4.分析举例：http://localhost:8080/xiaoyi/xiaoyi.html 1.http：协议2.localhost:域名（会解析成本机ip）3.8080：端口号4.xiaoyi： webapps下的文件夹5.xiaoyi.html：xiaoyi文件夹下的html文件 tips：webapps下的不能为单个文件，如没有xiaoyi这个文件夹（如：http://localhost:8080/xiaoyi.html），会报404。 5.http常见网络状态码 200：客户端请求成功，服务器正确处理了请求400：请求有误，服务器不能理解403：服务器拒绝请求404：服务器找不到请求的网页500：服务器错误（服务器程序问题） 更多状态码请点击（来自开源中国）： http://tool.oschina.net/commons?type=5","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.yiyuclub.club/categories/服务器/"},{"name":"tomcat","slug":"服务器/tomcat","permalink":"http://www.yiyuclub.club/categories/服务器/tomcat/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://www.yiyuclub.club/tags/服务器/"},{"name":"tomcat","slug":"tomcat","permalink":"http://www.yiyuclub.club/tags/tomcat/"}]},{"title":"学习从安装开始之jdk","slug":"学习从安装开始之jdk","date":"2017-12-05T11:29:53.000Z","updated":"2019-07-01T00:16:09.584Z","comments":true,"path":"2017/12/05/学习从安装开始之jdk/","link":"","permalink":"http://www.yiyuclub.club/2017/12/05/学习从安装开始之jdk/","excerpt":"学习从安装开始之jdk","text":"学习从安装开始之jdk 1.jdk是什么？jdk是java语言开发工具包，含有java的运行环境与java工具。 2.如何下载jdk （以windows为例） 搜索网页：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html （或者百度：搜索“jdk”，第一个） 勾选Accept….，选择windows下载。3.安装jdk双击下好的文件，更改jdk和jre地址（如jdk:E:\\css\\java\\jdk, jre:E:\\css\\java\\jre）（把jre安装进jdk文件夹里，我这后面会出问题）4.配置jdk1.右键单击我的电脑左键，打开“属性”，左侧“高级系统设置”，打开环境设置2.在系统变量中单击“新建”，如图设置变量名（JAVA_HOME）和变量值（你的jdk地址，不是jre）3.在系统变量中找到“path”，点击编辑，在末尾添加：%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;（如果之前没有分号，请添加英文下的分号）4.一路确定即可，打开cmd（win+r后输入cmd），在命令窗口欧输入javac（编译环境）和java（运行环境），看到如图界面环境就安装好了。","categories":[{"name":"java","slug":"java","permalink":"http://www.yiyuclub.club/categories/java/"},{"name":"jdk","slug":"java/jdk","permalink":"http://www.yiyuclub.club/categories/java/jdk/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.yiyuclub.club/tags/java/"},{"name":"jdk","slug":"jdk","permalink":"http://www.yiyuclub.club/tags/jdk/"}]}]}